{% extends "base.html" %}
{% block title %}Dashboard - GBot Web{% endblock %}

{% block content %}
<!-- Tab Navigation - Hidden, tabs now in sidebar dropdown -->
<div class="tab-navigation" style="display: none;">
    <nav>
        <button class="tab-button active" onclick="showTab('tab1')">
            <i class="fas fa-user-friends"></i>
            <span>Account & User Mgmt</span>
        </button>
        <button class="tab-button" onclick="showTab('tab2')">
            <i class="fas fa-user-plus"></i>
            <span>User Create/Delete/Domain</span>
        </button>
        <button class="tab-button" onclick="showTab('tab3')">
            <i class="fas fa-exchange-alt"></i>
            <span>DNS & SMTP</span>
        </button>
    </nav>
</div>

<!-- Tab 1: Account & User Management (existing content) -->
<div id="tab1" class="tab-content active">
    <!-- Account Selection & Authentication -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-user-friends"></i>
                Account Selection & Authentication
            </h3>
        </div>

        <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end; margin-bottom: 20px;">
            <div class="form-group-github">
                <label for="account-select" class="form-label-github">
                    <i class="fas fa-user-circle"></i> Select Account
                </label>
                <select id="account-select" class="form-control-github">
                    <option value="">Type to search accounts...</option>
                    <!-- Populated dynamically via JavaScript -->
                </select>
            </div>
            <button onclick="authenticateAccount()" class="btn-github btn-github-primary">
                <i class="fas fa-key"></i> Authenticate Selected
            </button>
        </div>

        <div style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 20px;">
            <button onclick="openAddAccountModal()" class="btn-github btn-github-primary">
                <i class="fas fa-plus-circle"></i> Add Account
            </button>
            <button onclick="openS3ImportModal()" class="btn-github"
                style="background-color: #0969da; border-color: #0969da; color: white;">
                <i class="fas fa-cloud-download-alt"></i> Import from S3
            </button>
            {% if session.role == 'admin' %}
            <button onclick="forceTokenStatusCheck()" class="btn-github"
                style="background-color: var(--color-warning-emphasis); border-color: var(--color-warning-emphasis); color: #ffffff;">
                <i class="fas fa-search"></i> Check Token Status Now (Admin)
            </button>
            {% endif %}
        </div>

        <!-- Search and Account List Area -->
        <div class="account-management-area">
            <div class="search-and-list">
                <input type="text" id="account-search" placeholder="Search accounts..." class="search-input"
                    autocomplete="off" oninput="debounceSearchAccounts(this.value)">

                <!-- Container for async accounts -->
                <div id="account-list-area" class="account-list custom-scrollbar">
                    <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                        <i class="fas fa-search"></i> Use search to find accounts
                    </div>
                </div>
            </div>

            <div class="account-actions">
                <button onclick="authenticateFromList()" class="action-button" style="height: 50px; font-size: 12px;">
                    <i class="fas fa-key"></i> Authenticate<br>(List Selection)
                </button>
                {% if session.role == 'admin' %}
                <button onclick="openBulkDeleteModal()" class="action-button delete-button"
                    style="background-color: #dc3545; border-color: #dc3545; height: 50px; font-size: 12px;">
                    <i class="fas fa-trash"></i> Bulk Delete<br>(Admin Only)
                </button>
                {% endif %}
                <button onclick="deleteFromList()" class="action-button delete-button"
                    style="height: 50px; font-size: 12px;">
                    <i class="fas fa-trash"></i> Delete Account<br>(List Selection)
                </button>
            </div>
        </div>
        <div id="account-count-display" class="count-display">
            <span id="account-stats">Loading account statistics...</span>
        </div>
        <div id="auth-status" class="status-box">
            <p>No account authenticated</p>
        </div>

        <!-- OTP Generator -->
        <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #d0d7de;">
            <h4 style="color: #24292f; margin-bottom: 16px; font-size: 16px;">
                <i class="fas fa-key"></i> OTP Generator
            </h4>

            <div style="display: grid; grid-template-columns: 1fr auto auto; gap: 12px; align-items: end;">
                <div class="form-group-github">
                    <label
                        style="display:flex; align-items:center; gap:8px; margin-bottom:8px; font-size:13px; color:#57606a;">
                        <input type="checkbox" id="otp-lowercase-toggle">
                        Force lowercase before generating OTP
                    </label>
                    <label for="otp-account-input" class="form-label-github">
                        <i class="fas fa-user"></i> Account Name
                    </label>
                    <input type="text" id="otp-account-input" class="form-control-github"
                        placeholder="Enter account name (e.g., email address)" autocapitalize="none" autocorrect="off"
                        spellcheck="false">
                </div>

                <button onclick="generateOTP()" class="btn-github btn-github-primary">
                    <i class="fas fa-key"></i> Generate OTP
                </button>

                <button onclick="copyOTP()" class="btn-github" id="copy-otp-btn" disabled>
                    <i class="fas fa-copy"></i> Copy OTP
                </button>
            </div>

            <div id="otp-status" class="status-box" style="margin-top: 12px; display: none;">
                <p id="otp-status-text">Enter account and click 'Generate OTP'</p>
            </div>

            <div id="otp-result" class="data-display" style="margin-top: 12px; display: none;">
                <h4>Generated OTP:</h4>
                <div id="otp-code-display"
                    style="font-family: monospace; font-size: 18px; font-weight: bold; color: #0969da; text-align: center; padding: 12px; background-color: #f6f8fa; border: 1px solid #d0d7de; border-radius: 6px;">
                </div>
            </div>
        </div>
    </div>







    <!-- OAuth Authorization Modal -->
    <div id="oauthModal" class="modal" style="display: none;">
        <div class="modal-content"
            style="background: var(--bg-modal) !important; backdrop-filter: blur(28px) !important; border: 1px solid var(--border-panel) !important;">
            <div class="modal-header">
                <h3 class="modal-title">
                    <i class="fas fa-link"></i> OAuth Authorization Required
                </h3>
                <button type="button" class="btn-github" onclick="closeOAuthModal()" style="margin-left: auto;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <p>Please copy this link and open it in your browser to authorize the account:</p>
                <div id="oauthUrl" class="data-display"
                    style="font-family: monospace; word-break: break-all; margin: 16px 0;"></div>
                <div
                    style="background-color: rgba(9, 105, 218, 0.1); border: 1px solid var(--color-accent-emphasis); border-radius: 6px; padding: 12px; color: var(--color-accent-fg); font-size: 14px;">
                    <i class="fas fa-lightbulb"></i>
                    <strong>Tip:</strong> You can copy this link to use in another browser or app for authorization.
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="copyOAuthUrl()" class="btn-github">
                    <i class="fas fa-copy"></i> Copy Link
                </button>
                <button onclick="openOAuthUrl()" class="btn-github btn-github-primary">
                    <i class="fas fa-external-link-alt"></i> Open Link
                </button>
                <button onclick="closeOAuthModal()" class="btn-github">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
        </div>
    </div>

    <!-- Add Account Modal -->
    <div id="addAccountModal" class="modal" style="display: none;">
        <div class="modal-content"
            style="background: var(--bg-modal) !important; backdrop-filter: blur(28px) !important; border: 1px solid var(--border-panel) !important;">
            <div class="modal-header">
                <h3 class="modal-title">
                    <i class="fas fa-plus-circle"></i> Add New Account
                </h3>
                <button type="button" class="btn-github" onclick="closeAddAccountModal()" style="margin-left: auto;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="glass-info-box" style="margin-bottom: 16px;">
                    <i class="fas fa-info-circle"></i>
                    <strong>Instructions:</strong> Enter the account email and upload the service account JSON
                    credentials file to add a new account.
                </div>

                <div class="form-group-github" style="margin-bottom: 16px;">
                    <label for="addAccountEmail" class="form-label-github">
                        <i class="fas fa-envelope"></i> Account Email (Admin Email)
                    </label>
                    <input type="email" id="addAccountEmail" class="form-control-github"
                        placeholder="admin@yourdomain.com" required>
                    <small style="color: #656d76; font-size: 12px; margin-top: 4px; display: block;">
                        This should be the admin email address for the Google Workspace account.
                    </small>
                </div>

                <div class="form-group-github" style="margin-bottom: 16px;">
                    <label for="addAccountName" class="form-label-github">
                        <i class="fas fa-tag"></i> Account Name (Optional)
                    </label>
                    <input type="text" id="addAccountName" class="form-control-github"
                        placeholder="My Workspace Account">
                    <small style="color: #656d76; font-size: 12px; margin-top: 4px; display: block;">
                        A friendly name for this account. If left blank, the email will be used.
                    </small>
                </div>

                <div class="form-group-github" style="margin-bottom: 16px;">
                    <label for="addAccountJsonFile" class="form-label-github">
                        <i class="fas fa-file-code"></i> Service Account JSON File
                    </label>
                    <input type="file" id="addAccountJsonFile" class="form-control-github" accept=".json" required>
                    <small style="color: #656d76; font-size: 12px; margin-top: 4px; display: block;">
                        Upload the service account credentials JSON file downloaded from Google Cloud Console.
                    </small>
                </div>

                <div id="addAccountJsonPreview" style="display: none; margin-bottom: 16px;">
                    <label class="form-label-github">
                        <i class="fas fa-check-circle" style="color: #28a745;"></i> JSON File Preview
                    </label>
                    <div class="glass-code-block" style="max-height: 150px; overflow-y: auto;">
                        <div id="addAccountJsonContent"></div>
                    </div>
                </div>

                <div id="addAccountStatus" style="display: none; margin-top: 16px;">
                    <div id="addAccountStatusContent" style="padding: 12px; border-radius: 6px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="submitAddAccount()" class="btn-github btn-github-primary" id="addAccountSubmitBtn">
                    <i class="fas fa-plus"></i> Add Account
                </button>
                <button onclick="closeAddAccountModal()" class="btn-github">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- S3 Import Accounts Modal -->
    <div id="s3ImportModal" class="modal" style="display: none;">
        <div class="modal-content"
            style="max-width: 700px; background: var(--bg-modal) !important; backdrop-filter: blur(28px) !important; border: 1px solid var(--border-panel) !important;">
            <div class="modal-header">
                <h3 class="modal-title">
                    <i class="fas fa-cloud-download-alt"></i> Import Accounts from S3
                </h3>
                <button type="button" class="btn-github" onclick="closeS3ImportModal()" style="margin-left: auto;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="glass-info-box" style="margin-bottom: 16px;">
                    <i class="fas fa-info-circle"></i>
                    <strong>Instructions:</strong> Enter account emails (one per line). The system will fetch JSON files
                    from S3 bucket <code>dev-app-passwords/workspace-keys/</code>.
                </div>

                <div class="form-group-github" style="margin-bottom: 16px;">
                    <label for="s3ImportAccounts" class="form-label-github">
                        <i class="fas fa-list"></i> Account Emails (one per line)
                    </label>
                    <textarea id="s3ImportAccounts" class="form-control-github" rows="10"
                        placeholder="admin@domain1.com&#10;webmail@domain2.com&#10;support@domain3.co.uk"
                        style="font-family: 'Courier New', monospace; font-size: 14px;"></textarea>
                    <small style="color: #656d76; font-size: 12px; margin-top: 4px; display: block;">
                        Each JSON file should be named <code>{email}.json</code> in the S3 bucket.
                    </small>
                </div>

                <div id="s3ImportProgress" style="display: none; margin-bottom: 16px;">
                    <div class="glass-code-block">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span id="s3ImportStatus">Importing...</span>
                            <span id="s3ImportCount">0/0</span>
                        </div>
                        <div
                            style="background: var(--input-bg); border-radius: 6px; height: 8px; overflow: hidden; border: 1px solid var(--border-panel);">
                            <div id="s3ImportProgressBar"
                                style="background: var(--accent-primary); height: 100%; width: 0%; transition: width 0.3s;">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="s3ImportResults" style="display: none; margin-bottom: 16px;">
                    <h6 style="font-weight: 600; margin-bottom: 8px; color: #24292f;">
                        <i class="fas fa-list-check"></i> Import Results
                    </h6>
                    <div id="s3ImportResultsContent" class="glass-code-block"
                        style="max-height: 200px; overflow-y: auto;">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="executeS3Import()" class="btn-github btn-github-primary" id="s3ImportBtn">
                    <i class="fas fa-cloud-download-alt"></i> Import from S3
                </button>
                <button onclick="closeS3ImportModal()" class="btn-github">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Bulk Delete Accounts Modal -->
    <div id="bulkDeleteModal" class="modal" style="display: none;">
        <div class="modal-content"
            style="background: var(--bg-modal) !important; backdrop-filter: blur(28px) !important; border: 1px solid var(--border-panel) !important;">
            <div class="modal-header">
                <h3 class="modal-title">
                    <i class="fas fa-trash-alt"></i> Bulk Delete Accounts
                </h3>
                <button type="button" class="btn-github" onclick="closeBulkDeleteModal()" style="margin-left: auto;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="glass-warning-box" style="margin-bottom: 16px;">
                    <i class="fas fa-exclamation-triangle"></i>
                    <strong>Warning:</strong> This action will permanently delete the specified accounts. This cannot be
                    undone!
                </div>

                <div class="form-group-github">
                    <label for="bulkDeleteAccounts" class="form-label-github">
                        <i class="fas fa-list"></i> Account Names (one per line)
                    </label>
                    <textarea id="bulkDeleteAccounts" class="form-control-github" rows="8"
                        placeholder="Enter account names, one per line:&#10;admin@domain1.com&#10;user@domain2.com&#10;manager@domain3.com"
                        style="font-family: 'Courier New', monospace; font-size: 14px;"></textarea>
                    <small style="color: #656d76; font-size: 12px;">
                        Enter the exact account names (email addresses) that you want to delete, one per line.
                    </small>
                </div>

                <div id="bulkDeleteProgress" style="display: none; margin-top: 16px;">
                    <div class="glass-code-block">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span id="bulkDeleteStatus">Processing...</span>
                            <span id="bulkDeleteCount">0/0</span>
                        </div>
                        <div
                            style="background: var(--input-bg); border-radius: 6px; height: 8px; overflow: hidden; border: 1px solid var(--border-panel);">
                            <div id="bulkDeleteProgressBar"
                                style="background: #dc3545; height: 100%; width: 0%; transition: width 0.3s; border-radius: 6px;">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="bulkDeleteResults" style="display: none; margin-top: 16px;">
                    <h6 style="font-weight: 600; margin-bottom: 8px; color: #24292f;">
                        <i class="fas fa-list-check"></i> Deletion Results
                    </h6>
                    <div id="bulkDeleteResultsContent" class="glass-code-block"
                        style="max-height: 200px; overflow-y: auto;">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="executeBulkDelete()" class="btn-github btn-github-danger" id="bulkDeleteExecuteBtn">
                    <i class="fas fa-trash-alt"></i> Delete Accounts
                </button>
                <button onclick="closeBulkDeleteModal()" class="btn-github">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- User Listing & Actions -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-users"></i>
                User Listing & Basic Actions
            </h3>
        </div>

        <div class="button-row">
            <button onclick="retrieveUsers()" class="btn-github btn-github-primary">
                <i class="fas fa-chart-bar"></i> Retrieve All Users
            </button>
            <button onclick="clearUserList()" class="btn-github">
                <i class="fas fa-broom"></i> Clear List
            </button>
            <button onclick="copyAllUsers()" class="btn-github">
                <i class="fas fa-copy"></i> Copy All
            </button>
        </div>

        <div id="user-display" class="data-display">
            <div class="status-info">
                <p><strong><i class="fas fa-users"></i> User Management</strong></p>
                <p>Click "Retrieve All Users" to load and display all users from your Google Workspace.</p>
                <p><small>This will show user status (Active/Suspended), admin privileges, and provide options for bulk
                        operations.</small></p>
            </div>
        </div>

        <!-- Individual User Actions -->
        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 16px; align-items: end; margin-top: 16px;">
            <div class="form-group-github">
                <label for="suspend-user-email" class="form-label-github">
                    <i class="fas fa-user-slash"></i> Suspend User
                </label>
                <input type="email" id="suspend-user-email" class="form-control-github" placeholder="user@domain.com">
            </div>
            <div class="form-group-github">
                <label for="unsuspend-user-email" class="form-label-github">
                    <i class="fas fa-user-check"></i> Unsuspend User
                </label>
                <input type="email" id="unsuspend-user-email" class="form-control-github" placeholder="user@domain.com">
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="suspendUser()" class="btn-github btn-github-warning">
                    <i class="fas fa-user-slash"></i> Suspend
                </button>
                <button onclick="unsuspendUser()" class="btn-github btn-github-success">
                    <i class="fas fa-user-check"></i> Unsuspend
                </button>
            </div>
        </div>


        <div id="user-count" class="count-display">Total Users: 0</div>

        <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end; margin-top: 16px;">
            <div class="form-group-github">
                <label for="new-password" class="form-label-github">
                    <i class="fas fa-lock"></i> New Password for All Users
                </label>
                <input type="password" id="new-password" class="form-control-github"
                    placeholder="Enter new password for all users" autocomplete="new-password" readonly
                    onfocus="this.removeAttribute('readonly');">
            </div>
            <button onclick="updateAllPasswords()" class="btn-github btn-github-danger">
                <i class="fas fa-key"></i> Update Password (All)
            </button>
        </div>
    </div>


    <!-- Activity Log Section -->
    <div class="github-card" style="margin-top: 24px;">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-list-alt"></i>
                Activity Log
            </h3>
            <div class="button-row">
                <button onclick="clearLogs()" class="btn-github btn-github-secondary"
                    style="font-size: 12px; padding: 4px 8px;">
                    <i class="fas fa-trash"></i> Clear Logs
                </button>
                <button onclick="copyLogs()" class="btn-github" style="font-size: 12px; padding: 4px 8px;">
                    <i class="fas fa-copy"></i> Copy Logs
                </button>
                <button onclick="downloadLogs()" class="btn-github" style="font-size: 12px; padding: 4px 8px;">
                    <i class="fas fa-download"></i> Download
                </button>
            </div>
        </div>

        <div id="activity-log" class="log-display" style="
            background: #f8f9fa; 
            border: 1px solid #e1e4e8; 
            border-radius: 6px; 
            padding: 12px; 
            max-height: 300px; 
            overflow-y: auto; 
            font-family: 'Courier New', monospace; 
            font-size: 12px; 
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        ">
            <div style="color: #6a737d; font-style: italic;">
                üìù Activity log will appear here...
            </div>
        </div>

        <div style="margin-top: 8px; font-size: 11px; color: #6a737d;">
            <i class="fas fa-info-circle"></i>
            This log shows all user management activities, API calls, and system messages.
        </div>
    </div>

    <!-- Domain Info
    <div class="section">
        <h3>üåê Domain Info & Subdomain Utility</h3>
        
        <div class="button-row">
            <button onclick="retrieveDomains()">üîç Retrieve Domains</button>
            <button onclick="clearDomainDisplay()">üßπ Clear Display</button>
        </div>
        
        <div id="domain-display" class="data-display">
            <p>Click 'Retrieve Domains' to view domains here...</p>
        </div>
    </div> -->

    <!-- Suspended Users -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-user-slash"></i>
                Suspended User Management
            </h3>
        </div>

        <div class="button-row">
            <button onclick="loadSuspendedUsers()" class="btn-github btn-github-primary">
                <i class="fas fa-search"></i> Load Suspended Users
            </button>
            <button onclick="copySuspendedUsers()" class="btn-github">
                <i class="fas fa-copy"></i> Copy Selected
            </button>
            <button onclick="refreshSuspendedUsers()" class="btn-github">
                <i class="fas fa-sync-alt"></i> Refresh Status
            </button>
            <button onclick="clearSuspendedUsers()" class="btn-github">
                <i class="fas fa-broom"></i> Clear Display
            </button>
        </div>

        <div id="suspended-display" class="data-display">
            <div class="status-info">
                <p><strong><i class="fas fa-user-slash"></i> Suspended User Management</strong></p>
                <p>Click "Load Suspended Users" to check for suspended accounts in your Google Workspace.</p>
                <p><small>This will show all users with suspended status, including their names, emails, and admin
                        privileges.</small></p>
            </div>
        </div>

        <div id="suspended-count" class="count-display">Suspended Users: 0</div>

    </div>
</div>

<!-- Tab 2: User Create/Delete/Domain -->
<div id="tab2" class="tab-content">

    <!-- Bulk Account Management -->
    <div class="github-card" style="margin-bottom: 24px; border: 2px solid #0969da;">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-users-cog"></i>
                Bulk Account Management
            </h3>
        </div>
        <p style="color: #656d76; margin-bottom: 16px;">
            Create users for multiple accounts in bulk. All accounts will be authenticated using saved Authenticators in
            parallel.
        </p>
        <button onclick="openBulkAccountModal()" class="btn-github btn-github-primary" style="width: 100%;">
            <i class="fas fa-layer-group"></i>
            Manage Bulk Accounts
        </button>

        <!-- Results Display Section -->
        <div id="bulk-account-results"
            style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid #d0d7de;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <h4 style="color: #24292f; margin: 0; font-size: 16px;">
                    <i class="fas fa-list"></i>
                    Created Users (user:password format)
                </h4>
                <button onclick="copyBulkAccountResults()" class="btn-github" style="margin-left: 8px;">
                    <i class="fas fa-sync-alt"></i>
                    Retrieve & Copy All Users
                </button>
            </div>
            <div class="form-group-github">
                <textarea id="bulk-account-results-text" class="form-control-github" rows="15" readonly
                    style="font-family: 'Courier New', monospace; font-size: 13px; background-color: var(--input-bg);"></textarea>
            </div>
            <div id="bulk-account-summary" class="glass-code-block" style="margin-top: 12px;">
                <!-- Summary will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Bulk Account Modal -->
    <div id="bulk-account-modal" class="modal" style="display: none;">
        <div class="modal-content"
            style="max-width: 1200px; width: 95%; max-height: 90vh; display: flex; flex-direction: column; background: var(--bg-modal) !important; backdrop-filter: blur(28px) !important; border: 1px solid var(--border-panel) !important;">
            <div class="modal-header" style="flex-shrink: 0;">
                <h3 style="margin: 0;">
                    <i class="fas fa-users-cog"></i>
                    Bulk Account Management
                </h3>
                <span class="close" onclick="closeBulkAccountModal()">&times;</span>
            </div>
            <div class="modal-body" style="overflow-y: auto; flex: 1; padding-right: 10px;">
                <p style="color: #656d76; margin-bottom: 16px;">
                    <i class="fas fa-info-circle"></i>
                    Each account can have its own number of users, domain, and password. Add accounts using the button
                    below or paste bulk data.
                </p>

                <!-- Bulk Paste Field -->
                <div class="glass-code-block" style="margin-bottom: 16px;">
                    <label for="bulk-accounts-paste" class="form-label-github">
                        <i class="fas fa-paste"></i>
                        Bulk Paste Accounts (one per line)
                    </label>
                    <textarea id="bulk-accounts-paste" class="form-control-github" rows="4"
                        placeholder="Paste accounts in one of these formats:&#10;account@domain.com,password&#10;account@domain.com,domain.com,password&#10;&#10;Example:&#10;admin@example.com,example.com,MyPass123&#10;user@test.com,TestPass456"></textarea>
                    <small style="color: #656d76; font-size: 12px; margin-top: 8px; display: block;">
                        <i class="fas fa-info-circle"></i>
                        Format: <code>account,password</code> or <code>account,domain,password</code> (one per line).
                        Default: 50 users per account.
                    </small>
                    <button onclick="parseBulkAccountsPaste()" class="btn-github" style="margin-top: 8px; width: 100%;">
                        <i class="fas fa-magic"></i>
                        Parse & Fill Table
                    </button>
                </div>

                <!-- Accounts Table -->
                <div style="overflow-x: auto; margin-bottom: 16px;">
                    <table id="bulk-accounts-table" class="glass-table">
                        <thead>
                            <tr>
                                <th>
                                    <i class="fas fa-envelope"></i> Account Email
                                </th>
                                <th style="width: 150px;">
                                    <i class="fas fa-hashtag"></i> Users
                                </th>
                                <th>
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <span><i class="fas fa-globe"></i> Domain</span>
                                        <button onclick="populateAllDomains()" class="btn-github"
                                            style="padding: 2px 6px; font-size: 11px;" title="Populate All Domains">
                                            <i class="fas fa-sync-alt"></i>
                                        </button>
                                    </div>
                                </th>
                                <th>
                                    <i class="fas fa-lock"></i> Password
                                </th>
                                <th style="width: 80px; text-align: center;">
                                    <i class="fas fa-trash"></i> Action
                                </th>
                            </tr>
                        </thead>
                        <tbody id="bulk-accounts-tbody">
                            <!-- Rows will be added here dynamically -->
                        </tbody>
                    </table>
                </div>

                <!-- Add Account Button -->
                <div style="margin-bottom: 16px;">
                    <button onclick="addBulkAccountRow()" class="btn-github" style="width: 100%;">
                        <i class="fas fa-plus"></i>
                        Add Account Row
                    </button>
                </div>

                <div style="display: flex; gap: 12px; margin-top: 24px; flex-wrap: wrap;">
                    <button onclick="executeBulkAccountCreation()" class="btn-github btn-github-primary"
                        style="flex: 1; min-width: 150px;">
                        <i class="fas fa-play"></i>
                        Start Bulk Creation
                    </button>
                    <button onclick="retrieveUsersFromTableAccounts(event)" class="btn-github"
                        style="flex: 1; min-width: 150px; background-color: #0969da; border-color: #0969da; color: white;">
                        <i class="fas fa-sync-alt"></i>
                        Auth + Retrieve Bulk Users
                    </button>
                    <button onclick="executeBulkAccountDeletion(event)" class="btn-github"
                        style="flex: 1; min-width: 150px; background-color: #d73a49; border-color: #d73a49; color: white;">
                        <i class="fas fa-trash"></i>
                        Authenticate & Delete All Users
                    </button>
                    <button onclick="closeBulkAccountModal()" class="btn-github" style="flex: 1; min-width: 150px;">
                        <i class="fas fa-times"></i>
                        Cancel
                    </button>
                </div>

                <!-- Progress Indicator -->
                <div id="bulk-account-progress" style="display: none; margin-top: 24px;">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div id="bulk-account-progress-bar" class="progress-fill"></div>
                        </div>
                        <div id="bulk-account-progress-text" class="progress-text">Starting bulk account creation...
                        </div>
                    </div>
                </div>

                <!-- Results Display Section (inside modal) -->
                <div id="bulk-account-results-modal"
                    style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid #d0d7de;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h4 style="color: #24292f; margin: 0; font-size: 16px;">
                            <i class="fas fa-list"></i>
                            Retrieved Users (user:password format)
                        </h4>
                        <button onclick="copyBulkAccountResults()" class="btn-github" style="margin-left: 8px;">
                            <i class="fas fa-copy"></i>
                            Copy All
                        </button>
                    </div>
                    <div class="form-group-github">
                        <textarea id="bulk-account-results-text-modal" class="form-control-github" rows="15" readonly
                            style="font-family: 'Courier New', monospace; font-size: 13px; background-color: var(--input-bg);"></textarea>
                    </div>
                    <div id="bulk-account-summary-modal" class="glass-code-block" style="margin-top: 12px;">
                        <!-- Summary will be displayed here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Single User -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-user-plus"></i>
                Create Single User
            </h3>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
            <div class="form-group-github">
                <label for="new-user-first-name" class="form-label-github">
                    <i class="fas fa-user"></i> First Name
                </label>
                <input type="text" id="new-user-first-name" class="form-control-github" placeholder="Enter first name">
            </div>
            <div class="form-group-github">
                <label for="new-user-last-name" class="form-label-github">
                    <i class="fas fa-user"></i> Last Name
                </label>
                <input type="text" id="new-user-last-name" class="form-control-github" placeholder="Enter last name">
            </div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
            <div class="form-group-github">
                <label for="new-user-email" class="form-label-github">
                    <i class="fas fa-envelope"></i> Email Address
                </label>
                <input type="email" id="new-user-email" class="form-control-github" placeholder="user@domain.com">
            </div>
            <div class="form-group-github">
                <label for="new-user-password" class="form-label-github">
                    <i class="fas fa-lock"></i> Password
                </label>
                <input type="password" id="new-user-password" class="form-control-github" placeholder="Enter password">
            </div>
        </div>
        <button onclick="createSingleUser()" class="btn-github btn-github-primary">
            <i class="fas fa-plus"></i> Create User
        </button>
    </div>

    <!-- Domain Management -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-globe"></i>
                Domain Management
            </h3>
        </div>
        <div class="button-row">
            <button onclick="getDomainInfo()" class="btn-github btn-github-primary">
                <i class="fas fa-search"></i> Retrieve Domains
            </button>
            <button onclick="refreshDomainStatus()" class="btn-github" style="margin-left: 8px;">
                <i class="fas fa-sync-alt"></i> Refresh Status
            </button>
            <button onclick="copyRetrievedSubdomains()" class="btn-github" style="margin-left: 8px;">
                <i class="fas fa-copy"></i> Copy Subdomains
            </button>
            <button onclick="markUsedDomains()" class="btn-github"
                style="margin-left: 8px; background-color: #28a745; border-color: #28a745; color: white;">
                <i class="fas fa-check-circle"></i> Mark Used Domains
            </button>
            <!-- Auto Change Subdomain button moved to Tab 3 Workflow 2 -->
        </div>
        <div id="domain-info-display" class="data-display">
            <div class="status-info">
                <p><strong><i class="fas fa-globe"></i> Domain Information</strong></p>
                <p>Click "Retrieve Domains" to view domains here...</p>
            </div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end; margin-top: 16px;">
            <div class="form-group-github">
                <label for="new-domain-alias" class="form-label-github">
                    <i class="fas fa-plus"></i> New Domain Alias
                </label>
                <input type="text" id="new-domain-alias" class="form-control-github"
                    placeholder="Enter new domain alias">
            </div>
            <button onclick="addDomainAlias()" class="btn-github btn-github-primary">
                <i class="fas fa-plus"></i> Add Domain Alias
            </button>
        </div>

        <!-- Bulk Subdomain Deletion -->
        <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #d0d7de;">
            <h4 style="color: #24292f; margin-bottom: 16px; font-size: 16px;">
                <i class="fas fa-trash-alt"></i> Bulk Subdomain Deletion
            </h4>

            <div class="form-group-github">
                <label for="bulk-subdomains-list" class="form-label-github">
                    <i class="fas fa-list"></i> Subdomains to Delete (one per line)
                </label>
                <textarea id="bulk-subdomains-list" class="form-control-github" rows="6"
                    placeholder="Enter subdomains to delete (one per line):&#10;subdomain1.domain.com&#10;subdomain2.domain.com&#10;subdomain3.domain.com"></textarea>
                <small style="color: #656d76; font-size: 12px; margin-top: 8px; display: block;">
                    <i class="fas fa-info-circle"></i>
                    Enter one subdomain per line. The process will attempt to delete all listed subdomains and continue
                    until completion.
                </small>
            </div>

            <div style="display: flex; gap: 12px; margin-top: 16px;">
                <button onclick="executeBulkSubdomainDeletion()" class="btn-github btn-github-primary">
                    <i class="fas fa-trash"></i> Delete All Subdomains
                </button>
                <button onclick="clearBulkSubdomainsList()" class="btn-github">
                    <i class="fas fa-times"></i> Clear List
                </button>
            </div>

            <div id="bulk-subdomain-progress" class="progress-container" style="display: none; margin-top: 16px;">
                <div class="progress-bar">
                    <div id="bulk-subdomain-progress-bar" class="progress-fill"></div>
                </div>
                <div id="bulk-subdomain-progress-text" class="progress-text">Starting bulk subdomain deletion...</div>
            </div>

            <div id="bulk-subdomain-results" class="data-display" style="margin-top: 16px; display: none;">
                <h4>Bulk Deletion Results:</h4>
                <div id="bulk-subdomain-results-content"></div>
            </div>
        </div>
    </div>

    <!-- Create Users from CSV File -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-file-csv"></i>
                Create Users from CSV File
            </h3>
        </div>
        <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end;">
            <div class="form-group-github">
                <label for="csv-file-input" class="form-label-github">
                    <i class="fas fa-file-upload"></i> Select CSV File
                </label>
                <input type="file" id="csv-file-input" class="form-control-github" accept=".csv">
            </div>
            <button onclick="createUsersFromCSV()" class="btn-github btn-github-primary">
                <i class="fas fa-upload"></i> Create Users from CSV
            </button>
        </div>
    </div>

    <!-- Create Random Users -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-random"></i>
                Create Random Users
            </h3>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 16px; align-items: end;">
            <div class="form-group-github">
                <label for="random-user-count" class="form-label-github">
                    <i class="fas fa-hashtag"></i> Number of Users
                </label>
                <input type="number" id="random-user-count" class="form-control-github" min="1" max="100"
                    placeholder="e.g., 10">
            </div>
            <div class="form-group-github">
                <label for="random-user-domain" class="form-label-github">
                    <i class="fas fa-globe"></i> Domain
                </label>
                <input type="text" id="random-user-domain" class="form-control-github" placeholder="example.com">
            </div>
            <div class="form-group-github">
                <label for="random-user-password" class="form-label-github">
                    <i class="fas fa-lock"></i> Password
                </label>
                <input type="text" id="random-user-password" class="form-control-github"
                    placeholder="Password for all users">
            </div>
            <button onclick="createRandomUsers()" class="btn-github btn-github-primary">
                <i class="fas fa-random"></i> Create Random Users
            </button>
        </div>
    </div>

    <!-- Create Random Admin Users -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-user-shield"></i>
                Create Random Admin Users
            </h3>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr auto; gap: 16px; align-items: end;">
            <div class="form-group-github">
                <label for="random-admin-count" class="form-label-github">
                    <i class="fas fa-hashtag"></i> Number of Admins
                </label>
                <input type="number" id="random-admin-count" class="form-control-github" min="1" max="50"
                    placeholder="e.g., 5">
            </div>
            <div class="form-group-github">
                <label for="random-admin-domain" class="form-label-github">
                    <i class="fas fa-globe"></i> Domain
                </label>
                <input type="text" id="random-admin-domain" class="form-control-github" placeholder="example.com">
            </div>
            <div class="form-group-github">
                <label for="random-admin-password" class="form-label-github">
                    <i class="fas fa-lock"></i> Password
                </label>
                <input type="text" id="random-admin-password" class="form-control-github"
                    placeholder="Password for all admins">
            </div>
            <div class="form-group-github">
                <label for="admin-role" class="form-label-github">
                    <i class="fas fa-crown"></i> Admin Role
                </label>
                <select id="admin-role" class="form-control-github">
                    <option value="SUPER_ADMIN">Super Admin (Full Access)</option>
                    <option value="USER_MANAGEMENT_ADMIN">User Management Admin</option>
                    <option value="HELP_DESK_ADMIN">Help Desk Admin</option>
                    <option value="SERVICE_ADMIN">Service Admin</option>
                    <option value="BILLING_ADMIN">Billing Admin</option>
                    <option value="SECURITY_ADMIN">Security Admin</option>
                </select>
            </div>
            <button onclick="createRandomAdminUsers()" class="btn-github btn-github-warning">
                <i class="fas fa-user-shield"></i> Create Admin Users
            </button>
        </div>
        <div class="glass-warning-box"
            style="margin-top: 12px; background: rgba(255, 234, 167, 0.1) !important; border-color: rgba(255, 234, 167, 0.3) !important;">
            <i class="fas fa-info-circle" style="color: #f39c12; margin-right: 8px;"></i>
            <span style="color: var(--text-primary); font-size: 14px;">
                <strong>Note:</strong> Creates users with basic admin privileges. Specific role assignments require
                Google Admin Console configuration.
            </span>
        </div>
    </div>

    <!-- Update Passwords for Specific Users -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-key"></i>
                Update Passwords for Specific Users
            </h3>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 16px; align-items: end;">
            <div class="form-group-github">
                <label for="password-update-users" class="form-label-github">
                    <i class="fas fa-users"></i> Users (one per line)
                </label>
                <textarea id="password-update-users" class="form-control-github" rows="4"
                    placeholder="user1@domain.com&#10;user2@domain.com&#10;user3@domain.com"></textarea>
            </div>
            <div class="form-group-github">
                <label for="password-update-new-password" class="form-label-github">
                    <i class="fas fa-lock"></i> New Password
                </label>
                <input type="text" id="password-update-new-password" class="form-control-github"
                    placeholder="New password for all users">
            </div>
            <button onclick="updateUserPasswords()" class="btn-github btn-github-primary">
                <i class="fas fa-key"></i> Update Passwords
            </button>
        </div>
    </div>

    <!-- Change Domain for Specific Users -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-exchange-alt"></i>
                Change Domain for Specific Users
            </h3>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
            <div class="form-group-github">
                <label for="old-domain" class="form-label-github">
                    <i class="fas fa-globe"></i> Current Domain
                </label>
                <input type="text" id="old-domain" class="form-control-github" placeholder="old.com">
            </div>
            <div class="form-group-github">
                <label for="new-domain" class="form-label-github">
                    <i class="fas fa-globe"></i> New Domain
                </label>
                <input type="text" id="new-domain" class="form-control-github" placeholder="new.com">
            </div>
        </div>
        <div class="form-group-github" style="margin-bottom: 20px;">
            <label for="domain-change-emails" class="form-label-github">
                <i class="fas fa-envelope"></i> Email Addresses (one per line)
            </label>
            <textarea id="domain-change-emails" class="form-control-github" rows="4"
                placeholder="user1@old.com&#10;user2@old.com&#10;user3@old.com"></textarea>
        </div>
        <button onclick="changeDomainForUsers()" class="btn-github btn-github-primary">
            <i class="fas fa-exchange-alt"></i> Change Domain for These Users
        </button>
    </div>

    <!-- Delete Specific Users -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-user-times"></i>
                Delete Specific Users
            </h3>
        </div>
        <div class="form-group-github" style="margin-bottom: 20px;">
            <label for="delete-user-emails" class="form-label-github">
                <i class="fas fa-envelope"></i> Email Addresses to Delete (one per line)
            </label>
            <textarea id="delete-user-emails" class="form-control-github" rows="4"
                placeholder="user1@domain.com&#10;user2@domain.com&#10;user3@domain.com"></textarea>
        </div>
        <button onclick="deleteSpecificUsers()" class="btn-github btn-github-danger">
            <i class="fas fa-trash"></i> Delete These Users
        </button>
    </div>

    <!-- Results Log -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-file-alt"></i>
                Results Log
            </h3>
        </div>
        <div style="display: flex; gap: 12px; margin-bottom: 16px;">
            <button onclick="clearResultsLog()" class="btn-github">
                <i class="fas fa-broom"></i> Clear Log
            </button>
            <button onclick="copyResultsLog()" class="btn-github">
                <i class="fas fa-copy"></i> Copy Log
            </button>
        </div>
        <div id="results-log" class="data-display" style="font-family: monospace; font-size: 13px;"></div>
    </div>
</div>
<!-- Tab 3: DNS & SMTP -->
<div id="tab3" class="tab-content">

    <!-- Workflow 1: Change Domain using CSV File -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-file-csv"></i>
                Workflow 1: Change Domain using CSV File
            </h3>
        </div>

        <!-- Step 1.1: Download Current Users to CSV -->
        <div style="margin-bottom: 32px;">
            <h4
                style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-download" style="color: var(--color-accent-fg);"></i>
                Step 1.1: Download Current Users to CSV
            </h4>
            <div style="margin-bottom: 16px;">
                <button onclick="downloadAllUsersCSV()" class="btn-github btn-github-primary">
                    <i class="fas fa-download"></i> Download All Users
                </button>
            </div>
            <div
                style="background-color: rgba(9, 105, 218, 0.1); border: 1px solid var(--color-accent-emphasis); border-radius: 6px; padding: 12px; color: var(--color-accent-fg); font-size: 14px;">
                <i class="fas fa-info-circle"></i>
                CSV will be saved to: <strong id="csv-save-path">Downloads folder</strong>
            </div>
        </div>

        <!-- Step 1.2: Select New Domain and Apply to Downloaded CSV -->
        <div style="margin-bottom: 32px;">
            <h4
                style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-globe" style="color: var(--color-accent-fg);"></i>
                Step 1.2: Select New Domain and Apply to Downloaded CSV
            </h4>
            <div style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 16px;">
                <button onclick="retrieveAvailableDomains()" class="btn-github">
                    <i class="fas fa-search"></i> Retrieve Available Domains
                </button>
                <button onclick="getDomainUsageStats()" class="btn-github"
                    style="background-color: var(--color-success-emphasis); border-color: var(--color-success-emphasis); color: #ffffff;">
                    <i class="fas fa-chart-bar"></i> Domain Usage Stats
                </button>
                <button onclick="clearOldDomainData()" class="btn-github"
                    style="background-color: var(--color-warning-emphasis); border-color: var(--color-warning-emphasis); color: #ffffff;">
                    <i class="fas fa-trash"></i> Clear Old Data
                </button>
                <button onclick="applySelectedDomainToCSV()" class="btn-github btn-github-primary">
                    <i class="fas fa-check"></i> Apply Selected Domain to CSV
                </button>
                <button onclick="debugDomainUsers()" class="btn-github"
                    style="background-color: #6f42c1; border-color: #6f42c1; color: #ffffff;">
                    <i class="fas fa-bug"></i> Debug Domain Users
                </button>
                <button onclick="verifyUnverifiedDomains()" class="btn-github"
                    style="background-color: #d63384; border-color: #d63384; color: #ffffff;">
                    <i class="fas fa-check-double"></i> Verify Unverified Domains
                </button>
            </div>

            <div id="available-domains" class="data-display">
                <div class="status-info">
                    <p><strong><i class="fas fa-globe"></i> Domain Selection</strong></p>
                    <p>Click 'Retrieve Available Domains' to view available domains</p>
                </div>
            </div>
        </div>

        <!-- Step 1.3: Process Domain Changes from Modified CSV -->
        <div>
            <h4
                style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-cogs" style="color: var(--color-accent-fg);"></i>
                Step 1.3: Process Domain Changes from Modified CSV
            </h4>
            <div
                style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end; margin-bottom: 16px;">
                <div class="form-group-github">
                    <label for="csv-file-path" class="form-label-github">
                        <i class="fas fa-file-csv"></i> CSV File Path
                    </label>
                    <input type="text" id="csv-file-path" class="form-control-github"
                        placeholder="CSV file path will appear here after download/apply, or browse manually..."
                        readonly>
                </div>
                <button onclick="browseCSVFile()" class="btn-github">
                    <i class="fas fa-folder-open"></i> Browse Manually...
                </button>
            </div>
            <button onclick="processDomainChangesFromCSV()" class="btn-github btn-github-primary">
                <i class="fas fa-cogs"></i> Process Domain Changes from CSV
            </button>
        </div>
    </div>

    <!-- Subdomain Status Management -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-toggle-on"></i>
                Subdomain Status Management
            </h3>
        </div>

        <div style="margin-bottom: 20px;">
            <h4
                style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-edit" style="color: var(--color-accent-fg);"></i>
                Change Subdomain Status
            </h4>

            <div class="form-group-github" style="margin-bottom: 16px;">
                <label for="subdomain-status-input" class="form-label-github">
                    <i class="fas fa-list"></i> Subdomains (one per line)
                </label>
                <textarea id="subdomain-status-input" class="form-control-github" rows="6"
                    placeholder="Enter subdomains one per line, e.g.&#10;subdomain1&#10;subdomain2&#10;subdomain3"></textarea>
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 16px;">
                <button onclick="changeSubdomainStatus('available')" class="btn-github"
                    style="background-color: var(--color-success-emphasis); border-color: var(--color-success-emphasis); color: #ffffff;">
                    <i class="fas fa-check-circle"></i> Set as Available
                </button>
                <button onclick="changeSubdomainStatus('in_use')" class="btn-github"
                    style="background-color: var(--color-warning-emphasis); border-color: var(--color-warning-emphasis); color: #ffffff;">
                    <i class="fas fa-clock"></i> Set as In Use
                </button>
                <button onclick="changeSubdomainStatus('used')" class="btn-github"
                    style="background-color: var(--color-danger-emphasis); border-color: var(--color-danger-emphasis); color: #ffffff;">
                    <i class="fas fa-times-circle"></i> Set as Used
                </button>
                <button onclick="clearSubdomainStatusInput()" class="btn-github">
                    <i class="fas fa-trash"></i> Clear List
                </button>
            </div>

            <div id="subdomain-status-progress" style="display: none; margin-bottom: 16px;">
                <div class="progress-bar-github">
                    <div id="subdomain-status-progress-bar" class="progress-fill-github" style="width: 0%;"></div>
                </div>
                <div id="subdomain-status-progress-text"
                    style="text-align: center; margin-top: 8px; font-size: 14px; color: var(--color-fg-muted);">
                    Processing...
                </div>
            </div>

            <div id="subdomain-status-results" class="data-display" style="display: none;">
                <div class="status-info">
                    <p><strong><i class="fas fa-info-circle"></i> Status Change Results</strong></p>
                    <div id="subdomain-status-results-content"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Workflow 2: Change Domain for All Users (Non-CSV, Excludes Admin) -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-exchange-alt"></i>
                Workflow 2: Change Domain for All Users (Non-CSV, Excludes Admin)
            </h3>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
            <div class="form-group-github">
                <label for="current-domain-suffix" class="form-label-github">
                    <i class="fas fa-globe"></i> Current Domain Suffix
                </label>
                <input type="text" id="current-domain-suffix" class="form-control-github" placeholder="old-domain.com">
            </div>
            <div class="form-group-github">
                <label for="new-domain-suffix" class="form-label-github">
                    <i class="fas fa-globe"></i> New Domain Suffix
                </label>
                <input type="text" id="new-domain-suffix" class="form-control-github" placeholder="new-domain.com">
            </div>
        </div>

        <button onclick="changeDomainForAllUsers()" class="btn-github"
            style="background-color: var(--color-warning-emphasis); border-color: var(--color-warning-emphasis); color: #ffffff;">
            <i class="fas fa-exchange-alt"></i> Change Domain for ALL Matching Users (Non-Admin)
        </button>

        <!-- Auto Change Subdomain button moved here from Domain Management section -->
        <button onclick="autoChangeSubdomain()" class="btn-github"
            style="margin-left: 8px; background-color: #9C27B0; border-color: #9C27B0; color: white;">
            <i class="fas fa-magic"></i> Auto Change Subdomain
        </button>

        <!-- Progress Indicator -->
        <div id="domain-change-progress" class="progress-container" style="display: none; margin-top: 20px;">
            <div class="progress-header">
                <h4 style="margin: 0; color: var(--color-fg-default);">
                    <i class="fas fa-spinner fa-spin"></i> Domain Change Progress
                </h4>
                <span id="progress-percentage" style="color: var(--color-fg-muted);">0%</span>
            </div>
            <div class="progress-bar-container">
                <div id="progress-bar" class="progress-bar" style="width: 0%;"></div>
            </div>
            <div id="progress-message" class="progress-message"
                style="margin-top: 8px; color: var(--color-fg-muted); font-size: 14px;">
                Initializing...
            </div>
        </div>
    </div>



    <!-- Domain Addition & Verification -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-check-circle"></i>
                Domain Addition & Verification
            </h3>
        </div>

        <div style="margin-bottom: 20px;">
            <div class="form-group-github" style="margin-bottom: 16px;">
                <label for="domain-verification-input" class="form-label-github">
                    <i class="fas fa-list"></i> Paste domains (one per line)
                </label>
                <textarea id="domain-verification-input" class="form-control-github" rows="8"
                    placeholder="example.com&#10;sub.team.example.co.uk&#10;another-domain.io"></textarea>
            </div>

            <!-- DNS Provider Selection -->
            <div class="form-group-github" style="margin-bottom: 16px;">
                <label class="form-label-github">
                    <i class="fas fa-server"></i> DNS Provider
                </label>
                <div style="display: flex; gap: 16px; align-items: center;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="radio" name="dns_provider" value="namecheap" checked
                            onchange="toggleProviderSettings()">
                        <span>Namecheap</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="radio" name="dns_provider" value="cloudflare" onchange="toggleProviderSettings()">
                        <span>Cloudflare</span>
                    </label>
                </div>
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 16px; margin-bottom: 16px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="domain-verification-dry-run" style="cursor: pointer;">
                    <span>Dry-run (no DNS writes)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="domain-verification-skip-verified" checked style="cursor: pointer;">
                    <span>Skip if domain already verified</span>
                </label>
            </div>

            <button
                onclick="console.log('Button clicked!'); if(typeof window.startDomainVerification === 'function') { window.startDomainVerification(); } else { alert('Error: startDomainVerification function not found! Check console for details.'); console.error('startDomainVerification is:', typeof window.startDomainVerification); }"
                class="btn-github btn-github-primary" id="domain-verification-start-btn">
                <i class="fas fa-play"></i> Start Process
            </button>
            <button onclick="stopDomainVerification()" class="btn-github" id="domain-verification-stop-btn"
                style="background-color: var(--color-danger-emphasis); border-color: var(--color-danger-emphasis); color: #ffffff; margin-left: 8px;">
                <i class="fas fa-stop"></i> Stop Process
            </button>
            <button onclick="verifyUnverifiedDomains()" class="btn-github" id="verify-unverified-btn"
                style="background-color: #6f42c1; border-color: #6f42c1; color: #ffffff; margin-left: 8px;">
                <i class="fas fa-check-double"></i> Verify Unverified Domains
            </button>
        </div>

        <!-- Status Table -->
        <div id="domain-verification-status" style="display: none; margin-top: 24px;">
            <h4 style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0;">
                <i class="fas fa-table"></i> Status
            </h4>
            <div style="overflow-x: auto;">
                <table id="domain-verification-table" style="width: 100%; border-collapse: collapse; font-size: 13px;">
                    <thead>
                        <tr class="glass-table-header">
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Domain</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Workspace Add</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">DNS TXT</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Verification</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Message</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Last Updated</th>
                        </tr>
                    </thead>
                    <tbody id="domain-verification-table-body">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Log Panel -->
        <div id="domain-verification-log-container" style="margin-top: 24px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <h4 style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0;">
                    <i class="fas fa-file-alt"></i> Log Panel
                </h4>
                <button onclick="toggleDomainVerificationLog()" class="btn-github"
                    style="padding: 4px 12px; font-size: 12px;">
                    <i class="fas fa-chevron-down" id="domain-verification-log-toggle-icon"></i> Toggle
                </button>
            </div>
            <div id="domain-verification-log" class="glass-code-block"
                style="display: none; max-height: 300px; overflow-y: auto; white-space: pre-wrap;">
            </div>
        </div>
    </div>

    <!-- Bulk Multi-Account Domain Verification -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-layer-group"></i>
                Bulk Multi-Account Domain Verification
            </h3>
        </div>

        <div style="margin-bottom: 20px;">
            <div class="form-group-github" style="margin-bottom: 16px;">
                <label for="bulk-multi-account-input" class="form-label-github">
                    <i class="fas fa-list"></i> Paste accounts with domains (one per line)
                </label>
                <textarea id="bulk-multi-account-input" class="form-control-github" rows="8"
                    placeholder="Format: admin@account.com,newdomain.fun&#10;admin@yklqssgbjeympegr.boldvisiongroup.co.uk,eaxi263oyz7ji6gf.lunervanexta.fun&#10;admin@torrrimvlrojsppo.boldvisiongroup.co.uk,3kg4j2chiuc6fykm.lunervanexta.fun"></textarea>
                <small style="color: #656d76; font-size: 12px; margin-top: 8px; display: block;">
                    <i class="fas fa-info-circle"></i>
                    Format: <code>account_name,domain</code> or <code>admin_email,domain</code> - Uses stored JSON
                    credentials (no password needed)
                </small>
            </div>

            <!-- DNS Provider Selection for Bulk -->
            <div class="form-group-github" style="margin-bottom: 16px;">
                <label class="form-label-github">
                    <i class="fas fa-server"></i> DNS Provider
                </label>
                <div style="display: flex; gap: 16px; align-items: center;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="radio" name="bulk_dns_provider" value="namecheap" checked>
                        <span>Namecheap</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="radio" name="bulk_dns_provider" value="cloudflare">
                        <span>Cloudflare</span>
                    </label>
                </div>
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 16px;">
                <button onclick="parseBulkMultiAccountDomains()" class="btn-github btn-github-primary">
                    <i class="fas fa-list-check"></i> Parse & Preview
                </button>
                <button onclick="startBulkMultiAccountVerification()" class="btn-github"
                    style="background-color: #28a745; border-color: #28a745; color: #ffffff;" id="bulk-multi-start-btn">
                    <i class="fas fa-play"></i> Start All
                </button>
                <button onclick="stopBulkMultiAccountVerification()" class="btn-github"
                    style="background-color: var(--color-danger-emphasis); border-color: var(--color-danger-emphasis); color: #ffffff;"
                    id="bulk-multi-stop-btn">
                    <i class="fas fa-stop"></i> Stop
                </button>
                <button onclick="clearBulkMultiAccountInput()" class="btn-github">
                    <i class="fas fa-broom"></i> Clear
                </button>
            </div>
        </div>

        <!-- Parsed Schedule Table -->
        <div id="bulk-multi-schedule" style="display: none; margin-top: 24px;">
            <h4 style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0;">
                <i class="fas fa-table"></i> Schedule (<span id="bulk-multi-count">0</span> entries)
            </h4>
            <div style="overflow-x: auto;">
                <table id="bulk-multi-table" style="width: 100%; border-collapse: collapse; font-size: 13px;">
                    <thead>
                        <tr class="glass-table-header">
                            <th style="padding: 8px; text-align: left; font-weight: 600;">#</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Domain</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Account</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Auth</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Workspace</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">DNS TXT</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Verify</th>
                            <th style="padding: 8px; text-align: left; font-weight: 600;">Message</th>
                        </tr>
                    </thead>
                    <tbody id="bulk-multi-table-body">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Log Panel -->
        <div id="bulk-multi-log-container" style="margin-top: 24px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <h4 style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0;">
                    <i class="fas fa-file-alt"></i> Log
                </h4>
                <button onclick="toggleBulkMultiLog()" class="btn-github" style="padding: 4px 12px; font-size: 12px;">
                    <i class="fas fa-chevron-down" id="bulk-multi-log-toggle-icon"></i> Toggle
                </button>
            </div>
            <div id="bulk-multi-log" class="glass-code-block"
                style="max-height: 300px; overflow-y: auto; white-space: pre-wrap;">
            </div>
        </div>
    </div>

    <!-- Results Log (Covers Both Workflows) -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-file-alt"></i>
                Results Log (Covers Both Workflows)
            </h3>
        </div>

        <div style="margin-bottom: 16px;">
            <button onclick="clearBulkDomainLog()" class="btn-github">
                <i class="fas fa-broom"></i> Clear Log
            </button>
        </div>

        <div id="bulk-domain-results" class="data-display" style="font-family: monospace; font-size: 13px;">
            <div class="status-info">
                <p><strong><i class="fas fa-file-alt"></i> Processing Results</strong></p>
                <p>Processing results will appear here...</p>
            </div>
        </div>
    </div>

    <!-- SMTP Credential Tester -->
    <div class="github-card" style="margin-top: 32px;">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-envelope"></i>
                SMTP Credential Tester
            </h3>
        </div>

        <div class="form-group-github" style="margin-bottom: 20px;">
            <label for="smtp-credentials" class="form-label-github">
                <i class="fas fa-key"></i> SMTP Credentials (email,password,smtp_server,port)
                <span id="smtp-sync-status" style="margin-left: 8px; font-size: 12px; color: #6a737d;"></span>
            </label>
            <textarea id="smtp-credentials" class="form-control-github" rows="5"
                placeholder="user1@gmail.com,password123,smtp.gmail.com,587&#10;user2@outlook.com,apppassword456,smtp.outlook.com,587&#10;user3@yahoo.com,secretpass789,smtp.mail.yahoo.com,587"
                onchange="syncSMTPToAppPasswords()" oninput="autoSyncSMTPCredentials()"></textarea>
            <small style="color: #656d76; font-size: 12px; margin-top: 8px; display: block;">
                <i class="fas fa-info-circle"></i>
                Credentials are automatically synced to App Password Management. Use format:
                email,password,smtp_server,port (one per line)
            </small>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; margin-bottom: 20px;">
            <div class="form-group-github">
                <label for="smtp-recipient" class="form-label-github">
                    <i class="fas fa-envelope"></i> Recipient Email
                </label>
                <input type="email" id="smtp-recipient" class="form-control-github" placeholder="test@domain.com">
            </div>
            <div class="form-group-github">
                <label for="smtp-server" class="form-label-github">
                    <i class="fas fa-server"></i> SMTP Server
                </label>
                <input type="text" id="smtp-server" class="form-control-github" value="smtp.gmail.com"
                    placeholder="SMTP Server">
            </div>
            <div class="form-group-github">
                <label for="smtp-port" class="form-label-github">
                    <i class="fas fa-plug"></i> Port
                </label>
                <input type="number" id="smtp-port" class="form-control-github" value="587" placeholder="Port">
            </div>
        </div>

        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
            <button onclick="testSMTPCredentials()" class="btn-github btn-github-primary">
                <i class="fas fa-paper-plane"></i> Send Test Emails
            </button>
            <button onclick="syncSMTPToAppPasswords()" class="btn-github"
                style="background-color: #28a745; border-color: #28a745; color: white;">
                <i class="fas fa-sync"></i> Sync to App Passwords
            </button>
            <button onclick="testSMTPParsing()" class="btn-github"
                style="background-color: #6f42c1; border-color: #6f42c1; color: white;">
                <i class="fas fa-bug"></i> Test Parsing
            </button>
            <button onclick="interruptSMTPTesting()" class="btn-github"
                style="background-color: var(--color-warning-emphasis); border-color: var(--color-warning-emphasis); color: #ffffff;">
                <i class="fas fa-stop"></i> Interrupt Sending
            </button>
            <button onclick="clearSMTPResults()" class="btn-github">
                <i class="fas fa-broom"></i> Clear Log / Reset Files
            </button>
        </div>

        <div>
            <h4
                style="font-size: 16px; font-weight: 600; color: var(--color-fg-default); margin: 0 0 16px 0; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-chart-bar" style="color: var(--color-accent-fg);"></i>
                SMTP Test Results
            </h4>
            <div id="smtp-results-log" class="data-display" style="font-family: monospace; font-size: 13px;">
                <div class="status-info">
                    <p><strong><i class="fas fa-envelope"></i> SMTP Testing Results</strong></p>
                    <p>Test results will appear here...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Generate Sample CSV for User Creation -->
    <div class="github-card" style="margin-top: 24px;">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-file-csv"></i>
                Generate Sample CSV for User Creation
            </h3>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; margin-bottom: 20px;">
            <div class="form-group-github">
                <label for="csv-num-users" class="form-label-github">
                    <i class="fas fa-hashtag"></i> Number of Users
                </label>
                <input type="number" id="csv-num-users" class="form-control-github" min="1" max="1000"
                    placeholder="e.g., 50">
            </div>
            <div class="form-group-github">
                <label for="csv-domain" class="form-label-github">
                    <i class="fas fa-globe"></i> Domain
                </label>
                <input type="text" id="csv-domain" class="form-control-github" placeholder="yourdomain.com">
            </div>
            <div class="form-group-github">
                <label for="csv-password" class="form-label-github">
                    <i class="fas fa-lock"></i> Default Password
                </label>
                <input type="text" id="csv-password" class="form-control-github"
                    placeholder="Default password for all users">
            </div>
        </div>

        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
            <button onclick="generateUserCSV()" class="btn-github btn-github-primary">
                <i class="fas fa-download"></i> Generate CSV File
            </button>
            <button onclick="previewCSV()" class="btn-github">
                <i class="fas fa-eye"></i> Preview CSV
            </button>
        </div>

        <div id="csv-download-area" class="data-display"></div>

        <div id="csv-preview-area" class="csv-preview"></div>
    </div>

    <!-- Mega Upgrade: Single Account Workflow -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-rocket"></i>
                Mega Upgrade: Single Account Workflow
            </h3>
        </div>

        <p style="color: #656d76; margin-bottom: 24px; font-size: 14px;">
            Process a single account with automated workflows. Select which features to apply to the account.
        </p>

        <button onclick="openMegaUpgradeModal()" class="btn-github btn-github-primary"
            style="width: 100%; padding: 16px; font-size: 16px;">
            <i class="fas fa-magic"></i> Launch Mega Upgrade Workflow
        </button>

    </div>

    <!-- App Password Management -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-key"></i>
                App Password Management
            </h3>
        </div>

        <div class="form-group-github">
            <label for="app-passwords-file" class="form-label-github">
                <i class="fas fa-upload"></i> Upload App Passwords File
            </label>
            <input type="file" id="app-passwords-file" class="form-control-github" accept=".txt"
                onchange="handleAppPasswordsFile(this)">
            <small class="form-text" style="color: #666; margin-top: 8px;">
                Upload a .txt file with format: user@domain.com:app_password (one per line)<br>
                <strong>üí° You can upload multiple files - all passwords will be stored in one place!</strong>
            </small>
        </div>

        <div style="display: flex; gap: 12px; margin-top: 16px;">
            <button onclick="uploadAppPasswords()" class="btn-github btn-github-primary">
                <i class="fas fa-upload"></i> Upload & Store Passwords
            </button>
            <button onclick="downloadAppPasswordsTemplate()" class="btn-github">
                <i class="fas fa-download"></i> Download Template
            </button>
            {% if session.role == 'admin' %}
            <button onclick="clearAppPasswords()" class="btn-github"
                style="background-color: #dc3545; border-color: #dc3545; color: white;"
                onmouseover="this.style.backgroundColor='#c82333'" onmouseout="this.style.backgroundColor='#dc3545'">
                <i class="fas fa-trash"></i> Clear All Passwords
            </button>
            {% else %}
            <div
                style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background-color: #f8f9fa; border: 1px solid #d0d7de; border-radius: 6px; color: #656d76; font-size: 13px;">
                <i class="fas fa-lock"></i>
                <span>Clear All Passwords (Admin Only)</span>
            </div>
            {% endif %}
        </div>

        <div id="app-passwords-status" class="count-display" style="margin-top: 16px;">
            <span id="app-passwords-count">No app passwords stored</span>
        </div>

        <!-- Advanced App Password Management -->
        <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #d0d7de;">
            <h4 style="color: #24292f; margin-bottom: 16px; font-size: 16px;">
                <i class="fas fa-cogs"></i> Advanced Management
            </h4>

            <!-- Search and Select Users -->
            <div class="form-group-github">
                <label for="search-app-passwords" class="form-label-github">
                    <i class="fas fa-search"></i> Search App Password Users
                </label>
                <input type="text" id="search-app-passwords" class="form-control-github"
                    placeholder="Search by alias (username)..." onkeyup="searchAppPasswordUsers()">
                <div style="margin-top: 8px;">
                    <button onclick="debugAppPasswords()" class="btn-github" style="font-size: 12px; padding: 4px 8px;">
                        <i class="fas fa-bug"></i> Debug Search
                    </button>
                </div>
            </div>

            <!-- User Selection and Management -->
            <div id="app-passwords-search-results"
                style="max-height: 200px; overflow-y: auto; border: 1px solid #d0d7de; border-radius: 6px; padding: 12px; margin-bottom: 16px; display: none;">
                <!-- Search results will be populated here -->
            </div>

            <!-- Delete Specific Users -->
            <div class="form-group-github">
                <label for="delete-app-passwords" class="form-label-github">
                    <i class="fas fa-trash-alt"></i> Delete Specific Users (one per line)
                </label>
                <textarea id="delete-app-passwords" class="form-control-github" rows="4"
                    placeholder="Enter usernames or emails to delete (one per line):&#10;user1@domain.com&#10;user2@domain.com&#10;username3"></textarea>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button onclick="deleteSpecificAppPasswords()" class="btn-github"
                        style="background-color: #dc3545; color: white;">
                        <i class="fas fa-trash"></i> Delete Selected
                    </button>
                    <button onclick="clearDeleteField()" class="btn-github">
                        <i class="fas fa-times"></i> Clear Field
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Automation Authentication Process -->
    <div class="github-card">
        <div class="github-card-header">
            <h3 class="github-card-title">
                <i class="fas fa-robot"></i>
                Automation Authentication Process
            </h3>
        </div>

        <div class="form-group-github">
            <label for="automation-accounts-list" class="form-label-github">
                <i class="fas fa-columns"></i> Accounts to Process (one per line)
            </label>
            <textarea id="automation-accounts-list" class="form-control-github" rows="8"
                placeholder="user1@domain.com&#10;user2@domain.com&#10;user3@domain.com&#10;..."></textarea>
        </div>

        <div style="display: flex; gap: 12px; margin-top: 16px; margin-bottom: 20px;">
            <button onclick="executeAutomationProcess()" class="btn-github btn-github-primary">
                <i class="fas fa-play"></i> Execute Automation Process
            </button>
            <button onclick="clearAutomationList()" class="btn-github">
                <i class="fas fa-trash"></i> Clear List
            </button>
        </div>

        <div id="automation-progress" class="progress-container" style="display: none;">
            <div class="progress-bar">
                <div id="automation-progress-bar" class="progress-fill"></div>
            </div>
            <div id="automation-progress-text" class="progress-text">Starting automation process...</div>
        </div>

        <div id="automation-results" class="data-display" style="margin-top: 16px; display: none;">
            <h4>Automation Results:</h4>
            <div id="automation-results-content"></div>
        </div>

        <div id="automation-users-display" class="github-card" style="margin-top: 16px; display: none;">
            <div class="github-card-header">
                <h3 class="github-card-title">
                    <i class="fas fa-users"></i>
                    Retrieved Users
                </h3>
            </div>
            <div id="automation-users-list" class="user-list" style="max-height: 400px; overflow-y: auto;">
                <!-- Users will be populated here -->
            </div>
            <div style="display: flex; gap: 12px; margin-top: 16px;">
                <button onclick="copyAutomationUsers()" class="btn-github">
                    <i class="fas fa-copy"></i> Copy All Emails
                </button>
                <button onclick="exportAutomationUsers()" class="btn-github">
                    <i class="fas fa-download"></i> Export as CSV
                </button>
            </div>
        </div>

        <!-- Users Text Display Field -->
        <div id="automation-users-text-display" class="github-card" style="margin-top: 16px; display: none;">
            <div class="github-card-header" style="
                background: linear-gradient(135deg, #f6f8fa 0%, #e1e8ed 100%);
                border-bottom: 3px solid #0969da;
                border-radius: 8px 8px 0 0;
                padding: 20px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            ">
                <div>
                    <h3 class="github-card-title" style="
                        margin: 0; 
                        color: #24292f; 
                        font-size: 20px; 
                        font-weight: 700;
                        text-shadow: 0 1px 2px rgba(0,0,0,0.1);
                    ">
                        <i class="fas fa-list-alt" style="color: #0969da; margin-right: 10px; font-size: 22px;"></i>
                        Users List (Text Format)
                    </h3>
                    <div id="users-list-stats" style="margin-top: 16px;">
                        <!-- Statistics will be displayed here -->
                    </div>
                </div>
            </div>
            <div class="github-card-body" style="padding: 20px;">
                <div class="form-group-github">
                    <label for="automation-users-text" class="form-label-github"
                        style="font-weight: 600; color: #24292f; margin-bottom: 12px;">
                        <i class="fas fa-file-text" style="color: #0969da; margin-right: 8px;"></i>
                        Retrieved Users (SMTP Format)
                    </label>
                    <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                        <button onclick="copyRetrievedUsersText()" class="btn-github" style="
                            padding: 8px 16px; 
                            font-size: 13px; 
                            font-weight: 500;
                            background: #0969da;
                            color: white;
                            border: 1px solid #0969da;
                            border-radius: 6px;
                            transition: all 0.2s ease;
                            display: flex;
                            align-items: center;
                            gap: 6px;
                        " onmouseover="this.style.background='#0550ae'" onmouseout="this.style.background='#0969da'">
                            <i class="fas fa-copy"></i> Copy Text
                        </button>
                        <button onclick="exportAutomationUsers()" class="btn-github" style="
                            padding: 8px 16px; 
                            font-size: 13px; 
                            font-weight: 500;
                            background: #28a745;
                            color: white;
                            border: 1px solid #28a745;
                            border-radius: 6px;
                            transition: all 0.2s ease;
                            display: flex;
                            align-items: center;
                            gap: 6px;
                        " onmouseover="this.style.background='#1e7e34'" onmouseout="this.style.background='#28a745'">
                            <i class="fas fa-download"></i> Export CSV
                        </button>
                        <button onclick="readyToTest();" class="btn-github" style="
                            padding: 8px 16px; 
                            font-size: 13px; 
                            font-weight: 500;
                            background: #ff6b35;
                            color: white;
                            border: 1px solid #ff6b35;
                            border-radius: 6px;
                            transition: all 0.2s ease;
                            display: flex;
                            align-items: center;
                            gap: 6px;
                        " onmouseover="this.style.background='#e55a2b'" onmouseout="this.style.background='#ff6b35'">
                            <i class="fas fa-vial"></i> Ready to Test
                        </button>
                    </div>
                    <div style="position: relative;">
                        <textarea id="automation-users-text" class="form-control-github" rows="15"
                            placeholder="Users will appear here after automation process..." readonly style="
                                    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
                                    font-size: 13px;
                                    line-height: 1.5;
                                    background: #f6f8fa;
                                    border: 2px solid #d0d7de;
                                    border-radius: 8px;
                                    padding: 16px;
                                    resize: vertical;
                                    min-height: 300px;
                                  "></textarea>
                        <div style="
                            position: absolute;
                            top: 8px;
                            right: 8px;
                            background: rgba(255, 255, 255, 0.9);
                            padding: 4px 8px;
                            border-radius: 4px;
                            font-size: 11px;
                            color: #656d76;
                            font-weight: 500;
                        ">
                            <i class="fas fa-lock"></i> Read-only
                        </div>
                    </div>
                    <div
                        style="margin-top: 12px; padding: 12px; background: #f6f8fa; border-radius: 6px; border-left: 4px solid #0969da;">
                        <div style="display: flex; align-items: center; gap: 8px; color: #656d76; font-size: 12px;">
                            <i class="fas fa-info-circle" style="color: #0969da;"></i>
                            <span><strong>Format:</strong> email,app_password,smtp.gmail.com,587 (one per line)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</div>


<script>
    function debugAppPasswords() {
        console.log('=== DEBUG APP PASSWORDS ===');

        fetch('/api/debug-app-passwords')
            .then(response => response.json())
            .then(data => {
                console.log('Debug API response:', data);

                if (data.success) {
                    const info = data.debug_info;
                    console.log(`Total app passwords in database: ${info.total_count}`);
                    console.log('Sample records:', info.sample_records);
                    console.log('Recent records:', info.recent_records);

                    alert(`Debug Info:\n\nTotal records: ${info.total_count}\n\nCheck browser console for detailed information.`);
                } else {
                    console.error('Debug API failed:', data.error);
                    alert(`Debug failed: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Debug request failed:', error);
                alert(`Debug request failed: ${error.message}`);
            });
    }

    // Normalize email to avoid duplicated domain segments like base.base at the end
    function normalizeEmail(rawEmail) {
        if (!rawEmail || typeof rawEmail !== 'string') return rawEmail;
        const trimmed = rawEmail.trim();
        const atIndex = trimmed.lastIndexOf('@');
        if (atIndex === -1) return trimmed; // not an email
        const local = trimmed.slice(0, atIndex);
        let domain = trimmed.slice(atIndex + 1);

        // Collapse duplicated trailing domain sequences, e.g.
        // foo@abc.def.ghi.abc.def.ghi -> foo@abc.def.ghi
        // Strategy: find the longest suffix that is repeated twice contiguously
        const labels = domain.split('.');
        for (let windowSize = Math.floor(labels.length / 2); windowSize >= 1; windowSize--) {
            const firstStart = labels.length - 2 * windowSize;
            if (firstStart < 0) continue;
            const left = labels.slice(firstStart, firstStart + windowSize).join('.');
            const right = labels.slice(firstStart + windowSize).join('.');
            if (left === right) {
                domain = labels.slice(0, firstStart + windowSize).join('.');
                break;
            }
        }

        return `${local}@${domain}`;
    }

    let currentAccount = null;
    let isAuthenticated = false;
    let selectedAccountFromList = null;
    let selectedAccountId = null;
    let smtpTesting = false;
    let selectedDomain = null;

    // Tab switching functionality - Make it globally accessible
    function showTab(tabId) {
        console.log('showTab called with tabId:', tabId);

        // Update sidebar dropdown active state
        const dropdownItems = document.querySelectorAll('.dropdown-item');
        dropdownItems.forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('onclick') && item.getAttribute('onclick').includes(tabId)) {
                item.classList.add('active');
            }
        });

        // Hide all tab contents
        const tabs = document.querySelectorAll('.tab-content');
        console.log('Found', tabs.length, 'tab content elements');
        tabs.forEach(tab => {
            tab.classList.remove('active');
            tab.style.display = 'none';
            tab.style.visibility = 'hidden';
            tab.style.opacity = '0';
        });

        // Remove active class from all tab buttons
        const buttons = document.querySelectorAll('.tab-button');
        buttons.forEach(button => {
            button.classList.remove('active');
            button.style.background = '';
            button.style.borderBottom = '';
            button.style.color = '';
            button.style.fontWeight = '';
            button.style.transform = '';
            button.style.boxShadow = '';
        });

        // Show selected tab
        const selectedTab = document.getElementById(tabId);
        if (selectedTab) {
            console.log('Found tab element:', tabId, selectedTab);
            selectedTab.classList.add('active');
            selectedTab.style.display = 'block';
            selectedTab.style.visibility = 'visible';
            selectedTab.style.opacity = '1';
            selectedTab.style.height = 'auto';
            selectedTab.style.overflow = 'visible';
            selectedTab.style.position = 'relative';
            selectedTab.style.zIndex = '1';

            // Scroll to top of tab
            selectedTab.scrollIntoView({ behavior: 'smooth', block: 'start' });

            console.log('Tab', tabId, 'is now visible');
        } else {
            console.error('Tab not found:', tabId);
            // Try to find it with a delay (in case DOM is still loading)
            setTimeout(() => {
                const retryTab = document.getElementById(tabId);
                if (retryTab) {
                    console.log('Found tab on retry:', tabId);
                    retryTab.classList.add('active');
                    retryTab.style.display = 'block';
                    retryTab.style.visibility = 'visible';
                    retryTab.style.opacity = '1';
                } else {
                    console.error('Tab still not found after retry:', tabId);
                }
            }, 200);
        }

        // Add active class to clicked button  
        const clickedButton = event ? event.target.closest('.tab-button') : document.querySelector(`[onclick="showTab('${tabId}')"]`);
        if (clickedButton) {
            clickedButton.classList.add('active');
            clickedButton.style.background = '';
            clickedButton.style.borderBottom = '';
            clickedButton.style.color = '';
            clickedButton.style.fontWeight = '';
            clickedButton.style.transform = '';
            clickedButton.style.boxShadow = '';
        }

        // Auto-refresh domain data when domains tab is shown
        checkTabRefresh(tabId);
    }

    // Make showTab globally accessible
    if (typeof window !== 'undefined') {
        window.showTab = showTab;
    }

    // Initialize tabs on page load
    document.addEventListener('DOMContentLoaded', function () {
        console.log('DOM loaded, initializing tabs...');

        // Check if all tabs exist
        for (let i = 1; i <= 4; i++) {
            const tab = document.getElementById(`tab${i}`);
            console.log(`Tab ${i} exists:`, !!tab);
            if (tab) {
                console.log(`Tab ${i} content length:`, tab.innerHTML.length);
            }
        }

        // Check URL hash and switch to appropriate tab
        const hash = window.location.hash;
        if (hash && (hash === '#tab1' || hash === '#tab2' || hash === '#tab3')) {
            const tabId = hash.substring(1); // Remove the #
            console.log('Switching to tab from hash:', tabId);
            showTab(tabId);
        } else {
            // Ensure tab1 is visible by default
            showTab('tab1');
        }

        // Listen for hash changes (when clicking sidebar links)
        window.addEventListener('hashchange', function () {
            const hash = window.location.hash;
            if (hash && (hash === '#tab1' || hash === '#tab2' || hash === '#tab3')) {
                const tabId = hash.substring(1);
                console.log('Hash changed, switching to tab:', tabId);
                showTab(tabId);
            }
        });

        // 3-tab layout is now complete - no special initialization needed
    });

    async function loadTokenStatusWithLive() {
        try {
            console.log('=== Starting LIVE token status check ===');

            // Reset counters
            let totalAccounts = 0;
            let validAccounts = 0;
            let invalidAccounts = 0;

            // Get list of accounts first
            const accountItems = document.querySelectorAll('.account-item');
            totalAccounts = accountItems.length;

            // Initialize display
            updateAccountStats(totalAccounts, 0, 0, 'Checking...');

            // Check each account individually (LIVE UPDATES)
            for (let item of accountItems) {
                // FIX: Clean the account name - remove status symbols
                const itemCopy = item.cloneNode(true);
                const statusSpan = itemCopy.querySelector('.token-status');
                if (statusSpan) {
                    statusSpan.remove();
                }
                const accountName = itemCopy.textContent.trim();

                try {
                    // Show "checking" status
                    showAccountChecking(item, accountName);

                    // Check this specific account
                    const isValid = await checkSingleAccountLive(accountName);

                    // Update visual immediately
                    updateAccountVisual(item, accountName, isValid);

                    // Update counters
                    if (isValid) {
                        validAccounts++;
                    } else {
                        invalidAccounts++;
                    }

                    // Update stats in real-time
                    updateAccountStats(totalAccounts, validAccounts, invalidAccounts, 'Checking...');

                    // Update dropdown too (with clean name)
                    updateDropdownOption(accountName, isValid);

                } catch (error) {
                    console.error(`Error checking ${accountName}:`, error);
                    updateAccountVisual(item, accountName, false);
                    invalidAccounts++;
                    updateAccountStats(totalAccounts, validAccounts, invalidAccounts, 'Checking...');
                }
            }

            // Final update
            updateAccountStats(totalAccounts, validAccounts, invalidAccounts, 'Complete');

            // Save results to cache/SFTP for persistence
            await saveTokenStatusResults();

            console.log(`‚úÖ Live check complete: ${validAccounts}/${totalAccounts} authenticated`);

        } catch (error) {
            console.error('Live token status check failed:', error);
        }
    }

    // Check single account status
    async function checkSingleAccountLive(accountName) {
        try {
            const response = await fetch('/api/check-token-status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ account_name: accountName })
            });

            const data = await response.json();
            return data.success && data.is_valid;

        } catch (error) {
            console.error(`Token check failed for ${accountName}:`, error);
            return false;
        }
    }

    // Show account being checked
    function showAccountChecking(item, accountName) {
        const oldStatus = item.querySelector('.token-status');
        if (oldStatus) oldStatus.remove();

        const statusSpan = document.createElement('span');
        statusSpan.className = 'token-status checking';
        statusSpan.textContent = ' üîÑ';
        statusSpan.style.cssText = 'float: right; margin-left: 10px; color: orange;';
        item.appendChild(statusSpan);
    }
    // Update account visual status
    function updateAccountVisual(item, accountName, isValid) {
        const oldStatus = item.querySelector('.token-status');
        if (oldStatus) oldStatus.remove();

        const statusSpan = document.createElement('span');
        statusSpan.className = isValid ? 'token-status valid' : 'token-status invalid';
        statusSpan.textContent = isValid ? ' ‚úÖ' : ' ‚ùå';
        statusSpan.style.cssText = 'float: right; margin-left: 10px;';
        item.appendChild(statusSpan);

        console.log(`‚úÖ Updated ${accountName}: ${isValid ? 'Valid' : 'Invalid'}`);
    }

    // Update dropdown option
    function updateDropdownOption(accountName, isValid) {
        // Clean account name for selector (escape special characters)
        const cleanAccountName = accountName.replace(/[^a-zA-Z0-9@.\-_]/g, '');

        try {
            // Try to find option by value
            const option = document.querySelector(`#account-select option[value="${accountName}"]`);
            if (option) {
                option.textContent = `${accountName} ${isValid ? '‚úÖ' : '‚ùå'}`;
            } else {
                // If not found, try finding by text content
                const allOptions = document.querySelectorAll('#account-select option');
                allOptions.forEach(opt => {
                    if (opt.value === accountName || opt.textContent.includes(accountName)) {
                        opt.textContent = `${accountName} ${isValid ? '‚úÖ' : '‚ùå'}`;
                    }
                });
            }
        } catch (error) {
            console.error(`Error updating dropdown for ${accountName}:`, error);
        }
    }

    // Update stats counter in real-time
    function updateAccountStats(total, valid, invalid, status) {
        const statsElement = document.getElementById('account-stats');
        if (statsElement) {
            const checked = valid + invalid;
            statsElement.innerHTML = `
            <span class="stat-item">Total: <strong>${total}</strong></span>
            <span class="stat-item">Checked: <strong>${checked}/${total}</strong></span>
            <span class="stat-item stat-valid">‚úÖ Authenticated: <strong>${valid}</strong></span>
            <span class="stat-item stat-invalid">‚ùå Need Auth: <strong>${invalid}</strong></span>
            <span class="stat-item" style="color: #007bff;">Status: <strong>${status}</strong></span>
        `;
        }
    }

    // Save results for persistence (survives restart)
    async function saveTokenStatusResults() {
        try {
            // Collect current status with CLEAN account names
            const results = {};
            const accountItems = document.querySelectorAll('.account-item');

            accountItems.forEach(item => {
                // Get ONLY the account name text, exclude status symbols
                const accountNameElement = item.cloneNode(true);

                // Remove the status span to get clean account name
                const statusSpan = accountNameElement.querySelector('.token-status');
                if (statusSpan) {
                    statusSpan.remove();
                }

                // Get clean account name
                const accountName = accountNameElement.textContent.trim();

                // Get the actual status
                const statusElement = item.querySelector('.token-status');

                if (statusElement && accountName) {
                    const isValid = statusElement.textContent.includes('‚úÖ');
                    results[accountName] = {
                        is_valid: isValid,
                        last_checked: new Date().toISOString()
                    };

                    console.log(`Clean save: "${accountName}" = ${isValid}`);
                }
            });

            console.log('Saving results for', Object.keys(results).length, 'accounts');

            // Save to server for persistence
            const response = await fetch('/api/save-token-status-cache', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status_results: results })
            });

            const data = await response.json();
            console.log('Save response:', data);

        } catch (error) {
            console.error('Failed to save token status results:', error);
        }
    }

    // Load saved results on page load (for persistence)
    async function loadSavedTokenStatus() {
        try {
            const response = await fetch('/api/load-token-status-cache', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            const data = await response.json();

            if (data.success && data.status) {
                console.log('Loading saved token status...');
                displaySavedTokenStatus(data.status);
                return true;
            }

            return false;

        } catch (error) {
            console.error('Failed to load saved token status:', error);
            return false;
        }
    }

    // Display saved status from cache
    function displaySavedTokenStatus(statusData) {
        const accountItems = document.querySelectorAll('.account-item');
        let totalAccounts = accountItems.length;
        let validAccounts = 0;
        let invalidAccounts = 0;

        accountItems.forEach(item => {
            const accountName = item.textContent.trim();

            if (statusData[accountName]) {
                const isValid = statusData[accountName].is_valid;
                updateAccountVisual(item, accountName, isValid);
                updateDropdownOption(accountName, isValid);

                if (isValid) {
                    validAccounts++;
                } else {
                    invalidAccounts++;
                }
            }
        });

        updateAccountStats(totalAccounts, validAccounts, invalidAccounts, 'Loaded from cache');
        console.log(`Loaded cached status: ${validAccounts}/${totalAccounts} authenticated`);
    }

    // Main function - use database for token status
    async function initializeTokenStatus() {
        console.log('Initializing token status from database...');
        await checkTokenStatusFromDatabase();
    }

    // Auto-refresh every 8 hours (but user can manually refresh anytime)
    setInterval(checkTokenStatusFromDatabase, 8 * 60 * 60 * 1000);

    // Load on page load
    document.addEventListener('DOMContentLoaded', function () {
        setTimeout(initializeTokenStatus, 1000);

        // Check if there's a currently authenticated account in session
        checkCurrentAuthenticationStatus();
    });

    // Check current authentication status from session
    async function checkCurrentAuthenticationStatus() {
        try {
            const response = await fetch('/api/get-account-status', {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
            });

            const data = await response.json();

            if (data.success && data.status) {
                const { total, authenticated, need_auth } = data.status;

                // Update the auth status display
                if (authenticated > 0) {
                    // Get the current authenticated account name
                    const currentAccountName = sessionStorage.getItem('current_account_name');
                    if (currentAccountName) {
                        updateAuthStatus(currentAccountName, true, `Currently authenticated (${authenticated}/${total} accounts)`);
                    }
                }

                console.log(`Current authentication status: ${authenticated}/${total} accounts authenticated`);
            }
        } catch (error) {
            console.error('Failed to check current authentication status:', error);
        }
    }


    // Auto-refresh domain data when domains tab is shown
    function checkTabRefresh(tabId) {
        if (tabId === 'tab3' && isAuthenticated) {
            setTimeout(() => {
                retrieveAvailableDomains();
            }, 500);
        }
    }

    // Results log functions
    function logResult(message) {
        const log = document.getElementById('results-log');
        const activityLog = document.getElementById('activity-log');
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}\n`;

        // Log to results log (existing functionality)
        log.textContent += logEntry;
        log.scrollTop = log.scrollHeight;

        // Also log to activity log
        if (activityLog) {
            // Remove the placeholder text if it exists
            if (activityLog.textContent.includes('üìù Activity log will appear here...')) {
                activityLog.textContent = '';
            }
            activityLog.textContent += logEntry;
            activityLog.scrollTop = activityLog.scrollHeight;
        }
    }

    function clearResultsLog() {
        document.getElementById('results-log').textContent = '';
    }

    // Activity log management functions
    function clearLogs() {
        if (confirm('üóëÔ∏è Are you sure you want to clear all activity logs?')) {
            document.getElementById('activity-log').textContent = 'üìù Activity log cleared. New activities will appear here...';
            logResult('üìù Activity log cleared by user');
        }
    }

    function copyLogs() {
        const activityLog = document.getElementById('activity-log');
        const logText = activityLog.textContent;

        if (!logText || logText.includes('üìù Activity log will appear here...') || logText.includes('üìù Activity log cleared.')) {
            alert('üìù No logs to copy. Perform some actions first.');
            return;
        }

        navigator.clipboard.writeText(logText).then(() => {
            logResult('üìã Activity logs copied to clipboard');
        }).catch(err => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = logText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            logResult('üìã Activity logs copied to clipboard (fallback method)');
        });
    }

    function downloadLogs() {
        const activityLog = document.getElementById('activity-log');
        const logText = activityLog.textContent;

        if (!logText || logText.includes('üìù Activity log will appear here...') || logText.includes('üìù Activity log cleared.')) {
            alert('üìù No logs to download. Perform some actions first.');
            return;
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `gbot-activity-log-${timestamp}.txt`;

        const blob = new Blob([logText], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);

        logResult(`üíæ Activity logs downloaded as ${filename}`);
    }

    // App Password Management Functions
    function storeAppPassword() {
        const userAlias = document.getElementById('app-password-alias').value.trim();
        const appPassword = document.getElementById('app-password-value').value.trim();
        const domain = document.getElementById('app-password-domain').value.trim();

        if (!userAlias) {
            alert('Please enter a user alias');
            return;
        }

        if (!appPassword) {
            alert('Please enter an app password');
            return;
        }

        if (!userAlias.includes('@')) {
            alert('Please enter a valid email address as user alias');
            return;
        }

        logResult(`üîê Storing app password for user: ${userAlias}...`);

        fetch('/api/store-app-password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                user_alias: userAlias,
                app_password: appPassword,
                domain: domain || null
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ ${data.message}`);
                    document.getElementById('app-password-alias').value = '';
                    document.getElementById('app-password-value').value = '';
                    document.getElementById('app-password-domain').value = '';
                    // Refresh the display
                    loadAllAppPasswords();
                } else {
                    logResult(`‚ùå Failed to store app password: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
            });
    }

    function loadAllAppPasswords() {
        console.log('Loading all app passwords...');
        logResult('üîç Loading all app passwords...');

        fetch('/api/get-all-app-passwords')
            .then(response => {
                console.log('Response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('App passwords response:', data);
                if (data.success) {
                    console.log('App passwords data:', data.app_passwords);
                    displayAppPasswords(data.app_passwords);
                    logResult(`üìã Loaded ${data.total_count} app passwords`);
                } else {
                    console.error('Failed to load app passwords:', data.error);
                    logResult(`‚ùå Failed to load app passwords: ${data.error}`);
                    const displayElement = document.getElementById('app-passwords-display');
                    if (displayElement) {
                        displayElement.innerHTML = `<div class="error-message">‚ùå Error: ${data.error}</div>`;
                    }
                }
            })
            .catch(error => {
                console.error('Network error:', error);
                logResult(`‚ùå Network error: ${error.message}`);
                const displayElement = document.getElementById('app-passwords-display');
                if (displayElement) {
                    displayElement.innerHTML = `<div class="error-message">‚ùå Network error: ${error.message}</div>`;
                }
            });
    }

    function displayAppPasswords(appPasswords) {
        console.log('Displaying app passwords:', appPasswords);
        logResult(`üé® Displaying ${appPasswords ? appPasswords.length : 0} app passwords`);

        const displayElement = document.getElementById('app-passwords-display');
        if (!displayElement) {
            console.error('app-passwords-display element not found');
            logResult('‚ùå Error: App passwords display element not found');
            return;
        }

        if (!appPasswords || appPasswords.length === 0) {
            console.log('No app passwords to display');
            displayElement.innerHTML = '<div class="status-info"><p>‚úÖ No app passwords stored</p></div>';
            return;
        }

        let html = '<div class="app-passwords-list">';
        html += '<h4 style="margin-bottom: 16px; color: #24292f;">üîê Stored App Passwords</h4>';

        appPasswords.forEach(password => {
            html += `
            <div class="app-password-item" style="border: 1px solid #e1e4e8; border-radius: 6px; padding: 12px; margin-bottom: 8px; background: #f8f9fa;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${password.user_alias}</strong>
                        <div style="color: #666; font-size: 14px; margin-top: 4px;">
                            üîë App Password: ${password.app_password}
                        </div>
                        ${password.domain ? `<div style="color: #666; font-size: 12px; margin-top: 2px;">üåê Domain: ${password.domain}</div>` : ''}
                        <div style="color: #666; font-size: 11px; margin-top: 4px;">
                            üìÖ Updated: ${password.updated_at}
                        </div>
                    </div>
                </div>
            </div>
        `;
        });

        html += '</div>';
        displayElement.innerHTML = html;
        console.log('App passwords display updated');
        logResult('‚úÖ App passwords display updated');
    }

    // Auto-load app passwords when page loads
    function autoLoadAppPasswords() {
        console.log('Auto-loading app passwords...');
        loadAllAppPasswords();
    }

    // Auto-load when page is ready
    document.addEventListener('DOMContentLoaded', function () {
        console.log('Page loaded, auto-loading app passwords...');
        setTimeout(autoLoadAppPasswords, 1000); // Wait 1 second for page to fully load
        loadAppPasswordsStatus(); // Load status immediately
    });

    function clearAppPasswords() {
        document.getElementById('app-passwords-display').innerHTML = '<div style="color: #6a737d; font-style: italic;">üìù App passwords will appear here...</div>';
        logResult('üßπ App passwords display cleared');
    }


    // Sync SMTP credentials to App Password Management
    function syncSMTPToAppPasswords() {
        const credentials = document.getElementById('smtp-credentials').value.trim();

        if (!credentials) {
            alert('Please enter SMTP credentials first');
            return;
        }

        console.log('Syncing SMTP credentials to app passwords...');
        logResult('üîÑ Syncing SMTP credentials to App Password Management...');

        // Update status indicator
        const statusElement = document.getElementById('smtp-sync-status');
        if (statusElement) {
            statusElement.innerHTML = '<i class="fas fa-sync fa-spin"></i> Syncing...';
            statusElement.style.color = '#28a745';
        }

        // Parse credentials (format: email,password,smtp_server,port OR email:password)
        const credentialLines = credentials.split('\n').filter(line => line.trim());
        let syncedCount = 0;
        let errorCount = 0;

        credentialLines.forEach((line, index) => {
            const trimmedLine = line.trim();
            let email, password, domain;

            // Check if it's CSV format (comma-separated)
            if (trimmedLine.includes(',') && !trimmedLine.includes(':')) {
                const parts = trimmedLine.split(',');
                if (parts.length >= 2) {
                    email = parts[0].trim();
                    password = parts[1].trim();
                    domain = email.includes('@') ? email.split('@')[1] : '';
                }
            }
            // Check if it's colon format (email:password)
            else if (trimmedLine.includes(':')) {
                const parts = trimmedLine.split(':');
                if (parts.length >= 2) {
                    email = parts[0].trim();
                    password = parts.slice(1).join(':').trim(); // Handle passwords with colons
                    domain = email.includes('@') ? email.split('@')[1] : '';
                }
            }

            if (email && password && email.includes('@')) {
                console.log(`Syncing credential: ${email} -> ${password.substring(0, 4)}...`);
                logResult(`üîÑ Syncing: ${email}`);

                // Store each credential as an app password
                console.log(`Storing app password for: ${email}`);
                logResult(`üì§ Storing: ${email} -> ${password.substring(0, 4)}...`);

                fetch('/api/store-app-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_alias: email,
                        app_password: password,
                        domain: domain || email.split('@')[1] // Use extracted domain or fallback
                    })
                })
                    .then(response => {
                        console.log(`Response for ${email}:`, response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log(`Data for ${email}:`, data);
                        if (data.success) {
                            syncedCount++;
                            logResult(`‚úÖ Synced: ${email}`);
                        } else {
                            errorCount++;
                            logResult(`‚ùå Failed to sync ${email}: ${data.error}`);
                        }

                        // If this is the last credential, show summary
                        if (index === credentialLines.length - 1) {
                            logResult(`üìä Sync Complete: ${syncedCount} synced, ${errorCount} failed`);

                            // Update status indicator
                            if (statusElement) {
                                if (errorCount === 0) {
                                    statusElement.innerHTML = '<i class="fas fa-check"></i> Synced';
                                    statusElement.style.color = '#28a745';
                                } else {
                                    statusElement.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${syncedCount} synced, ${errorCount} failed`;
                                    statusElement.style.color = '#d73a49';
                                }
                            }

                            // Refresh the app passwords display
                            loadAllAppPasswords();
                        }
                    })
                    .catch(error => {
                        errorCount++;
                        logResult(`‚ùå Error syncing ${email}: ${error.message}`);

                        if (index === credentialLines.length - 1) {
                            logResult(`üìä Sync Complete: ${syncedCount} synced, ${errorCount} failed`);

                            // Update status indicator
                            if (statusElement) {
                                if (errorCount === 0) {
                                    statusElement.innerHTML = '<i class="fas fa-check"></i> Synced';
                                    statusElement.style.color = '#28a745';
                                } else {
                                    statusElement.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${syncedCount} synced, ${errorCount} failed`;
                                    statusElement.style.color = '#d73a49';
                                }
                            }

                            loadAllAppPasswords();
                        }
                    });
            } else {
                errorCount++;
                logResult(`‚ùå Invalid format: ${line}`);
            }
        });

        if (credentialLines.length === 0) {
            alert('No valid credentials found. Please use format: email:password');
        }
    }

    // Auto-sync SMTP credentials with debouncing
    let smtpSyncTimeout;
    function autoSyncSMTPCredentials() {
        // Clear previous timeout
        if (smtpSyncTimeout) {
            clearTimeout(smtpSyncTimeout);
        }

        // Set new timeout for auto-sync (2 seconds delay)
        smtpSyncTimeout = setTimeout(() => {
            const credentials = document.getElementById('smtp-credentials').value.trim();

            if (credentials && (credentials.includes(':') || credentials.includes(','))) {
                console.log('Auto-syncing SMTP credentials...');
                syncSMTPToAppPasswords();
            }
        }, 2000);
    }

    // Test SMTP parsing function
    function testSMTPParsing() {
        const credentials = document.getElementById('smtp-credentials').value.trim();

        if (!credentials) {
            alert('Please enter SMTP credentials first');
            return;
        }

        console.log('Testing SMTP parsing...');
        logResult('üß™ Testing SMTP credential parsing...');

        const credentialLines = credentials.split('\n').filter(line => line.trim());

        credentialLines.forEach((line, index) => {
            const trimmedLine = line.trim();
            let email, password, domain;

            console.log(`Line ${index + 1}: "${trimmedLine}"`);
            logResult(`üìù Line ${index + 1}: "${trimmedLine}"`);

            // Check if it's CSV format (comma-separated)
            if (trimmedLine.includes(',') && !trimmedLine.includes(':')) {
                const parts = trimmedLine.split(',');
                console.log(`CSV format detected: ${parts.length} parts`);
                logResult(`üìä CSV format detected: ${parts.length} parts`);

                if (parts.length >= 2) {
                    email = parts[0].trim();
                    password = parts[1].trim();
                    domain = email.includes('@') ? email.split('@')[1] : '';

                    console.log(`Parsed: email=${email}, password=${password.substring(0, 4)}..., domain=${domain}`);
                    logResult(`‚úÖ Parsed: ${email} -> ${password.substring(0, 4)}... (${domain})`);
                } else {
                    console.log('‚ùå Not enough parts in CSV format');
                    logResult('‚ùå Not enough parts in CSV format');
                }
            }
            // Check if it's colon format (email:password)
            else if (trimmedLine.includes(':')) {
                const parts = trimmedLine.split(':');
                console.log(`Colon format detected: ${parts.length} parts`);
                logResult(`üìä Colon format detected: ${parts.length} parts`);

                if (parts.length >= 2) {
                    email = parts[0].trim();
                    password = parts.slice(1).join(':').trim();
                    domain = email.includes('@') ? email.split('@')[1] : '';

                    console.log(`Parsed: email=${email}, password=${password.substring(0, 4)}..., domain=${domain}`);
                    logResult(`‚úÖ Parsed: ${email} -> ${password.substring(0, 4)}... (${domain})`);
                } else {
                    console.log('‚ùå Not enough parts in colon format');
                    logResult('‚ùå Not enough parts in colon format');
                }
            } else {
                console.log('‚ùå No recognized format detected');
                logResult('‚ùå No recognized format detected');
            }
        });

        logResult('üß™ Parsing test complete. Check console for detailed output.');
    }

    function fetchAppPasswordsForWorkflow() {
        logBulkDomain('üîç Fetching stored app passwords...');

        fetch('/api/get-all-app-passwords')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.app_passwords.length > 0) {
                    logBulkDomain(`üìã Found ${data.app_passwords.length} stored app passwords:`);
                    data.app_passwords.forEach(password => {
                        logBulkDomain(`   üîë ${password.user_alias} - ${password.app_password} ${password.domain ? `(${password.domain})` : ''}`);
                    });

                    // Display in the App Passwords Display field
                    displayWorkflowAppPasswords(data.app_passwords);
                } else {
                    logBulkDomain('‚ö†Ô∏è No app passwords found in storage');
                    logBulkDomain('üí° Tip: Store app passwords in the App Password Management section first');
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Error fetching app passwords: ${error.message}`);
            });
    }

    function storeAppPasswordsForWorkflow(accounts) {
        logBulkDomain('üíæ Storing app passwords for workflow...');

        // Generate sample app passwords for each account
        accounts.forEach(account => {
            const username = account.split('@')[0];
            const domain = account.split('@')[1];

            // Generate a random app password
            const appPassword = generateRandomPassword(16);

            // Store the app password
            fetch('/api/store-app-password', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_alias: account,
                    app_password: appPassword,
                    domain: domain
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        logBulkDomain(`‚úÖ Stored app password for ${account}`);
                    } else {
                        logBulkDomain(`‚ùå Failed to store app password for ${account}: ${data.error}`);
                    }
                })
                .catch(error => {
                    logBulkDomain(`‚ùå Error storing app password for ${account}: ${error.message}`);
                });
        });
    }
    function storeAndDisplayAppPasswordsForWorkflow(accounts) {
        logBulkDomain('üíæ Storing and displaying app passwords for workflow...');
        logBulkDomain('üîÑ REFACTORED: Enhanced app password retrieval with new subdomains');

        // CRITICAL: Use the EXACT subdomain that was actually changed during Mega Upgrade
        if (window.megaUpgradeChangedSubdomain) {
            logBulkDomain(`üéØ Using ACTUAL Mega Upgrade subdomain: ${window.megaUpgradeChangedSubdomain}`);
            logBulkDomain(`‚úÖ This is the EXACT subdomain that was changed during the process`);
            generateAppPasswordsWithTargetDomain(accounts, window.megaUpgradeChangedSubdomain);
            return;
        }

        // If no detected subdomain, we need to find the ACTUAL changed subdomain
        logBulkDomain('üîç No detected subdomain, finding the ACTUAL changed subdomain...');

        fetch('/api/retrieve-domains', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                batched: true
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.domains && data.domains.length > 0) {
                    logBulkDomain(`‚úÖ Retrieved ${data.domains.length} domains`);

                    // Debug: Log all domains to understand the structure
                    logBulkDomain(`üîç Debug: Analyzing ${data.domains.length} domains...`);
                    data.domains.forEach((domain, index) => {
                        logBulkDomain(`   Domain ${index + 1}: ${JSON.stringify(domain)}`);
                    });

                    // Find the ACTUAL subdomain that was changed (look for the one with the most recent activity)
                    let targetDomain = null;

                    // PRIORITY 1: Look for domains that were just changed (IN USE with users)
                    const inUseDomains = data.domains.filter(domain =>
                        (domain.status === 'in_use' || domain.status_text === 'IN USE') &&
                        domain.user_count > 0 &&
                        (domain.domainName || domain.domain_name) &&
                        (domain.domainName || domain.domain_name) !== 'undefined'
                    );

                    logBulkDomain(`üîç Found ${inUseDomains.length} IN USE domains with users`);

                    if (inUseDomains.length > 0) {
                        // Build a base->newSubdomain map by comparing IN USE vs AVAILABLE per base
                        const availableByBase = {};
                        data.domains
                            .filter(d => (d.status === 'available' || d.status_text === 'AVAILABLE'))
                            .forEach(d => {
                                const dn = d.domainName || d.domain_name;
                                if (!dn) return;
                                const parts = dn.split('.');
                                if (parts.length < 2) return;
                                const base = parts.slice(1).join('.');
                                if (!availableByBase[base]) availableByBase[base] = [];
                                availableByBase[base].push(dn);
                            });

                        const baseToNewSubdomainMap = {};
                        inUseDomains.forEach(d => {
                            const dn = d.domainName || d.domain_name;
                            if (!dn) return;
                            const parts = dn.split('.');
                            if (parts.length < 2) return;
                            const base = parts.slice(1).join('.');
                            const candidates = availableByBase[base] || [];
                            if (candidates.length > 0) {
                                // Choose the lexicographically next available as the new subdomain target
                                candidates.sort();
                                baseToNewSubdomainMap[base] = candidates[0];
                            } else {
                                // Fallback to current in-use if no available found
                                baseToNewSubdomainMap[base] = dn;
                            }
                        });

                        // Save map globally for formatter
                        window.baseToNewSubdomainMap = baseToNewSubdomainMap;

                        // Also pick one representative for logging/legacy path
                        const firstBase = Object.keys(baseToNewSubdomainMap)[0];
                        targetDomain = baseToNewSubdomainMap[firstBase];
                        logBulkDomain(`üéØ Using NEXT subdomain mapping per base: ${JSON.stringify(baseToNewSubdomainMap)}`);
                    } else {
                        // PRIORITY 2: Look for any domain with users (fallback)
                        const domainsWithUsers = data.domains.filter(domain =>
                            domain.user_count > 0 &&
                            (domain.domainName || domain.domain_name) &&
                            (domain.domainName || domain.domain_name) !== 'undefined'
                        );

                        logBulkDomain(`üîç Found ${domainsWithUsers.length} domains with users`);

                        if (domainsWithUsers.length > 0) {
                            const selectedDomain = domainsWithUsers.reduce((prev, current) =>
                                (current.user_count > prev.user_count) ? current : prev
                            );
                            targetDomain = selectedDomain.domainName || selectedDomain.domain_name;
                            const userCount = selectedDomain.user_count;
                            logBulkDomain(`üéØ Found domain with users: ${targetDomain} (${userCount} users)`);
                        } else {
                            // PRIORITY 3: Look for any domain with a valid domainName
                            const validDomains = data.domains.filter(domain =>
                                (domain.domainName || domain.domain_name) &&
                                (domain.domainName || domain.domain_name) !== 'undefined' &&
                                (domain.domainName || domain.domain_name).length > 0
                            );

                            logBulkDomain(`üîç Found ${validDomains.length} domains with valid names`);

                            if (validDomains.length > 0) {
                                targetDomain = validDomains[0].domainName || validDomains[0].domain_name;
                                logBulkDomain(`üéØ Using first valid domain: ${targetDomain}`);
                            } else {
                                logBulkDomain(`‚ùå No valid domains found - cannot proceed`);
                                return;
                            }
                        }
                    }

                    if (targetDomain) {
                        logBulkDomain(`üåê Using ACTUAL changed subdomain: ${targetDomain}`);
                        logBulkDomain(`‚úÖ This is the EXACT subdomain that was changed during the process`);

                        // Save the ACTUAL subdomain
                        window.selectedSubdomain = targetDomain;
                        window.megaUpgradeChangedSubdomain = targetDomain;
                        logBulkDomain(`üíæ Saved ACTUAL subdomain: ${targetDomain}`);

                        generateAppPasswordsWithTargetDomain(accounts, targetDomain);
                    } else {
                        logBulkDomain(`‚ùå No suitable ACTUAL subdomain found`);
                        logBulkDomain(`‚ö†Ô∏è Cannot proceed without the actual changed subdomain`);
                        logBulkDomain(`üîÑ Attempting manual domain fallback...`);

                        // Try manual domain fallback
                        generateAppPasswordsWithManualDomainChange(accounts);
                    }
                } else {
                    logBulkDomain(`‚ùå Failed to retrieve domains`);
                    logBulkDomain(`‚ö†Ô∏è Cannot proceed without domain information`);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Error retrieving domains: ${error.message}`);
                logBulkDomain(`‚ö†Ô∏è Cannot proceed without domain information`);
            });
    }

    function generateAppPasswordsWithTargetDomain(accounts, targetDomain) {
        logBulkDomain(`üîë Preparing SMTP lines using stored app passwords`);
        window.currentTargetDomain = targetDomain;
        window.megaUpgradeChangedSubdomain = targetDomain;

        fetch('/api/get-all-app-passwords')
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    logBulkDomain(`‚ùå Failed to load stored app passwords: ${data.error || 'unknown error'}`);
                    return;
                }

                const rows = data.app_passwords || [];
                if (rows.length === 0) {
                    logBulkDomain('‚ÑπÔ∏è No stored app passwords found');
                    return;
                }

                const output = [];
                // Support multi-base processing: use global base-to-subdomain map if available
                const baseMap = window.baseToNewSubdomainMap || null;
                // Extract new subdomain label and target base from single detected domain
                const targetParts = (targetDomain || '').split('.');
                const newSubLabelSingle = targetParts.length > 0 ? targetParts[0] : '';
                const targetBaseSingle = targetParts.length > 1 ? targetParts.slice(1).join('.') : '';

                logBulkDomain(`üîç Total stored app passwords: ${rows.length}`);
                logBulkDomain(`üîç Processing all stored passwords (aliases and passwords are static)`);

                rows.forEach(row => {
                    const alias = row.user_alias || '';
                    const pwd = row.app_password || '';
                    if (!alias || !pwd) return;

                    const [username, aliasDomain] = alias.includes('@') ? alias.split('@') : [alias, ''];
                    if (!aliasDomain) return;

                    // Compute base of alias (everything after the first dot)
                    const aliasParts = aliasDomain.split('.');
                    if (aliasParts.length < 2) return; // not a subdomain; skip
                    const aliasBase = aliasParts.slice(1).join('.');

                    // Determine mapped domain for this base
                    let newDomainForAlias = '';
                    if (baseMap && baseMap[aliasBase]) {
                        newDomainForAlias = baseMap[aliasBase];
                    } else if (targetBaseSingle) {
                        if (aliasBase !== targetBaseSingle) return; // not part of processed base
                        newDomainForAlias = `${newSubLabelSingle}.${targetBaseSingle}`;
                    } else {
                        return;
                    }

                    // Filter by alias and app password (both static) - include all stored passwords
                    // No domain filtering since aliases and passwords are static
                    logBulkDomain(`üîç Including alias: ${alias} (base: ${aliasBase}) - aliases and passwords are static`);

                    const line = `${username}@${newDomainForAlias},${pwd},smtp.gmail.com,587`;
                    output.push(line);
                });

                if (output.length === 0) {
                    logBulkDomain('‚ÑπÔ∏è No stored app passwords found to format');
                    return;
                }

                const display = document.getElementById('app-passwords-display');
                display.value = output.join('\n');
                logBulkDomain(`üìã ${output.length} SMTP lines displayed (alias+password kept static)`);
            })
            .catch(err => {
                logBulkDomain(`‚ùå Error building SMTP lines: ${err.message}`);
            });
    }

    function generateAppPasswordsWithManualDomainChange(accounts) {
        logBulkDomain(`üîë Generating app passwords with manual domain change...`);
        logBulkDomain(`üîÑ This is a fallback when automatic domain detection fails`);

        const appPasswords = [];
        let completedAccounts = 0;
        const totalAccounts = accounts.length;

        // Get subdomain prefix from input field
        const subdomainPrefix = document.getElementById('mega-subdomain-prefix').value.trim();

        accounts.forEach((account, index) => {
            // Get the original domain from the account
            const originalDomain = account.split('@')[1];

            // MANUALLY change the domain from .giize.com to .mywire.org
            let updatedDomain = originalDomain;
            if (originalDomain.includes('.giize.com')) {
                updatedDomain = originalDomain.replace('.giize.com', '.mywire.org');
                logBulkDomain(`üîÑ MANUAL DOMAIN CHANGE: ${originalDomain} ‚Üí ${updatedDomain}`);
            }

            // Create the new subdomain format with custom or random subdomain
            const subdomain = subdomainPrefix || generateRandomSubdomain(16);
            const newDomain = `${subdomain}.${updatedDomain}`;

            logBulkDomain(`üîÑ Creating new subdomain: ${newDomain} for account: ${account}`);
            logBulkDomain(`‚úÖ Using manual subdomain: ${newDomain}`);

            // Store the manual subdomain globally
            window.megaUpgradeChangedSubdomain = newDomain;
            window.currentTargetDomain = newDomain;

            // Retrieve all users from the account and process them
            retrieveAllUsersForWorkflow(account, newDomain, appPasswords, () => {
                completedAccounts++;
                if (completedAccounts >= totalAccounts) {
                    logBulkDomain(`‚úÖ Completed manual domain change for all accounts`);
                    displayAppPasswordsInWorkflow(appPasswords);
                }
            });
        });
    }

    function retrieveAllUsersForWorkflow(account, newDomain, appPasswords, onComplete) {
        logBulkDomain(`üë• REFACTORED: Retrieving all users from account: ${account}`);
        logBulkDomain(`üåê Using new subdomain: ${newDomain}`);

        // Retrieve all users from the account
        fetch('/api/retrieve-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                domain: account.split('@')[1],
                batched: true
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.users && data.users.length > 0) {
                    logBulkDomain(`‚úÖ Retrieved ${data.users.length} users from ${account}`);
                    logBulkDomain(`üîÑ Processing users with new subdomain: ${newDomain}`);

                    // Build SMTP lines for each user from stored passwords without changing them
                    const alias_domain_map = {};
                    data.users.forEach(u => {
                        const user = (u.email || '').split('@')[0];
                        alias_domain_map[u.email] = newDomain; // map full alias to new domain
                        alias_domain_map[user] = newDomain;    // also map by username
                    });
                    fetch('/api/retrieve-app-passwords', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ alias_domain_map })
                    })
                        .then(r => r.json())
                        .then(resp => {
                            if (resp.success && Array.isArray(resp.app_passwords)) {
                                // Append to appPasswords list used by displayAppPasswordsInWorkflow
                                resp.app_passwords.forEach(line => appPasswords.push(line));
                            } else if (!resp.success) {
                                logBulkDomain(`‚ùå Failed to retrieve stored app passwords: ${resp.error}`);
                            }
                            onComplete();
                        })
                        .catch(err => {
                            logBulkDomain(`‚ùå Error retrieving stored passwords: ${err.message}`);
                            onComplete();
                        });
                } else {
                    logBulkDomain(`‚ö†Ô∏è No users found for account ${account}, using admin account only`);

                    // Fallback to admin account only
                    const username = account.split('@')[0];
                    const appPassword = generateRandomPassword(16);
                    const newAccount = `${username}@${newDomain}`;

                    storeAppPasswordForUser(newAccount, appPassword, newDomain, appPasswords, onComplete);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Error retrieving users from ${account}: ${error.message}`);

                // Fallback to admin account only
                const username = account.split('@')[0];
                const appPassword = generateRandomPassword(16);
                const newAccount = `${username}@${newDomain}`;

                storeAppPasswordForUser(newAccount, appPassword, newDomain, appPasswords, onComplete);
            });
    }

    function generateAppPasswordsForUsers(users, newDomain, appPasswords, onComplete) {
        logBulkDomain(`üîë REFACTORED: Generating app passwords for ${users.length} users`);
        logBulkDomain(`üåê Using new subdomain: ${newDomain}`);

        let completedUsers = 0;
        const totalUsers = users.length;

        if (totalUsers === 0) {
            logBulkDomain(`‚ö†Ô∏è No users to process`);
            onComplete();
            return;
        }

        logBulkDomain(`üë• Processing ${totalUsers} users with new subdomain`);

        users.forEach((user, userIndex) => {
            const username = user.email.split('@')[0];
            const appPassword = generateRandomPassword(16);
            const newAccount = `${username}@${newDomain}`;

            logBulkDomain(`üë§ Processing user ${userIndex + 1}/${totalUsers}: ${username}`);
            logBulkDomain(`üåê Creating account: ${newAccount}`);

            storeAppPasswordForUser(newAccount, appPassword, newDomain, appPasswords, () => {
                completedUsers++;
                if (completedUsers >= totalUsers) {
                    logBulkDomain(`‚úÖ Completed processing ${totalUsers} users with new subdomain`);
                    onComplete();
                }
            });
        });
    }

    function storeAppPasswordForUser(newAccount, appPassword, newDomain, appPasswords, onComplete) {
        // CRITICAL: Use the ACTUAL subdomain that was changed during Mega Upgrade
        const targetDomain = window.megaUpgradeChangedSubdomain || window.currentTargetDomain || newDomain;

        // Update the account to use the ACTUAL subdomain
        const username = newAccount.split('@')[0];
        const updatedAccount = `${username}@${targetDomain}`;

        logBulkDomain(`üíæ Storing app password for ${updatedAccount} (using ACTUAL subdomain: ${targetDomain})`);
        logBulkDomain(`‚úÖ This is the EXACT subdomain that was changed during Mega Upgrade`);

        // Store the app password with the saved subdomain
        fetch('/api/store-app-password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                user_alias: updatedAccount,
                app_password: appPassword,
                domain: targetDomain
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logBulkDomain(`‚úÖ Stored app password for ${updatedAccount}`);

                    // Add to display format with the saved subdomain
                    appPasswords.push(`${updatedAccount},${appPassword},smtp.gmail.com,587`);
                } else {
                    logBulkDomain(`‚ùå Failed to store app password for ${updatedAccount}: ${data.error}`);
                }

                onComplete();
            })
            .catch(error => {
                logBulkDomain(`‚ùå Error storing app password for ${updatedAccount}: ${error.message}`);
                onComplete();
            });
    }

    function generateAppPasswordsWithUpdatedDomain(accounts, updatedDomain) {
        logBulkDomain(`üîë Generating app passwords with updated domain: ${updatedDomain}`);

        const appPasswords = [];
        let completedAccounts = 0;
        const totalAccounts = accounts.length;

        // Get subdomain prefix from input field
        const subdomainPrefix = document.getElementById('mega-subdomain-prefix').value.trim();

        accounts.forEach((account, index) => {
            // Create the new subdomain format with custom or random subdomain
            const subdomain = subdomainPrefix || generateRandomSubdomain(16);
            const newDomain = `${subdomain}.${updatedDomain}`;

            logBulkDomain(`üîÑ Creating new subdomain: ${newDomain} for account: ${account}`);

            // Retrieve all users from the account and process them
            retrieveAllUsersForWorkflow(account, newDomain, appPasswords, () => {
                completedAccounts++;
                if (completedAccounts >= totalAccounts) {
                    displayAppPasswordsInWorkflow(appPasswords);
                }
            });
        });
    }

    function displayAppPasswordsInWorkflow(appPasswords) {
        logBulkDomain(`üìã REFACTORED: Displaying ${appPasswords.length} app passwords with new subdomains`);
        logBulkDomain(`üîÑ Enhanced display for Mega Upgrade workflow`);

        if (!appPasswords || appPasswords.length === 0) {
            logBulkDomain(`‚ö†Ô∏è No app passwords to display`);
            return;
        }

        // Display in the App Passwords Display field
        const display = document.getElementById('app-passwords-display');
        if (display) {
            const passwordText = appPasswords.join('\n');
            display.value = passwordText;
            logBulkDomain('‚úÖ App passwords displayed in App Passwords Display field');
            logBulkDomain(`üìù Content: ${passwordText}`);

            // Also trigger a change event to ensure the display updates
            display.dispatchEvent(new Event('change', { bubbles: true }));

            // Force focus and scroll to the display field
            display.focus();
            display.scrollIntoView({ behavior: 'smooth', block: 'center' });

            logBulkDomain(`üéØ Display field updated with ${appPasswords.length} app passwords`);
        } else {
            logBulkDomain('‚ùå App Passwords Display field not found!');
            logBulkDomain('üîç Searching for alternative display fields...');

            // Try alternative field names
            const altDisplay = document.getElementById('app-passwords-display') ||
                document.getElementById('app-passwords-display-field') ||
                document.querySelector('textarea[placeholder*="app password"]') ||
                document.querySelector('textarea[placeholder*="App Password"]');

            if (altDisplay) {
                const passwordText = appPasswords.join('\n');
                altDisplay.value = passwordText;
                logBulkDomain('‚úÖ App passwords displayed in alternative field');
                logBulkDomain(`üìù Content: ${passwordText}`);
            } else {
                logBulkDomain('‚ùå No suitable display field found!');
            }
        }

        // Also log each password for reference
        appPasswords.forEach((password, index) => {
            logBulkDomain(`   ${index + 1}. ${password}`);
        });

        // Show success message
        logBulkDomain(`üéâ SUCCESS: ${appPasswords.length} app passwords generated and displayed`);
        logBulkDomain(`‚úÖ All users now have app passwords with the new subdomains`);
    }

    // Function to manually select and save a subdomain
    function selectAndSaveSubdomain() {
        logBulkDomain('üîç Retrieving available domains for manual selection...');

        fetch('/api/retrieve-domains', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                batched: true
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.domains && data.domains.length > 0) {
                    logBulkDomain(`‚úÖ Retrieved ${data.domains.length} domains`);

                    // PRIORITY 1: Look for IN USE domains (these have users and should be updated)
                    const inUseDomains = data.domains.filter(domain => domain.status === 'in_use' && domain.user_count > 0);
                    let selectedDomain = null;

                    if (inUseDomains.length > 0) {
                        // Select the IN USE domain with the most users
                        selectedDomain = inUseDomains.reduce((prev, current) =>
                            (current.user_count > prev.user_count) ? current : prev
                        ).domainName;
                        const userCount = inUseDomains.find(d => d.domainName === selectedDomain).user_count;
                        logBulkDomain(`üéØ Selected IN USE domain: ${selectedDomain} (${userCount} users)`);
                    } else {
                        // PRIORITY 2: Look for any domain with users
                        const domainsWithUsers = data.domains.filter(domain => domain.user_count > 0);
                        if (domainsWithUsers.length > 0) {
                            selectedDomain = domainsWithUsers.reduce((prev, current) =>
                                (current.user_count > prev.user_count) ? current : prev
                            ).domainName;
                            const userCount = domainsWithUsers.find(d => d.domainName === selectedDomain).user_count;
                            logBulkDomain(`üéØ Selected domain with users: ${selectedDomain} (${userCount} users)`);
                        } else {
                            // PRIORITY 3: Fallback to available domains
                            const availableDomains = data.domains.filter(domain => domain.status === 'available');
                            if (availableDomains.length > 0) {
                                selectedDomain = availableDomains[0].domainName;
                                logBulkDomain(`üéØ Selected AVAILABLE domain: ${selectedDomain}`);
                            }
                        }
                    }

                    if (selectedDomain) {
                        // Save the selected subdomain
                        window.selectedSubdomain = selectedDomain;
                        window.currentTargetDomain = selectedDomain;

                        logBulkDomain(`üíæ Saved selected subdomain: ${selectedDomain}`);
                        logBulkDomain(`üîÑ This subdomain will be used for updating users and app passwords`);

                        // Update the subdomain prefix input field
                        const subdomainPrefix = document.getElementById('mega-subdomain-prefix');
                        if (subdomainPrefix) {
                            const subdomainPart = selectedDomain.split('.')[0];
                            subdomainPrefix.value = subdomainPart;
                            logBulkDomain(`üìù Updated subdomain prefix field: ${subdomainPart}`);
                        }
                    } else {
                        logBulkDomain(`‚ö†Ô∏è No suitable domains found for selection`);
                    }
                } else {
                    logBulkDomain(`‚ùå Failed to retrieve domains`);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Error retrieving domains: ${error.message}`);
            });
    }

    // Function to update users and generate app passwords with the selected IN USE subdomain
    function updateUsersWithSelectedSubdomain() {
        if (!window.selectedSubdomain) {
            logBulkDomain(`‚ùå No subdomain selected. Please run selectAndSaveSubdomain() first.`);
            return;
        }

        logBulkDomain(`üîÑ Updating users with selected subdomain: ${window.selectedSubdomain}`);

        // Get the current account from the Mega Upgrade modal
        const accountEmail = document.getElementById('mega-single-account').value.trim();
        if (!accountEmail) {
            logBulkDomain(`‚ùå No account email found. Please enter an account email first.`);
            return;
        }

        const accounts = [accountEmail];
        logBulkDomain(`üìß Processing account: ${accountEmail}`);

        // Generate app passwords with the selected IN USE subdomain
        generateAppPasswordsWithTargetDomain(accounts, window.selectedSubdomain);
    }

    function generateRandomPassword(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    function generateRandomSubdomain(length) {
        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    function displayWorkflowAppPasswords(appPasswords) {
        const display = document.getElementById('app-passwords-display');
        if (!display) return;

        let html = '<div class="workflow-app-passwords">';
        html += '<h4 style="margin-bottom: 16px; color: #24292f;">üîê App Passwords for Workflow</h4>';

        appPasswords.forEach(password => {
            html += `
            <div class="workflow-password-item" style="border: 1px solid #28a745; border-radius: 6px; padding: 12px; margin-bottom: 8px; background: #d4edda;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: #155724;">${password.user_alias}</strong>
                        <div style="color: #155724; font-size: 14px; margin-top: 4px;">
                            üîë ${password.app_password}
                        </div>
                        ${password.domain ? `<div style="color: #155724; font-size: 12px; margin-top: 2px;">üåê ${password.domain}</div>` : ''}
                    </div>
                    <div style="color: #28a745; font-size: 12px;">
                        ‚úÖ Ready
                    </div>
                </div>
            </div>
        `;
        });

        html += '</div>';
        display.innerHTML = html;
    }

    async function copyToClipboard(text) {
        try {
            // Try modern clipboard API first
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(text);
                return true;
            } else {
                // Fallback method for HTTP sites
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                const successful = document.execCommand('copy');
                document.body.removeChild(textArea);
                return successful;
            }
        } catch (err) {
            console.error('Copy failed:', err);
            return false;
        }
    }

    function enterAuthorizationCode() {
        const accountName = document.getElementById('account-select').value;

        if (!accountName) {
            alert('Please select an account first');
            return;
        }

        // Get the account ID from the selected option
        const selectedOption = document.querySelector(`#account-select option[value="${accountName}"]`);
        const accountId = selectedOption ? selectedOption.getAttribute('data-account-id') : null;

        if (!accountId) {
            alert('Account ID not found. Please refresh the page and try again.');
            return;
        }

        const authCode = prompt('Paste the authorization code from the authentication page:');

        if (!authCode) {
            return;
        }

        // Complete authentication with code
        fetch('/api/complete-oauth', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                auth_code: authCode.trim(),
                account_id: accountId,
                account_name: accountName
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ Authentication completed successfully!');

                    // Store the authenticated account in sessionStorage for persistence
                    sessionStorage.setItem('current_account_name', accountName);

                    updateAccountStatusAfterAuth(accountName, true);
                } else {
                    alert('‚ùå Authentication failed: ' + data.error);
                }
            })
            .catch(error => {
                alert('‚ùå Network error: ' + error);
            });
    }

    function copyResultsLog() {
        const logContent = document.getElementById('results-log').textContent;
        if (logContent.trim()) {
            copyToClipboard(logContent).then(success => {
                if (success) {
                    alert('üìã Log copied to clipboard!');
                } else {
                    alert('‚ùå Copy failed - please try manually selecting the text');
                }
            });
        } else {
            alert('No log content to copy');
        }
    }

    function updateAuthStatus(account, authenticated, message) {
        const statusBox = document.getElementById('auth-status');
        currentAccount = account;
        isAuthenticated = authenticated;

        if (authenticated) {
            statusBox.innerHTML = `<p style="color: green;">‚úÖ Authenticated as: ${account}</p>`;
            statusBox.className = 'status-box success';
        } else {
            statusBox.innerHTML = `<p style="color: red;">‚ùå ${message || 'Not authenticated'}</p>`;
            statusBox.className = 'status-box error';
        }
    }
    function authenticateAccount() {
        const select = document.getElementById('account-select');
        const accountName = select.value;

        if (!accountName) {
            alert('Please select an account first');
            return;
        }

        // Get the account ID from the selected option
        const selectedOption = select.querySelector(`option[value="${accountName}"]`);
        const accountId = selectedOption ? selectedOption.getAttribute('data-account-id') : null;

        if (!accountId) {
            alert('Account ID not found. Please refresh the page and try again.');
            return;
        }

        console.log('DEBUG: Authenticating account:', accountName, 'ID:', accountId);
        updateAuthStatus(accountName, false, 'Authenticating...');

        fetch('/api/authenticate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_id: accountId, account_name: accountName })
        })
            .then(response => response.json())
            .then(data => {
                console.log('DEBUG: API response:', data);

                if (data.success) {
                    updateAuthStatus(accountName, true, data.message);

                    // Store the authenticated account in sessionStorage for persistence
                    sessionStorage.setItem('current_account_name', accountName);

                    // UPDATE THE VISUAL STATUS IMMEDIATELY
                    updateAccountStatusAfterAuth(accountName, true);

                } else if (data.oauth_required && data.oauth_url) {
                    console.log('DEBUG: OAuth URL received:', data.oauth_url);
                    updateAuthStatus(accountName, false, 'OAuth URL generated - opening...');

                    // Show OAuth modal with the URL
                    showOAuthModal(data.oauth_url);

                } else {
                    console.error('DEBUG: Authentication failed:', data.error);
                    updateAuthStatus(accountName, false, data.error || 'Authentication failed');
                }
            })
            .catch(error => {
                console.error('DEBUG: Network error:', error);
                updateAuthStatus(accountName, false, 'Network error: ' + error);
            });
    }

    function completeOAuthWithCode() {
        const authCode = prompt('Paste the authorization code from the OAuth success page:');
        const accountName = document.getElementById('account-select').value;

        if (!authCode || !accountName) {
            alert('Code and account selection required');
            return;
        }

        fetch('/api/complete-oauth', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                auth_code: authCode.trim(),
                account_name: accountName
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ Authentication completed successfully!');
                    updateAccountStatusAfterAuth(accountName, true);
                } else {
                    alert('‚ùå Authentication failed: ' + data.error);
                }
            })
            .catch(error => {
                alert('‚ùå Network error: ' + error);
            });
    }


    // OAuth Modal functions
    function showOAuthModal(authUrl) {
        const modal = document.getElementById('oauthModal');
        const urlDiv = document.getElementById('oauthUrl');

        urlDiv.textContent = authUrl;
        modal.style.display = 'block';

        // Store URL globally for copying
        window.currentOAuthUrl = authUrl;
    }

    function closeOAuthModal() {
        document.getElementById('oauthModal').style.display = 'none';
    }

    function copyOAuthUrl() {
        if (window.currentOAuthUrl) {
            copyToClipboard(window.currentOAuthUrl).then(success => {
                if (success) {
                    alert('‚úÖ OAuth URL copied to clipboard!');
                } else {
                    alert('‚ùå Copy failed - please select and copy manually');
                }
            });
        }
    }

    function openOAuthUrl() {
        if (window.currentOAuthUrl) {
            window.open(window.currentOAuthUrl, '_blank');
        }
    }

    // Update existing window click handler
    window.onclick = function (event) {
        const modal = document.getElementById('oauthModal');
        if (event.target === modal) {
            closeOAuthModal();
        }
    }

    function retrieveUsers() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        document.getElementById('user-display').innerHTML = `
        <div class="status-info" style="background: #fff3cd; border-color: #ffeaa7;">
            <p><strong>üìä Loading Users</strong></p>
            <p>Retrieving user data from Google Admin API...</p>
            <p><small>This may take up to 2 minutes for large user bases (10k+ users).</small></p>
            <div style="margin-top: 10px;">
                <div class="progress-bar" style="width: 100%; background-color: #f0f0f0; border-radius: 5px; overflow: hidden;">
                    <div class="progress-fill" style="width: 0%; height: 20px; background-color: #007bff; transition: width 0.3s ease;"></div>
                </div>
                <p style="margin-top: 5px; font-size: 12px; color: #666;">Please wait while we retrieve all users...</p>
            </div>
        </div>`;

        // Batched retrieval to avoid 504 timeouts
        const allUsers = [];
        let nextToken = null;
        let batches = 0;
        const progressFill = document.querySelector('.progress-fill');

        const fetchBatch = async () => {
            const payload = { mode: 'batched', max_pages: 6 };
            if (nextToken) payload.page_token = nextToken;
            const resp = await fetch('/api/retrieve-users', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const text = await resp.text();
            let data;
            try { data = JSON.parse(text); } catch (e) { throw new Error('SERVER_HTML:' + text.slice(0, 200)); }
            if (!data.success) throw new Error(data.error || 'Unknown error');
            allUsers.push(...data.users);
            nextToken = data.next_page_token || null;
            batches += 1;
            if (progressFill) progressFill.style.width = Math.min(95, 10 + batches * 8) + '%';
            if (nextToken) {
                await new Promise(r => setTimeout(r, 150));
                return fetchBatch();
            }
            if (progressFill) progressFill.style.width = '100%';
            return allUsers;
        };

        fetchBatch().then(users => {
            const activeUsers = users.filter(user => !user.suspended).length;
            const suspendedUsers = users.filter(user => user.suspended).length;
            const adminUsers = users.filter(user => user.admin).length;
            let html = `<div class="status-summary">
            <div class="status-item"><span class="status-label">üìä Total Users:</span><span class="status-value">${users.length}</span></div>
            <div class="status-item"><span class="status-label">‚úÖ Active Users:</span><span class="status-value">${activeUsers}</span></div>
            <div class="status-item"><span class="status-label">üö´ Suspended Users:</span><span class="status-value">${suspendedUsers}</span></div>
            <div class="status-item"><span class="status-label">üëë Admin Users:</span><span class="status-value">${adminUsers}</span></div>
            </div>`;
            users.forEach(user => {
                const statusBadge = user.suspended ? '<span class="badge suspended">üö´ Suspended</span>' : '<span class="badge active">‚úÖ Active</span>';
                html += `<div class="user-item ${user.suspended ? 'suspended-user-item' : ''}">
                    <span class="email">${user.email}</span>
                    <span class="name">${user.first_name} ${user.last_name}</span>
                <span class="status-badges">${user.admin ? '<span class="badge admin">üëë Admin</span>' : ''}${statusBadge}</span>
                </div>`;
            });
            document.getElementById('user-display').innerHTML = html;
            document.getElementById('user-count').textContent = `Total Users: ${users.length}`;
            setTimeout(() => { loadSuspendedUsers(); }, 500);
        })
            .catch(error => {
                let errorMessage = 'Failed to connect to the server';
                let errorDetails = 'Please check your connection and try again.';

                if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
                    errorMessage = 'Request Timeout';
                    errorDetails = 'The request took longer than 2 minutes. For very large user bases (10k+ users), this is normal. Please try again.';
                } else if (error.name === 'AbortError') {
                    errorMessage = 'Request Aborted';
                    errorDetails = 'The request was cancelled. Please try again.';
                } else {
                    errorMessage = 'Network Error';
                    errorDetails = `Failed to connect to the server: ${error.message}`;
                }

                if (error.message && error.message.startsWith('SERVER_HTML:')) {
                    const snippet = error.message.replace('SERVER_HTML:', '');
                    document.getElementById('user-display').innerHTML = `
                <div class="status-info" style="background: #f8d7da; border-color: #f5c6cb;">
                    <p><strong>‚ùå Server Error</strong></p>
                    <p>The server returned an HTML error page instead of JSON. This usually means a timeout or crash upstream.</p>
                    <pre style="white-space: pre-wrap; max-height: 160px; overflow:auto; background:#fff; padding:8px; border:1px solid #eee;">${snippet}</pre>
                </div>`;
                } else {
                    document.getElementById('user-display').innerHTML = `
            <div class="status-info" style="background: #f8d7da; border-color: #f5c6cb;">
                    <p><strong>‚ùå ${errorMessage}</strong></p>
                    <p>${errorDetails}</p>
                    <p><small>If you have a very large user base (10k+ users), this may be a timeout. We've raised server timeouts to handle this.</small></p>
            </div>`;
                }
            });
    }

    function clearUserList() {
        document.getElementById('user-display').innerHTML = `
        <div class="status-info">
            <p><strong>üë• User Management</strong></p>
            <p>Click "üìä Retrieve All Users" to load and display all users from your Google Workspace.</p>
            <p><small>This will show user status (Active/Suspended), admin privileges, and provide options for bulk operations.</small></p>
        </div>`;
        document.getElementById('user-count').textContent = 'Total Users: 0';
    }

    function copyAllUsers() {
        const userElements = document.querySelectorAll('.user-item');
        if (userElements.length === 0) {
            alert('No users to copy');
            return;
        }

        const emails = Array.from(userElements).map(element => {
            const emailElement = element.querySelector('.email');
            return emailElement ? emailElement.textContent.trim() : '';
        }).filter(email => email);

        const emailText = emails.join('\n');

        copyToClipboard(emailText).then(success => {
            if (success) {
                alert(`‚úÖ Copied ${emails.length} user emails to clipboard`);
                logResult(`üìã Copied ${emails.length} user emails to clipboard`);
            } else {
                alert('‚ùå Copy failed - please try manually selecting the text');
            }
        });
    }

    function updateAllPasswords() {
        const password = document.getElementById('new-password').value;

        // Validation
        if (!password || password.length < 8) {
            alert('Password must be at least 8 characters');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        // Get emails from the displayed user items
        const userItems = document.querySelectorAll('.user-item .email');

        if (userItems.length === 0) {
            alert('No users found in the list. Please retrieve users first using "üìä Retrieve All Users" button.');
            return;
        }

        // Extract emails from the user display
        const userEmails = Array.from(userItems).map(item => item.textContent.trim());

        // Confirmation
        if (!confirm(`Update password for ALL ${userEmails.length} users?\n\nThis action cannot be undone.\n\nNew password: ${password}`)) {
            return;
        }

        // Show loading state
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'üîÑ Updating Passwords...';
        button.disabled = true;

        // Make API request
        fetch('/api/update-all-passwords', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                password: password,
                user_emails: userEmails
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    let message = data.message + '\n\n';

                    if (data.successful_emails.length > 0) {
                        message += `‚úÖ Successfully updated (${data.successful_emails.length}):\n`;
                        message += data.successful_emails.slice(0, 10).join('\n');
                        if (data.successful_emails.length > 10) {
                            message += `\n... and ${data.successful_emails.length - 10} more`;
                        }
                        message += '\n\n';
                    }

                    if (data.failed_details.length > 0) {
                        message += `‚ùå Failed updates (${data.failed_details.length}):\n`;
                        data.failed_details.slice(0, 5).forEach(failure => {
                            message += `${failure.email}: ${failure.error}\n`;
                        });
                        if (data.failed_details.length > 5) {
                            message += `... and ${data.failed_details.length - 5} more failures`;
                        }
                    }

                    alert(message);

                    // Clear password field
                    document.getElementById('new-password').value = '';

                } else {
                    alert('‚ùå Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Network error:', error);
                alert('‚ùå Network error: ' + error.message);
            })
            .finally(() => {
                // Restore button state
                button.textContent = originalText;
                button.disabled = false;
            });
    }

    function retrieveDomains() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        document.getElementById('domain-display').innerHTML = `
        <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 10px 0;">
            <p><strong>üîç Loading Domains</strong></p>
            <p>Retrieving domain data from Google Admin API...</p>
            <p><small>This may take a moment for large domain lists (500+ domains).</small></p>
            <div style="margin-top: 10px;">
                <div class="progress-bar" style="width: 100%; background-color: #f0f0f0; border-radius: 5px; overflow: hidden;">
                    <div class="progress-fill" style="width: 0%; height: 20px; background-color: #007bff; transition: width 0.3s ease;"></div>
                </div>
                <p style="margin-top: 5px; font-size: 12px; color: #666;">Please wait while we retrieve all domains...</p>
            </div>
        </div>`;

        // Batched retrieval to avoid timeouts with large domain lists
        const allDomains = [];
        let nextToken = null;
        let batches = 0;
        const progressFill = document.querySelector('.progress-fill');

        const fetchBatch = async () => {
            const payload = { mode: 'batched' };
            if (nextToken) payload.page_token = nextToken;

            const resp = await fetch('/api/retrieve-domains', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const text = await resp.text();
            let data;
            try { data = JSON.parse(text); } catch (e) { throw new Error('SERVER_HTML:' + text.slice(0, 200)); }

            if (!data.success) throw new Error(data.error || 'Unknown error');

            allDomains.push(...data.domains);
            nextToken = data.next_page_token || null;
            batches += 1;

            if (progressFill) progressFill.style.width = Math.min(95, 10 + batches * 15) + '%';

            if (nextToken) {
                await new Promise(r => setTimeout(r, 200));
                return fetchBatch();
            }

            if (progressFill) progressFill.style.width = '100%';
            return allDomains;
        };

        fetchBatch().then(domains => {
            let html = '';
            domains.forEach(domain => {
                // Extract domain information
                const domainName = domain.domainName || domain.domain_name || domain.domain || 'Unknown Domain';
                const isVerified = domain.verified || domain.isVerified || domain.is_verified || false;
                const userCount = domain.user_count || 0;
                const status = domain.status || 'available';
                const statusText = domain.status_text || 'AVAILABLE';
                const statusColor = domain.status_color || '#4CAF50';

                // Create status badge based on domain status
                let statusBadge = '';
                if (status === 'in_use') {
                    statusBadge = `<span class="badge in-use" style="background-color: #9C27B0; color: white;">üü£ IN USE</span>`;
                } else if (status === 'used') {
                    statusBadge = `<span class="badge used" style="background-color: #FF9800; color: white;">üü† USED</span>`;
                } else {
                    statusBadge = `<span class="badge available" style="background-color: #4CAF50; color: white;">üü¢ AVAILABLE</span>`;
                }

                html += `<div class="domain-item">
                <span class="domain-name">${domainName}</span>
                <span class="user-count">${userCount} users</span>
                ${isVerified ? '<span class="badge verified">‚úÖ Verified</span>' : '<span class="badge unverified">‚ùå Not Verified</span>'}
                ${statusBadge}
                </div>`;
            });
            document.getElementById('domain-display').innerHTML = html;
        })
            .catch(error => {
                if (error.message && error.message.startsWith('SERVER_HTML:')) {
                    const snippet = error.message.replace('SERVER_HTML:', '');
                    document.getElementById('domain-display').innerHTML = `<div class="domain-error">‚ùå Server Error: HTML error page returned<pre style="white-space: pre-wrap; max-height: 160px; overflow:auto; background:#fff; padding:8px; border:1px solid #eee;">${snippet}</pre></div>`;
                } else {
                    document.getElementById('domain-display').innerHTML = `<p style="color: red;">Network error: ${error}</p>`;
                }
            });
    }

    function clearDomainDisplay() {
        document.getElementById('domain-display').innerHTML = '<p>Click \'Retrieve Domains\' to view domains here...</p>';
    }

    function loadSuspendedUsers() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        document.getElementById('suspended-display').innerHTML = `
        <div class="status-info" style="background: #fff3cd; border-color: #ffeaa7;">
            <p><strong>üîç Loading Suspended Users</strong></p>
            <p>Retrieving user data from Google Admin API...</p>
            <p><small>This may take a few moments depending on the number of users.</small></p>
        </div>`;

        fetch('/api/load-suspended-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                console.log('Suspended users API response:', data); // Debug log
                if (data.success) {
                    if (data.users && data.users.length > 0) {
                        let html = `<div class="status-info">
                    <p><strong>üìä Found ${data.total_count} suspended user(s):</strong></p>
                    ${data.debug_info ? `<p><small>Debug: Raw count: ${data.debug_info.raw_suspended_count}, Formatted: ${data.debug_info.formatted_count}</small></p>` : ''}
                </div>`;

                        data.users.forEach(user => {
                            const fullName = user.full_name || `${user.first_name} ${user.last_name}`.trim() || 'No Name';
                            const adminBadge = user.admin ? '<span class="badge admin">üëë Admin</span>' : '';
                            const suspendedBadge = '<span class="badge suspended">üö´ Suspended</span>';

                            html += `<div class="suspended-user">
                        <div class="user-info">
                            <span class="email">${user.email}</span>
                            <span class="name">${fullName}</span>
                            ${adminBadge}
                            ${suspendedBadge}
                        </div>
                    </div>`;
                        });

                        document.getElementById('suspended-display').innerHTML = html;
                    } else {
                        document.getElementById('suspended-display').innerHTML = `
                    <div class="status-info">
                        <p><strong>‚úÖ No Suspended Users Found</strong></p>
                        <p>All users in this account are currently active.</p>
                        ${data.debug_info ? `<p><small>Debug: Raw count: ${data.debug_info.raw_suspended_count}, Formatted: ${data.debug_info.formatted_count}</small></p>` : ''}
                    </div>`;
                    }
                } else {
                    console.error('Suspended users API error:', data); // Debug log
                    document.getElementById('suspended-display').innerHTML = `
                <div class="status-info" style="background: #f8d7da; border-color: #f5c6cb;">
                    <p><strong>‚ùå Error Loading Suspended Users</strong></p>
                    <p>${data.error || 'Unknown error occurred'}</p>
                    <p><small>Please try refreshing or re-authenticating your account.</small></p>
                    <button onclick="debugAuthStatus()" class="btn-github" style="margin-top: 10px;">
                        üîç Debug Authentication Status
                    </button>
                    <button onclick="testSuspendedQuery()" class="btn-github" style="margin-top: 10px; margin-left: 10px;">
                        üß™ Test Suspended Query
                    </button>
                    <button onclick="console.log('Full API response:', ${JSON.stringify(data)})" class="btn-github" style="margin-top: 10px; margin-left: 10px;">
                        üìã Log Full Response
                    </button>
                </div>`;
                }
            })
            .catch(error => {
                document.getElementById('suspended-display').innerHTML = `
            <div class="status-info" style="background: #f8d7da; border-color: #f5c6cb;">
                <p><strong>‚ùå Network Error</strong></p>
                <p>Failed to connect to the server: ${error}</p>
                <p><small>Please check your connection and try again.</small></p>
            </div>`;
            });
    }


    function refreshSuspendedUsers() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        // Clear current display and reload
        document.getElementById('suspended-display').innerHTML = `
        <div class="status-info" style="background: #fff3cd; border-color: #ffeaa7;">
            <p><strong>üîÑ Refreshing Suspended Users</strong></p>
            <p>Updating user status from Google Admin API...</p>
            <p><small>Please wait while we refresh the data.</small></p>
        </div>`;

        // Reload after a short delay to show the refresh message
        setTimeout(() => {
            loadSuspendedUsers();
        }, 1000);
    }

    function clearSuspendedUsers() {
        document.getElementById('suspended-display').innerHTML = `
        <div class="status-info">
            <p><strong>‚õî Suspended User Management</strong></p>
            <p>Click "üîç Load Suspended Users" to check for suspended accounts in your Google Workspace.</p>
            <p><small>This will show all users with suspended status, including their names, emails, and admin privileges.</small></p>
        </div>`;
    }

    function debugAuthStatus() {
        fetch('/api/debug-auth-status')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const debugInfo = data.debug_info;
                    const debugHtml = `
                <div class="status-info" style="background: #e7f3ff; border-color: #b3d9ff;">
                    <p><strong>üîç Authentication Debug Information</strong></p>
                    <p><strong>Current Account:</strong> ${debugInfo.current_account || 'None'}</p>
                    <p><strong>Service Available:</strong> ${debugInfo.service_available ? '‚úÖ Yes' : '‚ùå No'}</p>
                    <p><strong>Token Valid:</strong> ${debugInfo.token_valid ? '‚úÖ Yes' : '‚ùå No'}</p>
                    <p><strong>Session ID:</strong> ${debugInfo.session_id || 'None'}</p>
                    <p><strong>Session Keys:</strong> ${debugInfo.session_keys.join(', ') || 'None'}</p>
                    <button onclick="clearSuspendedUsers()" class="btn-github" style="margin-top: 10px;">
                        üîô Back to Suspended Users
                    </button>
                </div>`;
                    document.getElementById('suspended-display').innerHTML = debugHtml;
                } else {
                    alert('Debug failed: ' + data.error);
                }
            })
            .catch(error => {
                alert('Debug request failed: ' + error);
            });
    }

    function testSuspendedQuery() {
        document.getElementById('suspended-display').innerHTML = `
        <div class="status-info" style="background: #fff3cd; border-color: #ffeaa7;">
            <p><strong>üß™ Testing Suspended User Queries</strong></p>
            <p>Running diagnostic tests...</p>
        </div>`;

        fetch('/api/test-suspended-query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                console.log('Test suspended query response:', data);
                if (data.success) {
                    const results = data.results;
                    let html = `
                <div class="status-info" style="background: #e7f3ff; border-color: #b3d9ff;">
                    <p><strong>üß™ Suspended Query Test Results</strong></p>
                    <p><strong>Account:</strong> ${data.account}</p>
            `;

                    // Direct suspended query results
                    if (results.direct_suspended_query.success) {
                        html += `
                    <p><strong>Direct Suspended Query:</strong> ‚úÖ Success</p>
                    <p><strong>Found:</strong> ${results.direct_suspended_query.count} suspended users</p>
                `;
                        if (results.direct_suspended_query.users.length > 0) {
                            html += `<p><strong>Users:</strong></p><ul>`;
                            results.direct_suspended_query.users.forEach(user => {
                                html += `<li>${user.email} (suspended: ${user.suspended})</li>`;
                            });
                            html += `</ul>`;
                        }
                    } else {
                        html += `
                    <p><strong>Direct Suspended Query:</strong> ‚ùå Failed</p>
                    <p><strong>Error:</strong> ${results.direct_suspended_query.error}</p>
                `;
                    }

                    // All users filter results
                    if (results.all_users_filter.success) {
                        html += `
                    <p><strong>All Users Filter:</strong> ‚úÖ Success</p>
                    <p><strong>Total Users:</strong> ${results.all_users_filter.total_users}</p>
                    <p><strong>Suspended Users:</strong> ${results.all_users_filter.suspended_count}</p>
                `;
                        if (results.all_users_filter.users.length > 0) {
                            html += `<p><strong>All Users (first 10):</strong></p><ul>`;
                            results.all_users_filter.users.forEach(user => {
                                html += `<li>${user.email} (suspended: ${user.suspended})</li>`;
                            });
                            html += `</ul>`;
                        }
                    } else {
                        html += `
                    <p><strong>All Users Filter:</strong> ‚ùå Failed</p>
                    <p><strong>Error:</strong> ${results.all_users_filter.error}</p>
                `;
                    }

                    html += `
                <button onclick="clearSuspendedUsers()" class="btn-github" style="margin-top: 10px;">
                    üîô Back to Suspended Users
                </button>
            </div>`;

                    document.getElementById('suspended-display').innerHTML = html;
                } else {
                    alert('Test failed: ' + data.error);
                }
            })
            .catch(error => {
                alert('Test request failed: ' + error);
            });
    }

    function refreshAccounts() {
        // Simply reload the page to refresh accounts from database
        location.reload();
    }

    // Modal functions
    function openAddAccountModal() {
        document.getElementById('addAccountModal').style.display = 'block';
    }

    function closeAddAccountModal() {
        document.getElementById('addAccountModal').style.display = 'none';
        document.getElementById('addAccountForm').reset();
    }

    // Close modal when clicking outside
    window.onclick = function (event) {
        const modal = document.getElementById('addAccountModal');
        if (event.target == modal) {
            closeAddAccountModal();
        }
    }

    // Save new account
    function saveNewAccount() {
        const email = document.getElementById('new-account-email').value;
        const clientId = document.getElementById('new-client-id').value;
        const clientSecret = document.getElementById('new-client-secret').value;

        if (!email || !clientId || !clientSecret) {
            alert('All fields are required');
            return;
        }

        if (!email.includes('@')) {
            alert('Please enter a valid email address');
            return;
        }

        fetch('/api/add-account', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                account_name: email,
                client_id: clientId,
                client_secret: clientSecret
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ Account added successfully!');
                    closeAddAccountModal();
                    location.reload(); // Reload to show new account
                } else {
                    alert('‚ùå Error: ' + data.error);
                }
            })
            .catch(error => {
                alert('‚ùå Network error: ' + error);
            });
    }

    // Account list functions
    function selectAccountFromList(accountName, accountId) {
        // Remove previous selection
        document.querySelectorAll('.account-item').forEach(item => {
            item.classList.remove('selected');
        });

        // Select clicked item
        event.target.classList.add('selected');
        selectedAccountFromList = accountName;
        selectedAccountId = accountId;

        // Also update dropdown
        document.getElementById('account-select').value = accountName;
    }

    function filterAccounts() {
        const searchTerm = document.getElementById('account-search').value.toLowerCase();
        const accountItems = document.querySelectorAll('.account-item');

        accountItems.forEach(item => {
            const accountName = item.textContent.toLowerCase();
            if (accountName.includes(searchTerm)) {
                item.style.display = 'block';
            } else {
                item.style.display = 'none';
            }
        });
    }

    function authenticateFromList() {
        if (!selectedAccountFromList || !selectedAccountId) {
            alert('Please select an account from the list first');
            return;
        }

        // Set the dropdown to selected account and authenticate
        document.getElementById('account-select').value = selectedAccountFromList;

        // Call the updated authenticate function
        authenticateAccount();
    }
    function deleteFromList() {
        if (!selectedAccountFromList || !selectedAccountId) {
            alert('Please select an account from the list first');
            return;
        }

        if (!confirm(`Are you sure you want to delete account: ${selectedAccountFromList}?`)) {
            return;
        }

        // Delete directly using the stored account ID
        fetch('/api/delete-account', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_id: selectedAccountId })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ Account deleted successfully!');
                    selectedAccountFromList = null;
                    selectedAccountId = null;
                    location.reload(); // Reload to refresh the display
                } else {
                    alert('‚ùå Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
                alert('‚ùå Error: ' + error.message);
            });
    }

    // Bulk Delete Functions
    function openBulkDeleteModal() {
        // Admin check is handled by the backend, so we can proceed directly
        // The button is only shown to admins via server-side template logic

        // Clear previous data
        document.getElementById('bulkDeleteAccounts').value = '';
        document.getElementById('bulkDeleteProgress').style.display = 'none';
        document.getElementById('bulkDeleteResults').style.display = 'none';
        document.getElementById('bulkDeleteExecuteBtn').disabled = false;

        // Show modal
        document.getElementById('bulkDeleteModal').style.display = 'block';
    }

    function closeBulkDeleteModal() {
        document.getElementById('bulkDeleteModal').style.display = 'none';
    }

    function executeBulkDelete() {
        const accountsText = document.getElementById('bulkDeleteAccounts').value.trim();

        if (!accountsText) {
            alert('‚ùå Please enter at least one account name to delete.');
            return;
        }

        // Parse account names
        const accountNames = accountsText.split('\n')
            .map(name => name.trim())
            .filter(name => name.length > 0);

        if (accountNames.length === 0) {
            alert('‚ùå Please enter valid account names.');
            return;
        }

        // Confirm deletion
        if (!confirm(`Are you sure you want to delete ${accountNames.length} accounts?\n\nThis action cannot be undone!`)) {
            return;
        }

        // Show progress
        document.getElementById('bulkDeleteProgress').style.display = 'block';
        document.getElementById('bulkDeleteResults').style.display = 'none';
        document.getElementById('bulkDeleteExecuteBtn').disabled = true;

        // Update progress
        updateBulkDeleteProgress(0, accountNames.length, 'Starting bulk deletion...');

        // Execute bulk delete
        fetch('/api/bulk-delete-accounts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_names: accountNames })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateBulkDeleteProgress(accountNames.length, accountNames.length, 'Bulk deletion completed!');
                    showBulkDeleteResults(data.results, accountNames.length);

                    // Reload page after 3 seconds to refresh the account list
                    setTimeout(() => {
                        location.reload();
                    }, 3000);
                } else {
                    updateBulkDeleteProgress(0, accountNames.length, 'Bulk deletion failed!');
                    showBulkDeleteResults([{ success: false, account: 'All', error: data.error }], 0);
                }
            })
            .catch(error => {
                console.error('Bulk delete error:', error);
                updateBulkDeleteProgress(0, accountNames.length, 'Network error occurred!');
                showBulkDeleteResults([{ success: false, account: 'All', error: error.message }], 0);
            })
            .finally(() => {
                document.getElementById('bulkDeleteExecuteBtn').disabled = false;
            });
    }

    function updateBulkDeleteProgress(completed, total, status) {
        const percentage = total > 0 ? (completed / total) * 100 : 0;

        document.getElementById('bulkDeleteStatus').textContent = status;
        document.getElementById('bulkDeleteCount').textContent = `${completed}/${total}`;
        document.getElementById('bulkDeleteProgressBar').style.width = percentage + '%';
    }

    function showBulkDeleteResults(results, totalAccounts) {
        const resultsContainer = document.getElementById('bulkDeleteResultsContent');
        let html = '';

        let successful = 0;
        let failed = 0;

        results.forEach(result => {
            if (result.success) {
                successful++;
                html += `<div style="color: #2da44e; margin-bottom: 4px;">‚úÖ ${result.account} - Deleted successfully</div>`;
            } else {
                failed++;
                html += `<div style="color: #da3633; margin-bottom: 4px;">‚ùå ${result.account} - ${result.error}</div>`;
            }
        });

        // Add summary
        html = `<div style="font-weight: 600; margin-bottom: 8px; color: #24292f;">
                Summary: ${successful} successful, ${failed} failed out of ${totalAccounts} total
            </div>` + html;

        resultsContainer.innerHTML = html;
        document.getElementById('bulkDeleteResults').style.display = 'block';
    }

    function refreshAccountsDisplay() {
        // Simply reload the page to refresh accounts from database
        location.reload();
    }

    // Admin-only manual token status check
    function forceTokenStatusCheck() {
        if (confirm('üîç Force token status check for all accounts?\n\nThis will check the database for current token status.')) {
            console.log('Admin triggered manual token status check');

            // Update status display
            updateAccountStats(0, 0, 0, 'Admin check starting...');

            // Use database API instead of JSON
            checkTokenStatusFromDatabase();
        }
    }

    // Check token status from database (replaces JSON-based approach)
    async function checkTokenStatusFromDatabase() {
        try {
            console.log('=== Starting DATABASE token status check ===');

            // Get token status from database API
            const response = await fetch('/api/check-token-status', {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
            });

            const data = await response.json();

            if (data.success && data.token_status) {
                console.log('Database token status received:', data.token_status);

                // Update visual status for each account
                let totalAccounts = data.token_status.length;
                let validAccounts = 0;
                let invalidAccounts = 0;

                data.token_status.forEach(accountStatus => {
                    const accountName = accountStatus.account_name;
                    const hasTokens = accountStatus.has_tokens;
                    const tokenValid = accountStatus.token_valid;

                    // Find the account item in the UI
                    const accountItems = document.querySelectorAll('.account-item');
                    accountItems.forEach(item => {
                        const itemAccountName = item.textContent.trim().split('\n')[0].trim();
                        if (itemAccountName === accountName) {
                            // Remove old status
                            const oldStatus = item.querySelector('.token-status');
                            if (oldStatus) oldStatus.remove();

                            // Add new status
                            const statusSpan = document.createElement('span');
                            statusSpan.className = 'token-status';
                            statusSpan.textContent = tokenValid ? ' ‚úÖ' : ' ‚ùå';
                            statusSpan.style.cssText = 'float: right; margin-left: 10px;';
                            item.appendChild(statusSpan);

                            // Update dropdown
                            updateDropdownOption(accountName, tokenValid);

                            // Count accounts
                            if (tokenValid) {
                                validAccounts++;
                            } else {
                                invalidAccounts++;
                            }
                        }
                    });
                });

                // Update stats
                updateAccountStats(totalAccounts, validAccounts, invalidAccounts, 'Database check complete');
                console.log(`‚úÖ Database check complete: ${validAccounts}/${totalAccounts} authenticated`);

            } else {
                console.error('Failed to get token status from database:', data.error);
                updateAccountStats(0, 0, 0, 'Database check failed');
            }

        } catch (error) {
            console.error('Database token status check failed:', error);
            updateAccountStats(0, 0, 0, 'Database check failed');
        }
    }

    function updateAccountStatusAfterAuth(accountName, isAuthenticated) {
        // Update the account in the list
        const accountItems = document.querySelectorAll('.account-item');

        accountItems.forEach(item => {
            const itemAccountName = item.textContent.trim().split('\n')[0].trim();

            if (itemAccountName === accountName) {
                // Remove old status
                const oldStatus = item.querySelector('.token-status');
                if (oldStatus) oldStatus.remove();

                // Add new status
                const statusSpan = document.createElement('span');
                statusSpan.className = isAuthenticated ? 'token-status valid' : 'token-status invalid';
                statusSpan.textContent = isAuthenticated ? ' ‚úÖ' : ' ‚ùå';
                statusSpan.style.cssText = 'float: right; margin-left: 10px;';
                item.appendChild(statusSpan);

                console.log(`Updated ${accountName} status to: ${isAuthenticated ? 'Valid' : 'Invalid'}`);
            }
        });

        // Update dropdown
        const option = document.querySelector(`#account-select option[value="${accountName}"]`);
        if (option) {
            option.textContent = `${accountName} ${isAuthenticated ? '‚úÖ' : '‚ùå'}`;
        }

        // Update counter
        updateCountersAfterChange();
    }

    function updateCountersAfterChange() {
        const accountItems = document.querySelectorAll('.account-item');
        let totalAccounts = accountItems.length;
        let validAccounts = 0;
        let invalidAccounts = 0;

        accountItems.forEach(item => {
            const statusElement = item.querySelector('.token-status');
            if (statusElement) {
                if (statusElement.textContent.includes('‚úÖ')) {
                    validAccounts++;
                } else {
                    invalidAccounts++;
                }
            }
        });

        updateAccountStats(totalAccounts, validAccounts, invalidAccounts, 'Updated');
    }

    function addFromServerJSON() {
        // Create a modal dialog instead of simple prompt
        const modal = document.createElement('div');
        modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;

        const dialog = document.createElement('div');
        dialog.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 10px;
        width: 600px;
        max-width: 90vw;
        max-height: 80vh;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        color: #333;
    `;

        dialog.innerHTML = `
        <h3 style="margin-bottom: 20px; color: #007bff;">üìÅ Add Accounts from Server JSON</h3>
        
        <p style="margin-bottom: 15px; color: #666;">
            Enter Google Workspace admin email addresses below (one per line).<br>
            The system will search for corresponding JSON credential files on the server.
        </p>
        
        <div style="margin-bottom: 15px;">
            <label style="font-weight: bold; display: block; margin-bottom: 5px;">Email Addresses:</label>
            <textarea id="emailInput" placeholder="admin@domain1.com&#10;admin@domain2.com&#10;admin@domain3.com&#10;..." 
                style="width: 100%; height: 250px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-family: monospace; resize: vertical;"></textarea>
        </div>
        
        <div style="margin-bottom: 20px; padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #007bff;">
            <strong>üí° Tips:</strong>
            <ul style="margin: 5px 0 0 20px; color: #666;">
                <li>Enter one email address per line</li>
                <li>You can paste multiple emails at once</li>
                <li>Empty lines will be ignored</li>
                <li>Files must be named exactly: <code>&lt;email&gt;.json</code></li>
            </ul>
        </div>
        
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button id="cancelBtn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">
                ‚ùå Cancel
            </button>
            <button id="searchBtn" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;" disabled>
                üîç Search & Add Accounts
            </button>
        </div>
    `;

        modal.appendChild(dialog);
        document.body.appendChild(modal);

        // Get elements
        const emailInput = dialog.querySelector('#emailInput');
        const searchBtn = dialog.querySelector('#searchBtn');
        const cancelBtn = dialog.querySelector('#cancelBtn');

        // Update button state as user types
        function updateButtonState() {
            const text = emailInput.value.trim();
            if (!text) {
                searchBtn.disabled = true;
                return;
            }

            const emails = text.split('\n')
                .map(email => email.trim())
                .filter(email => email && email.includes('@'));

            searchBtn.disabled = emails.length === 0;
        }

        // Add event listeners
        emailInput.addEventListener('input', updateButtonState);
        emailInput.addEventListener('paste', () => setTimeout(updateButtonState, 10));

        cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
        });

        searchBtn.addEventListener('click', () => {
            const emails = emailInput.value.trim()
                .split('\n')
                .map(email => email.trim())
                .filter(email => email && email.includes('@'));

            if (emails.length === 0) {
                alert('No valid email addresses found');
                return;
            }

            // Close modal
            document.body.removeChild(modal);

            // Show confirmation
            if (!confirm(`Search for JSON credential files for ${emails.length} email address(es)?`)) {
                return;
            }

            // Process the search using server configuration
            processServerJSONSearch(emails);
        });

        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });

        // Focus on textarea
        setTimeout(() => emailInput.focus(), 100);
    }

    // Separate function to handle the actual API call using server configuration
    function processServerJSONSearch(emails) {
        // Show loading in some button (you can modify this)
        const button = document.querySelector('[onclick="addFromServerJSON()"]');
        const originalText = button.textContent;
        button.textContent = 'üîç Searching...';
        button.disabled = true;

        // Make API request using server configuration
        fetch('/api/add-from-server-json', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ emails: emails })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    let message = data.message + '\n\n';

                    if (data.added_accounts && data.added_accounts.length > 0) {
                        message += `‚úÖ Successfully added:\n${data.added_accounts.join('\n')}\n\n`;
                    }

                    if (data.failed_accounts && data.failed_accounts.length > 0) {
                        message += `‚ùå Failed accounts:\n`;
                        for (const failed of data.failed_accounts) {
                            message += `${failed.email}: ${failed.error}\n`;
                        }
                    }

                    alert(message);

                    // Refresh the account list if any were added
                    if (data.added_accounts && data.added_accounts.length > 0) {
                        refreshAccountsDisplay();
                    }
                } else {
                    alert('‚ùå Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Network error:', error);
                alert('‚ùå Network error: ' + error.message);
            })
            .finally(() => {
                // Restore button state
                button.textContent = originalText;
                button.disabled = false;
            });
    }

    function debugSFTPFiles() {
        fetch('/api/debug-sftp-files', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    let message = "SFTP Directory Contents:\n\n";

                    if (data.directories.shared_credentials) {
                        if (data.directories.shared_credentials.error) {
                            message += `‚ùå shared_credentials: ${data.directories.shared_credentials.error}\n\n`;
                        } else {
                            message += `üìÅ shared_credentials (${data.directories.shared_credentials.total_count} files):\n`;
                            message += data.directories.shared_credentials.files.join('\n') + '\n\n';
                        }
                    }

                    if (data.directories.account) {
                        if (data.directories.account.error) {
                            message += `‚ùå account: ${data.directories.account.error}\n\n`;
                        } else {
                            message += `üìÅ account (${data.directories.account.total_count} files):\n`;
                            message += data.directories.account.files.join('\n');
                        }
                    }

                    alert(message);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                alert('Network error: ' + error);
            });
    }

    // Placeholder functions for buttons that need implementation

    function backupFiles() {
        alert('Backup Files feature coming soon!');
    }

    // Update the existing refreshAccounts function
    function refreshAccounts() {
        refreshAccountsDisplay();
    }

    // Tab 2 Functions

    function createUsersFromCSV() {
        const fileInput = document.getElementById('csv-file-input');
        if (!fileInput.files.length) {
            alert('Please select a CSV file first');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult('üì• Starting CSV user creation...');

        const formData = new FormData();
        formData.append('csv_file', fileInput.files[0]);

        fetch('/api/create-users-from-csv', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ CSV processing completed. Created ${data.created_count} users.`);
                    if (data.results) {
                        data.results.forEach(result => {
                            if (result.success) {
                                logResult(`‚úÖ Created: ${result.email}`);
                            } else {
                                logResult(`‚ùå Failed: ${result.email} - ${result.error}`);
                            }
                        });
                    }
                } else {
                    logResult(`‚ùå CSV creation failed: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error}`);
            });
    }

    function createRandomUsers() {
        const count = document.getElementById('random-user-count').value;
        const domain = document.getElementById('random-user-domain').value;
        const password = document.getElementById('random-user-password').value;

        if (!count || count <= 0) {
            alert('Please enter a valid number of users');
            return;
        }

        if (!domain || !domain.includes('.')) {
            alert('Please enter a valid domain');
            return;
        }

        if (!password || password.length < 8) {
            alert('Please enter a password (minimum 8 characters)');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult(`üé≤ Creating ${count} random users for ${domain} with password...`);

        fetch('/api/create-random-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                num_users: parseInt(count),
                domain: domain,
                password: password
            })
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ Random user creation completed. Password: ${data.password}`);
                    if (data.results) {
                        let successCount = 0;
                        let failureCount = 0;

                        data.results.forEach(result => {
                            if (result.result.success) {
                                logResult(`‚úÖ Created: ${result.email}`);
                                successCount++;
                            } else {
                                // Handle different error types for random users
                                if (result.result.error_type === 'domain_limit') {
                                    logResult(`üö´ DOMAIN LIMIT: ${result.email} - ${result.result.error}`);
                                    logResult(`üí° Solution: Upgrade to paid Google Workspace subscription`);
                                } else if (result.result.error_type === 'duplicate_user') {
                                    logResult(`üë§ DUPLICATE: ${result.email} - ${result.result.error}`);
                                    logResult(`üí° Solution: User already exists, skipping`);
                                } else {
                                    logResult(`‚ùå Failed: ${result.email} - ${result.result.error}`);
                                }
                                failureCount++;
                            }
                        });

                        logResult(`üìä Summary: ${successCount} successful, ${failureCount} failed`);

                        if (failureCount > 0) {
                            logResult(`üí° Note: Some users failed due to domain limits or duplicates`);
                        }
                    }
                } else {
                    // Handle overall failure
                    if (data.error_type === 'domain_limit') {
                        logResult(`üö´ DOMAIN LIMIT REACHED: ${data.error}`);
                        logResult(`üí° Solution: Upgrade to a paid Google Workspace subscription`);
                        logResult(`üìä Target domain: ${domain}`);
                    } else {
                        logResult(`‚ùå Random user creation failed: ${data.error}`);
                    }
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
                logResult(`üí° Solution: Check your internet connection and try again`);
            });
    }

    function createRandomAdminUsers() {
        const count = document.getElementById('random-admin-count').value;
        const domain = document.getElementById('random-admin-domain').value;
        const password = document.getElementById('random-admin-password').value;
        const adminRole = document.getElementById('admin-role').value;

        if (!count || count <= 0) {
            alert('Please enter a valid number of admin users');
            return;
        }

        if (!domain || !domain.includes('.')) {
            alert('Please enter a valid domain');
            return;
        }

        if (!password || password.length < 8) {
            alert('Please enter a password (minimum 8 characters)');
            return;
        }

        if (!adminRole) {
            alert('Please select an admin role');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        // Confirm admin creation due to elevated permissions
        if (!confirm(`‚ö†Ô∏è WARNING: You are about to create ${count} admin users with ${adminRole} permissions.\n\nThis will give them elevated access to your Google Workspace.\n\nAre you sure you want to continue?`)) {
            return;
        }

        logResult(`üëë Creating ${count} random admin users for ${domain} with ${adminRole} permissions...`);

        fetch('/api/create-random-admin-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                num_users: parseInt(count),
                domain: domain,
                password: password,
                admin_role: adminRole
            })
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ Random admin user creation completed. Password: ${data.password}`);
                    if (data.results) {
                        let successCount = 0;
                        let failureCount = 0;

                        data.results.forEach(result => {
                            if (result.result.success) {
                                logResult(`‚úÖ Created Admin: ${result.email} (${result.admin_role})`);
                                logResult(`üìù Note: ${result.result.message}`);
                                successCount++;
                            } else {
                                if (result.result.error_type === 'domain_limit') {
                                    logResult(`üö´ DOMAIN LIMIT: ${result.email} - ${result.result.error}`);
                                    logResult(`üí° Solution: Upgrade to paid Google Workspace subscription`);
                                } else if (result.result.error_type === 'duplicate_user') {
                                    logResult(`üë§ DUPLICATE: ${result.email} - ${result.result.error}`);
                                    logResult(`üí° Solution: User already exists, skipping`);
                                } else if (result.result.error_type === 'admin_permission_error') {
                                    logResult(`üîí ADMIN PERMISSION ERROR: ${result.email} - ${result.result.error}`);
                                    logResult(`üí° Solution: Check if you have permission to assign admin roles`);
                                } else {
                                    logResult(`‚ùå Failed: ${result.email} - ${result.result.error}`);
                                }
                                failureCount++;
                            }
                        });

                        logResult(`üìä Summary: ${successCount} admin users created, ${failureCount} failed`);

                        if (successCount > 0) {
                            logResult(`‚ö†Ô∏è IMPORTANT: Admin users have been created with elevated permissions!`);
                            logResult(`üîê Please ensure these accounts are properly secured and monitored.`);
                        }

                        if (failureCount > 0) {
                            logResult(`üí° Note: Some admin users failed due to domain limits, duplicates, or permission issues`);
                        }
                    }
                } else {
                    if (data.error_type === 'domain_limit') {
                        logResult(`üö´ DOMAIN LIMIT REACHED: ${data.error}`);
                        logResult(`üí° Solution: Upgrade to a paid Google Workspace subscription`);
                    } else if (data.error_type === 'admin_permission_error') {
                        logResult(`üîí ADMIN PERMISSION ERROR: ${data.error}`);
                        logResult(`üí° Solution: Ensure you have permission to create admin users`);
                    } else {
                        logResult(`‚ùå Random admin user creation failed: ${data.error}`);
                    }
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
                logResult(`üí° Solution: Check your internet connection and try again`);
            });
    }
    function updateUserPasswords() {
        const usersText = document.getElementById('password-update-users').value;
        const newPassword = document.getElementById('password-update-new-password').value;

        if (!usersText.trim()) {
            alert('Please enter user email addresses');
            return;
        }

        if (!newPassword || newPassword.length < 8) {
            alert('Please enter a password (minimum 8 characters)');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        // Parse users from textarea (one per line)
        const users = usersText.split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);

        if (users.length === 0) {
            alert('Please enter at least one valid email address');
            return;
        }

        logResult(`üîë Updating passwords for ${users.length} users...`);

        fetch('/api/update-user-passwords', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                users: users,
                new_password: newPassword
            })
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ Password update completed!`);
                    if (data.results) {
                        let successCount = 0;
                        let failureCount = 0;

                        data.results.forEach(result => {
                            if (result.success) {
                                logResult(`‚úÖ Updated: ${result.email}`);
                                successCount++;
                            } else {
                                logResult(`‚ùå Failed: ${result.email} - ${result.error}`);
                                failureCount++;
                            }
                        });

                        logResult(`üìä Summary: ${successCount} successful, ${failureCount} failed`);
                    }
                } else {
                    logResult(`‚ùå Password update failed: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
                logResult(`üí° Solution: Check your internet connection and try again`);
            });
    }

    // User Suspension Functions
    function suspendUser() {
        const email = document.getElementById('suspend-user-email').value.trim();

        if (!email) {
            alert('Please enter an email address');
            return;
        }

        if (!email.includes('@')) {
            alert('Please enter a valid email address');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        if (!confirm(`‚ö†Ô∏è Are you sure you want to suspend user: ${email}?\n\nThis will prevent them from accessing their account.`)) {
            return;
        }

        logResult(`üö´ Suspending user: ${email}...`);

        fetch('/api/suspend-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: email })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ ${data.message}`);
                    document.getElementById('suspend-user-email').value = '';
                } else {
                    logResult(`‚ùå Failed to suspend user: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
            });
    }

    function unsuspendUser() {
        const email = document.getElementById('unsuspend-user-email').value.trim();

        if (!email) {
            alert('Please enter an email address');
            return;
        }

        if (!email.includes('@')) {
            alert('Please enter a valid email address');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        if (!confirm(`‚úÖ Are you sure you want to unsuspend user: ${email}?\n\nThis will restore their account access.`)) {
            return;
        }

        logResult(`‚úÖ Unsuspending user: ${email}...`);

        fetch('/api/unsuspend-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: email })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ ${data.message}`);
                    document.getElementById('unsuspend-user-email').value = '';
                } else {
                    logResult(`‚ùå Failed to unsuspend user: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
            });
    }


    function loadSuspendedUsers() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult('üîç Loading suspended users...');

        fetch('/api/get-suspended-users')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displaySuspendedUsers(data.suspended_users);
                    document.getElementById('suspended-count').textContent = `Suspended Users: ${data.total_count}`;
                    logResult(`‚úÖ Loaded ${data.total_count} suspended users`);
                } else {
                    logResult(`‚ùå Failed to load suspended users: ${data.error}`);
                    document.getElementById('suspended-display').innerHTML = `<div class="error-message">‚ùå Error: ${data.error}</div>`;
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
                document.getElementById('suspended-display').innerHTML = `<div class="error-message">‚ùå Network error: ${error.message}</div>`;
            });
    }

    function displaySuspendedUsers(users) {
        if (!users || users.length === 0) {
            document.getElementById('suspended-display').innerHTML = '<div class="status-info"><p>‚úÖ No suspended users found</p></div>';
            return;
        }

        let html = '<div class="suspended-users-list">';
        html += '<h4 style="margin-bottom: 16px; color: #d73a49;">üö´ Suspended Users</h4>';

        users.forEach(user => {
            const adminBadge = user.isAdmin ? '<span class="badge admin">üëë Admin</span>' : '';
            const lastLogin = user.lastLoginTime === 'Never' ? 'Never' : new Date(user.lastLoginTime).toLocaleDateString();

            // Standard suspended user styling
            const cardStyle = 'border: 1px solid #d73a49; background: #ffeaea;';
            const statusColor = '#d73a49';
            const statusIcon = 'üö´';

            html += `
            <div class="suspended-user-item" style="${cardStyle} border-radius: 6px; padding: 12px; margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${user.name || user.firstName + ' ' + user.lastName}</strong>
                        <div style="color: #666; font-size: 14px;">${user.email}</div>
                        <div style="color: ${statusColor}; font-size: 12px; margin-top: 4px;">
                            ${statusIcon} Suspended | Last Login: ${lastLogin}
                        </div>
                        <div style="color: #666; font-size: 12px; margin-top: 2px;">
                            Reason: ${user.suspensionReason}
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        ${adminBadge}
                        <button onclick="unsuspendUserFromList('${user.email}')" class="btn-github btn-github-success" style="font-size: 12px; padding: 4px 8px;">
                            <i class="fas fa-user-check"></i> Unsuspend
                        </button>
                    </div>
                </div>
            </div>
        `;
        });

        html += '</div>';
        document.getElementById('suspended-display').innerHTML = html;
    }

    function unsuspendUserFromList(email) {
        if (!confirm(`‚úÖ Are you sure you want to unsuspend user: ${email}?`)) {
            return;
        }

        logResult(`‚úÖ Unsuspending user: ${email}...`);

        fetch('/api/unsuspend-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: email })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ ${data.message}`);
                    // Refresh the suspended users list
                    loadSuspendedUsers();
                } else {
                    logResult(`‚ùå Failed to unsuspend user: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
            });
    }




    function copySuspendedUsers() {
        const display = document.getElementById('suspended-display');

        // Check if there are any suspended users loaded
        if (!display || display.textContent.includes('üìù Activity log will appear here...') ||
            display.textContent.includes('No suspended users found') ||
            display.textContent.includes('Click "Load Suspended Users"')) {
            alert('No suspended users loaded. Please click "Load Suspended Users" first.');
            return;
        }

        const userItems = display.querySelectorAll('.suspended-user-item');

        if (userItems.length === 0) {
            alert('No suspended users to copy');
            return;
        }

        let emails = [];
        userItems.forEach(item => {
            // Extract only the email address from the item
            const emailElement = item.querySelector('div[style*="color: #666"]');

            if (emailElement) {
                const email = emailElement.textContent.trim();
                if (email && email.includes('@')) {
                    emails.push(email);
                }
            }
        });

        if (emails.length > 0) {
            const textToCopy = emails.join('\n');

            // Try modern clipboard API first
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    logResult(`üìã Copied ${emails.length} suspended user emails to clipboard`);
                    alert(`‚úÖ Copied ${emails.length} suspended user emails to clipboard!`);
                }).catch(() => {
                    // Fallback method
                    copyToClipboardFallback(textToCopy, emails.length);
                });
            } else {
                // Fallback for older browsers
                copyToClipboardFallback(textToCopy, emails.length);
            }
        } else {
            alert('No valid email addresses found to copy');
        }
    }

    function copyToClipboardFallback(text, count) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                logResult(`üìã Copied ${count} suspended user emails to clipboard (fallback method)`);
                alert(`‚úÖ Copied ${count} suspended user emails to clipboard!`);
            } else {
                throw new Error('Copy command failed');
            }
        } catch (err) {
            logResult(`‚ùå Failed to copy to clipboard: ${err.message}`);
            alert('‚ùå Copy failed. Please try manually selecting the text.');
        } finally {
            document.body.removeChild(textArea);
        }
    }

    function refreshSuspendedUsers() {
        loadSuspendedUsers();
    }

    function clearSuspendedUsers() {
        document.getElementById('suspended-display').innerHTML = `
        <div class="status-info">
            <p><strong><i class="fas fa-user-slash"></i> Suspended User Management</strong></p>
            <p>Click "Load Suspended Users" to check for suspended accounts in your Google Workspace.</p>
            <p><small>This will show all users with suspended status, including their names, emails, and admin privileges.</small></p>
        </div>
    `;
        document.getElementById('suspended-count').textContent = 'Suspended Users: 0';
    }

    function changeDomainForUsers() {
        const oldDomain = document.getElementById('old-domain').value;
        const newDomain = document.getElementById('new-domain').value;
        const emailsText = document.getElementById('domain-change-emails').value;

        if (!oldDomain || !newDomain) {
            alert('Please enter both old and new domains');
            return;
        }

        if (!emailsText.trim()) {
            alert('Please enter email addresses');
            return;
        }

        const emails = emailsText.split('\n').map(e => e.trim()).filter(e => e);

        if (emails.length === 0) {
            alert('No valid email addresses found');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult(`üîÑ Changing domain from ${oldDomain} to ${newDomain} for ${emails.length} users...`);

        fetch('/api/change-domain', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                old_domain: oldDomain,
                new_domain: newDomain,
                user_emails: emails
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ Domain change completed for ${emails.length} users.`);
                    if (data.results) {
                        data.results.forEach(result => {
                            if (result.success) {
                                logResult(`‚úÖ Changed: ${result.old_email} ‚Üí ${result.new_email}`);
                            } else {
                                logResult(`‚ùå Failed: ${result.email} - ${result.error}`);
                            }
                        });
                    }
                } else {
                    logResult(`‚ùå Domain change failed: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error}`);
            });
    }

    function deleteSpecificUsers() {
        const emailsText = document.getElementById('delete-user-emails').value;

        if (!emailsText.trim()) {
            alert('Please enter email addresses to delete');
            return;
        }

        const emails = emailsText.split('\n').map(e => e.trim()).filter(e => e);

        if (emails.length === 0) {
            alert('No valid email addresses found');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        if (!confirm(`‚ö†Ô∏è Are you sure you want to DELETE ${emails.length} users? This cannot be undone!`)) {
            return;
        }

        logResult(`‚ùå Deleting ${emails.length} users...`);

        fetch('/api/delete-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                user_emails: emails
            })
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ User deletion completed for ${emails.length} users.`);
                    if (data.results) {
                        data.results.forEach(result => {
                            if (result.result.success) {
                                logResult(`‚úÖ Deleted: ${result.email}`);
                            } else {
                                logResult(`‚ùå Failed to delete: ${result.email} - ${result.result.error}`);
                            }
                        });
                    }
                } else {
                    logResult(`‚ùå User deletion failed: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Delete users error:', error);
                logResult(`‚ùå Network error: ${error.message || error}`);
            });
    }

    function createSingleUser() {
        const firstName = document.getElementById('new-user-first-name').value;
        const lastName = document.getElementById('new-user-last-name').value;
        const email = document.getElementById('new-user-email').value;
        const password = document.getElementById('new-user-password').value;

        if (!firstName || !lastName || !email || !password) {
            alert('Please fill in all fields for the new user.');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult(`‚ûï Creating user: ${email}...`);

        fetch('/api/create-gsuite-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                first_name: firstName,
                last_name: lastName,
                email: email,
                password: password
            })
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ User ${email} created successfully.`);
                    // Clear the form after successful creation
                    document.getElementById('new-user-first-name').value = '';
                    document.getElementById('new-user-last-name').value = '';
                    document.getElementById('new-user-email').value = '';
                    document.getElementById('new-user-password').value = '';
                } else {
                    // Handle different error types with specific messages
                    if (data.error_type === 'domain_limit') {
                        logResult(`üö´ DOMAIN LIMIT REACHED: ${data.error}`);
                        logResult(`üí° Solution: Upgrade to a paid Google Workspace subscription`);
                        logResult(`üìä Current domain: ${email.split('@')[1]}`);
                    } else if (data.error_type === 'auth_error') {
                        logResult(`üîê AUTHENTICATION ERROR: ${data.error}`);
                        logResult(`üí° Solution: Please re-authenticate your account`);
                    } else if (data.error_type === 'duplicate_user') {
                        logResult(`üë§ DUPLICATE USER: ${data.error}`);
                        logResult(`üí° Solution: Use a different email address`);
                    } else if (data.error_type === 'invalid_domain') {
                        logResult(`üåê INVALID DOMAIN: ${data.error}`);
                        logResult(`üí° Solution: Check the domain name and try again`);
                    } else {
                        logResult(`‚ùå Failed to create user ${email}: ${data.error}`);
                    }

                    // Show raw error for debugging if available
                    if (data.raw_error) {
                        logResult(`üîç Technical details: ${data.raw_error}`);
                    }
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error.message}`);
                logResult(`üí° Solution: Check your internet connection and try again`);
            });
    }

    // Async Account Search Logic
    let searchTimeout;

    function debounceSearchAccounts(query) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            searchAccounts(query);
        }, 300);
    }

    function searchAccounts(query) {
        const listArea = document.getElementById('account-list-area');

        if (!query) {
            listArea.innerHTML = `
                <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                    <i class="fas fa-search"></i> Use search to find accounts
                </div>`;
            return;
        }

        listArea.innerHTML = `
            <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                <i class="fas fa-spinner fa-spin"></i> Searching...
            </div>`;

        fetch(`/api/search-accounts?q=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    renderAccountList(data.accounts);
                } else {
                    listArea.innerHTML = `<div style="padding: 10px; color: #dc3545;">Error searching accounts</div>`;
                }
            })
            .catch(err => {
                console.error(err);
                listArea.innerHTML = `<div style="padding: 10px; color: #dc3545;">Network error</div>`;
            });
    }

    function renderAccountList(accounts) {
        const listArea = document.getElementById('account-list-area');
        const selectDropdown = document.getElementById('account-select');

        if (accounts.length === 0) {
            listArea.innerHTML = `
                <div style="text-align: center; padding: 20px; color: var(--text-muted);">
                    No accounts found
                </div>`;
            // Clear dropdown except placeholder
            selectDropdown.innerHTML = '<option value="">No accounts found</option>';
            return;
        }

        // Populate list area
        listArea.innerHTML = '';
        accounts.forEach(account => {
            const item = document.createElement('div');
            item.className = 'account-item';
            item.dataset.accountName = account.account_name;
            item.dataset.accountId = account.id;
            item.textContent = account.account_name;
            item.onclick = () => selectAccountFromList(account.account_name, account.id);
            listArea.appendChild(item);
        });

        // Populate dropdown select
        selectDropdown.innerHTML = '<option value="">Choose an account...</option>';
        accounts.forEach(account => {
            const option = document.createElement('option');
            option.value = account.account_name;
            option.dataset.accountId = account.id;
            option.textContent = account.account_name;
            selectDropdown.appendChild(option);
        });
    }

    // Initialize with empty state or recent accounts
    searchAccounts('');

    // Optimized Bulk Parsing
    let bulkAccountRowCounter = 0;

    function openBulkAccountModal() {
        document.getElementById('bulk-account-modal').style.display = 'block';
        document.getElementById('bulk-accounts-tbody').innerHTML = '';
        const pasteField = document.getElementById('bulk-accounts-paste');
        if (pasteField) pasteField.value = '';
        document.getElementById('bulk-account-progress').style.display = 'none';
        const resultsSection = document.getElementById('bulk-account-results');
        if (resultsSection) resultsSection.style.display = 'none';
        bulkAccountRowCounter = 0;
        addBulkAccountRow();
    }

    function parseBulkAccountsPaste() {
        const pasteText = document.getElementById('bulk-accounts-paste').value.trim();

        if (!pasteText) {
            alert('Please paste account data first.');
            return;
        }

        const lines = pasteText.split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);

        if (lines.length === 0) {
            alert('No valid lines found in pasted data.');
            return;
        }

        // Clear existing rows
        const tbody = document.getElementById('bulk-accounts-tbody');
        tbody.innerHTML = '';
        bulkAccountRowCounter = 0;

        let parsedCount = 0;
        let errorCount = 0;
        const errors = [];

        // Disable button during processing
        const parseBtn = document.querySelector('button[onclick="parseBulkAccountsPaste()"]');
        if (parseBtn) {
            parseBtn.disabled = true;
            parseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Parsing...';
        }

        const BATCH_SIZE = 10;
        let currentIndex = 0;

        function processBatch() {
            const endIndex = Math.min(currentIndex + BATCH_SIZE, lines.length);

            for (let i = currentIndex; i < endIndex; i++) {
                const line = lines[i];
                const index = i;

                // Split by comma
                const parts = line.split(',').map(p => p.trim()).filter(p => p);

                if (parts.length < 2) {
                    errors.push(`Line ${index + 1}: Invalid format (need at least account,password)`);
                    errorCount++;
                    continue;
                }

                let account = '';
                let domain = '';
                let password = '';

                if (parts.length === 2) {
                    // Format: account,password
                    account = parts[0];
                    password = parts[1];
                    domain = ''; // Will use default domain
                } else if (parts.length === 3) {
                    // Format: account,domain,password
                    account = parts[0];
                    domain = parts[1];
                    password = parts[2];
                } else {
                    errors.push(`Line ${index + 1}: Too many fields (expected 2 or 3, got ${parts.length})`);
                    errorCount++;
                    continue;
                }

                // Validate account email
                if (!account.includes('@')) {
                    errors.push(`Line ${index + 1}: Invalid account email: ${account}`);
                    errorCount++;
                    continue;
                }

                // Validate password
                if (!password || password.length < 1) {
                    errors.push(`Line ${index + 1}: Password is required`);
                    errorCount++;
                    continue;
                }

                // Add row via existing function
                addBulkAccountRow(account, 50, domain, password);
                parsedCount++;
            }

            currentIndex += BATCH_SIZE;

            if (currentIndex < lines.length) {
                // Schedule next batch
                // Update button text to show progress
                if (parseBtn) parseBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Parsing... (${Math.round((currentIndex / lines.length) * 100)}%)`;
                requestAnimationFrame(() => setTimeout(processBatch, 0));
            } else {
                // Finished
                if (parseBtn) {
                    parseBtn.disabled = false;
                    parseBtn.innerHTML = '<i class="fas fa-magic"></i> Parse & Fill Table';
                }

                // Show results
                if (errorCount > 0) {
                    alert(`Parsed ${parsedCount} account(s) successfully.\n\nErrors (${errorCount}):\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? '\n...' : ''}`);
                } else {
                    // alert(`‚úÖ Successfully parsed and added ${parsedCount} account(s) to the table!`);
                    // Use a toast or log instead of alert to be less intrusive for large batches
                    console.log(`Successfully parsed and added ${parsedCount} account(s).`);
                }

                // Clear paste field
                document.getElementById('bulk-accounts-paste').value = '';
            }
        }

        // Start processing
        processBatch();
    }

    function closeBulkAccountModal() {
        document.getElementById('bulk-account-modal').style.display = 'none';
    }

    function populateAllDomains() {
        const tbody = document.getElementById('bulk-accounts-tbody');
        const rows = tbody.querySelectorAll('tr');

        if (rows.length === 0) {
            alert('No accounts in the list to populate domains for.');
            return;
        }

        let count = 0;
        rows.forEach(row => {
            const rowId = row.id;
            // Check if there is an account email entered
            const accountInput = row.querySelector('input[data-field="account"]');
            if (accountInput && accountInput.value.trim()) {
                // Add a small staggered delay to avoid overwhelming the server/API if there are many rows
                setTimeout(() => {
                    loadDomainsForAccount(rowId);
                }, count * 300); // 300ms delay between each call
                count++;
            }
        });

        if (count === 0) {
            alert('Please enter account emails first.');
        } else {
            // Optional: Show a toast or small notification that the process started
            console.log(`Started loading domains for ${count} accounts...`);
        }
    }

    function addBulkAccountRow(accountEmail = '', users = 50, domain = '', password = '') {
        const tbody = document.getElementById('bulk-accounts-tbody');
        const rowId = `bulk-account-row-${bulkAccountRowCounter++}`;

        const row = document.createElement('tr');
        row.id = rowId;
        // Removed hardcoded white styles to allow glass theme

        row.innerHTML = `
        <td style="padding: 12px; vertical-align: middle;">
            <input type="email" class="form-control-github" style="width: 100%; margin: 0; padding: 8px;" 
                   placeholder="account@domain.com" value="${accountEmail}" 
                   data-field="account">
        </td>
        <td style="padding: 12px; vertical-align: middle;">
            <input type="number" class="form-control-github" style="width: 100%; margin: 0; padding: 8px;" 
                   min="1" max="1000" placeholder="50" value="${users}" 
                   data-field="users">
        </td>
        <td style="padding: 12px; vertical-align: middle; position: relative;">
            <div style="position: relative;">
                <input type="text" class="form-control-github domain-combobox" 
                       style="width: 100%; margin: 0; padding: 8px; padding-right: 60px;" 
                       placeholder="example.com" value="${domain}" 
                       data-field="domain" 
                       data-row-id="${rowId}"
                       id="domain-input-${rowId}"
                       autocomplete="off"
                       onfocus="showDomainDropdown('${rowId}')"
                       onblur="setTimeout(() => hideDomainDropdown('${rowId}'), 200)">
                <div id="domain-status-${rowId}" style="position: absolute; right: 35px; top: 50%; transform: translateY(-50%); font-size: 10px; padding: 2px 6px; border-radius: 3px; font-weight: 600; display: none;"></div>
                <button type="button" 
                        onclick="loadDomainsForAccount('${rowId}')" 
                        class="btn-github" 
                        style="position: absolute; right: 4px; top: 50%; transform: translateY(-50%); padding: 4px 8px; font-size: 11px; background-color: #0969da; color: white; border: none; cursor: pointer; border-radius: 4px;"
                        title="Load domains from account">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <div id="domain-dropdown-${rowId}" 
                     style="position: absolute; top: 100%; left: 0; right: 0; background: var(--bg-modal); border: 1px solid var(--border-panel); border-radius: 6px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.5); margin-top: 2px;">
                    <!-- Domains will be populated here -->
                </div>
            </div>
        </td>
        <td style="padding: 12px; vertical-align: middle;">
            <input type="text" class="form-control-github" style="width: 100%; margin: 0; padding: 8px;" 
                   placeholder="Password" value="${password}" 
                   data-field="password">
        </td>
        <td style="padding: 12px; text-align: center; vertical-align: middle;">
            <button onclick="removeBulkAccountRow('${rowId}')" class="btn-github" 
                    style="background-color: #da3633; color: white; border-color: #da3633; padding: 6px 12px; cursor: pointer;">
                <i class="fas fa-trash"></i>
            </button>
        </td>
    `;

        tbody.appendChild(row);

        // Add hover effect
        row.addEventListener('mouseenter', function () {
            this.style.backgroundColor = '#f6f8fa';
        });
        row.addEventListener('mouseleave', function () {
            this.style.backgroundColor = '#ffffff';
        });

        // Add event listener to account email field to auto-load domains when account is entered
        const accountInput = row.querySelector('input[data-field="account"]');
        const domainInput = row.querySelector('input[data-field="domain"]');

        // Debounce function to avoid too many API calls
        let domainLoadTimeout;
        accountInput.addEventListener('blur', function () {
            const accountEmail = this.value.trim();
            if (accountEmail && accountEmail.includes('@')) {
                // Clear previous timeout
                clearTimeout(domainLoadTimeout);
                // Wait 500ms after user stops typing before loading domains
                domainLoadTimeout = setTimeout(() => {
                    loadDomainsForAccount(rowId);
                }, 500);
            }
        });

        // Also trigger on Enter key
        accountInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                const accountEmail = this.value.trim();
                if (accountEmail && accountEmail.includes('@')) {
                    clearTimeout(domainLoadTimeout);
                    loadDomainsForAccount(rowId);
                }
            }
        });
    }

    function removeBulkAccountRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) {
            row.remove();
        }
    }

    // Load domains for a specific account in a table row
    function loadDomainsForAccount(rowId) {
        const row = document.getElementById(rowId);
        if (!row) {
            console.error('Row not found:', rowId);
            return;
        }

        const accountInput = row.querySelector('input[data-field="account"]');
        const domainInput = row.querySelector('input[data-field="domain"]');
        const domainDropdown = row.querySelector(`#domain-dropdown-${rowId}`);
        const loadButton = row.querySelector('button[onclick*="loadDomainsForAccount"]');

        if (!accountInput || !domainInput || !domainDropdown) {
            console.error('Required elements not found in row:', rowId);
            return;
        }

        const accountEmail = accountInput.value.trim();

        if (!accountEmail || !accountEmail.includes('@')) {
            alert('Please enter a valid account email first.');
            return;
        }

        // Show loading state
        if (loadButton) {
            const icon = loadButton.querySelector('i');
            if (icon) {
                icon.className = 'fas fa-spinner fa-spin';
            }
            loadButton.disabled = true;
        }

        // Clear existing options
        domainDropdown.innerHTML = '';

        // Fetch domains from API
        fetch('/api/retrieve-domains-for-account', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                account_email: accountEmail
            })
        })
            .then(response => response.json())
            .then(data => {
                // Reset button state
                if (loadButton) {
                    const icon = loadButton.querySelector('i');
                    if (icon) {
                        icon.className = 'fas fa-sync-alt';
                    }
                    loadButton.disabled = false;
                }

                if (data.success && data.domains && data.domains.length > 0) {
                    // Populate custom dropdown with domains and status
                    const domainDropdown = row.querySelector(`#domain-dropdown-${rowId}`);
                    domainDropdown.innerHTML = '';

                    data.domains.forEach(domainData => {
                        const domainName = domainData.domain_name || domainData;
                        const status = domainData.status || 'available';
                        const statusText = domainData.status_text || 'AVAILABLE';
                        const statusColor = domainData.status_color || 'green';

                        // Map status colors
                        let colorCode = '#28a745'; // green (available)
                        if (statusColor === 'purple' || status === 'in_use') {
                            colorCode = '#6f42c1'; // purple (in use)
                        } else if (statusColor === 'red' || status === 'used') {
                            colorCode = '#dc3545'; // red (used)
                        }

                        const domainItem = document.createElement('div');
                        domainItem.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between;';
                        domainItem.style.borderBottom = '1px solid #f0f0f0';
                        domainItem.onmouseenter = function () { this.style.backgroundColor = '#f6f8fa'; };
                        domainItem.onmouseleave = function () { this.style.backgroundColor = 'white'; };
                        domainItem.onclick = function () {
                            domainInput.value = domainName;
                            updateDomainStatus(rowId, status, statusText, colorCode);
                            hideDomainDropdown(rowId);
                        };

                        const domainNameSpan = document.createElement('span');
                        domainNameSpan.textContent = domainName;
                        domainNameSpan.style.fontWeight = '500';

                        const statusBadge = document.createElement('span');
                        statusBadge.textContent = statusText;
                        statusBadge.style.cssText = `font-size: 10px; padding: 2px 6px; border-radius: 3px; font-weight: 600; background-color: ${colorCode}; color: white;`;

                        domainItem.appendChild(domainNameSpan);
                        domainItem.appendChild(statusBadge);
                        domainDropdown.appendChild(domainItem);
                    });

                    // Store domains data for later use
                    row.dataset.domainsLoaded = 'true';

                    // Show success message
                    console.log(`Loaded ${data.domains.length} domain(s) for ${accountEmail}`);

                    // Update status if domain input already has a value
                    const currentDomain = domainInput.value.trim();
                    if (currentDomain) {
                        const matchingDomain = data.domains.find(d => (d.domain_name || d) === currentDomain);
                        if (matchingDomain) {
                            const status = matchingDomain.status || 'available';
                            const statusText = matchingDomain.status_text || 'AVAILABLE';
                            let colorCode = '#28a745';
                            if (matchingDomain.status_color === 'purple' || status === 'in_use') {
                                colorCode = '#6f42c1';
                            } else if (matchingDomain.status_color === 'red' || status === 'used') {
                                colorCode = '#dc3545';
                            }
                            updateDomainStatus(rowId, status, statusText, colorCode);
                        }
                    }
                } else {
                    const errorMsg = data.error || 'No domains found or failed to retrieve domains';
                    console.warn(`Failed to load domains for ${accountEmail}:`, errorMsg);
                    // Don't show alert - just log it, user can still type domain manually
                }
            })
            .catch(error => {
                // Reset button state
                if (loadButton) {
                    const icon = loadButton.querySelector('i');
                    if (icon) {
                        icon.className = 'fas fa-sync-alt';
                    }
                    loadButton.disabled = false;
                }

                console.error('Error loading domains:', error);
                // Don't show alert - user can still type domain manually
            });
    }

    // Show domain dropdown
    function showDomainDropdown(rowId) {
        const dropdown = document.getElementById(`domain-dropdown-${rowId}`);
        if (dropdown && dropdown.children.length > 0) {
            dropdown.style.display = 'block';
        }
    }

    // Hide domain dropdown
    function hideDomainDropdown(rowId) {
        const dropdown = document.getElementById(`domain-dropdown-${rowId}`);
        if (dropdown) {
            dropdown.style.display = 'none';
        }
    }

    // Update domain status indicator
    function updateDomainStatus(rowId, status, statusText, colorCode) {
        const statusIndicator = document.getElementById(`domain-status-${rowId}`);
        if (statusIndicator) {
            statusIndicator.textContent = statusText;
            statusIndicator.style.backgroundColor = colorCode;
            statusIndicator.style.color = 'white';
            statusIndicator.style.display = 'block';
        }

        // Also update on input change
        const domainInput = document.getElementById(`domain-input-${rowId}`);
        if (domainInput) {
            domainInput.addEventListener('input', function () {
                // Clear status if user types manually
                if (statusIndicator) {
                    statusIndicator.style.display = 'none';
                }
            });
        }
    }

    function executeBulkAccountCreation() {
        const tbody = document.getElementById('bulk-accounts-tbody');
        const rows = tbody.querySelectorAll('tr');

        if (rows.length === 0) {
            alert('Please add at least one account.');
            return;
        }

        // Collect account data from table
        const accountsData = [];
        let hasErrors = false;
        const errors = [];

        rows.forEach((row, index) => {
            const accountInput = row.querySelector('input[data-field="account"]');
            const usersInput = row.querySelector('input[data-field="users"]');
            const domainInput = row.querySelector('input[data-field="domain"]');
            const passwordInput = row.querySelector('input[data-field="password"]');

            const account = accountInput.value.trim();
            const users = parseInt(usersInput.value);
            const domain = domainInput.value.trim();
            const password = passwordInput.value.trim();

            // Skip empty rows
            if (!account) {
                return;
            }

            // Validation
            if (!account.includes('@')) {
                errors.push(`Row ${index + 1}: Invalid account email`);
                hasErrors = true;
                return;
            }

            if (!users || users < 1 || users > 1000) {
                errors.push(`Row ${index + 1} (${account}): Invalid number of users (1-1000)`);
                hasErrors = true;
                return;
            }

            // Domain is optional - will use default domain if empty

            if (!password || password.length < 8) {
                errors.push(`Row ${index + 1} (${account}): Password must be at least 8 characters`);
                hasErrors = true;
                return;
            }

            accountsData.push({
                account: account,
                users_per_account: users,
                domain: domain || '', // Empty domain will use default
                password: password
            });
        });

        if (hasErrors) {
            alert('Please fix the following errors:\n\n' + errors.join('\n'));
            return;
        }

        if (accountsData.length === 0) {
            alert('Please add at least one valid account with all fields filled.');
            return;
        }

        // Show progress
        document.getElementById('bulk-account-progress').style.display = 'block';
        document.getElementById('bulk-account-progress-bar').style.width = '0%';
        document.getElementById('bulk-account-progress-text').textContent = `Starting bulk creation for ${accountsData.length} account(s)...`;

        // Disable button
        const btn = event.target;
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

        // Call API
        fetch('/api/bulk-create-account-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                accounts_data: accountsData
            })
        })
            .then(response => {
                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    return response.text().then(text => {
                        console.error('Non-JSON response:', text.substring(0, 500));
                        // Don't throw error if process is still running - just log it
                        console.warn('Received non-JSON response, but process may still be running');
                        // Return a placeholder response to continue
                        return { success: true, message: 'Process is running, please check results' };
                    });
                }
                return response.json();
            })
            .then(data => {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-play"></i> Start Bulk Creation';

                if (data.success) {
                    // Update progress
                    document.getElementById('bulk-account-progress-bar').style.width = '100%';
                    document.getElementById('bulk-account-progress-text').textContent = '‚úÖ Bulk creation completed!';

                    // Display results
                    displayBulkAccountResults(data);

                    // Keep modal open to show results - don't auto-close
                } else {
                    document.getElementById('bulk-account-progress-text').textContent = `‚ùå Error: ${data.error}`;
                    alert(`Error: ${data.error}`);
                }
            })
            .catch(error => {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-play"></i> Start Bulk Creation';
                document.getElementById('bulk-account-progress-text').textContent = `‚ùå Network error: ${error.message}`;
                alert(`Network error: ${error.message}`);
            });
    }

    function displayBulkAccountResults(data) {
        const resultsSection = document.getElementById('bulk-account-results');
        const resultsTextarea = document.getElementById('bulk-account-results-text');
        const summaryDiv = document.getElementById('bulk-account-summary');

        // Store processed accounts with their passwords for later retrieval (persist in localStorage)
        const accountsToStore = [];
        const accountPasswords = {}; // Store account -> password mapping

        if (data.results) {
            data.results.forEach(accountResult => {
                if (accountResult.account && accountResult.authenticated) {
                    accountsToStore.push(accountResult.account);
                    // Get password from first successful user in the account (all users have same password)
                    if (accountResult.users && accountResult.users.length > 0) {
                        // Try to find a successful user with password
                        const firstUser = accountResult.users.find(u => u.success && u.password);
                        if (firstUser && firstUser.password) {
                            accountPasswords[accountResult.account] = firstUser.password;
                            console.log(`[BULK] Stored password for account ${accountResult.account}: ${firstUser.password.substring(0, 5)}...`);
                        } else {
                            // If no password in user object, try to get it from the account data
                            // Check if password was passed in the original request
                            console.warn(`[BULK] No password found for account ${accountResult.account} in user results`);
                        }
                    }
                }
            });
        }

        // Also get passwords from the table if they exist (for immediate retrieval)
        const tbody = document.getElementById('bulk-accounts-tbody');
        if (tbody) {
            const rows = tbody.querySelectorAll('tr');
            rows.forEach((row) => {
                const accountInput = row.querySelector('input[data-field="account"]');
                const passwordInput = row.querySelector('input[data-field="password"]');
                if (accountInput && passwordInput) {
                    const account = accountInput.value.trim();
                    const password = passwordInput.value.trim();
                    if (account && password && account.includes('@')) {
                        accountPasswords[account] = password;
                        console.log(`[BULK] Stored password from table for account ${account}: ${password.substring(0, 5)}...`);
                    }
                }
            });
        }

        setProcessedAccounts(accountsToStore); // Store in localStorage for persistence
        setAccountPasswords(accountPasswords); // Store account passwords mapping
        console.log(`[BULK] Stored ${Object.keys(accountPasswords).length} account password(s) in localStorage`);

        // Build user:password list from ALL accounts
        let userPasswordList = [];
        let totalCreated = 0;
        let totalFailed = 0;
        let accountDetails = [];

        if (data.results) {
            data.results.forEach(accountResult => {
                const accountName = accountResult.account || 'Unknown';
                let accountCreated = 0;
                let accountFailed = 0;

                if (accountResult.users) {
                    accountResult.users.forEach(user => {
                        if (user.success) {
                            // Ensure password is included - check multiple possible fields
                            const password = user.password || user.app_password || '';
                            if (password) {
                                userPasswordList.push(`${user.email}:${password}`);
                            } else {
                                // If no password in user object, try to get from account passwords
                                const accountPassword = accountPasswords[accountName];
                                if (accountPassword) {
                                    userPasswordList.push(`${user.email}:${accountPassword}`);
                                } else {
                                    userPasswordList.push(`${user.email}:`);
                                    console.warn(`[BULK] No password found for user ${user.email} from account ${accountName}`);
                                }
                            }
                            totalCreated++;
                            accountCreated++;
                        } else {
                            totalFailed++;
                            accountFailed++;
                        }
                    });
                }

                accountDetails.push({
                    account: accountName,
                    created: accountCreated,
                    failed: accountFailed,
                    authenticated: accountResult.authenticated || false,
                    error: accountResult.error || null
                });
            });
        }

        // Display all users in user:password format (one per line)
        resultsTextarea.value = userPasswordList.join('\n');

        // Display summary with account breakdown
        let summaryHTML = `
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 16px;">
            <div>
                <strong style="color: #0969da;">Total Accounts:</strong>
                <div style="font-size: 24px; font-weight: bold; color: #24292f;">${data.total_accounts || 0}</div>
            </div>
            <div>
                <strong style="color: #1a7f37;">Users Created:</strong>
                <div style="font-size: 24px; font-weight: bold; color: #1a7f37;">${totalCreated}</div>
            </div>
            <div>
                <strong style="color: #cf222e;">Failed:</strong>
                <div style="font-size: 24px; font-weight: bold; color: #cf222e;">${totalFailed}</div>
            </div>
        </div>
    `;

        // Add account-by-account breakdown
        if (accountDetails.length > 0) {
            summaryHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #d0d7de;">
                <strong style="color: #24292f; font-size: 14px;">Account Details:</strong>
                <div style="margin-top: 8px; max-height: 200px; overflow-y: auto;">
        `;

            accountDetails.forEach(detail => {
                const statusIcon = detail.authenticated ? '‚úÖ' : '‚ùå';
                const statusColor = detail.authenticated ? '#1a7f37' : '#cf222e';
                summaryHTML += `
                <div style="padding: 8px; margin-bottom: 4px; background-color: #f6f8fa; border-radius: 4px; font-size: 13px;">
                    <strong>${statusIcon} ${detail.account}:</strong>
                    <span style="color: ${statusColor}; margin-left: 8px;">
                        ${detail.created} created, ${detail.failed} failed
                    </span>
                    ${detail.error ? `<div style="color: #cf222e; font-size: 12px; margin-top: 4px;">Error: ${detail.error}</div>` : ''}
                </div>
            `;
            });

            summaryHTML += `
                </div>
            </div>
        `;
        }

        summaryDiv.innerHTML = summaryHTML;

        // Show results section
        resultsSection.style.display = 'block';

        // Scroll to results
        resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    // Store processed accounts for retrieval (persist in localStorage)
    let processedAccountsList = [];

    function getProcessedAccounts() {
        try {
            const stored = localStorage.getItem('bulk_processed_accounts');
            return stored ? JSON.parse(stored) : [];
        } catch (e) {
            return [];
        }
    }

    function setProcessedAccounts(accounts) {
        try {
            localStorage.setItem('bulk_processed_accounts', JSON.stringify(accounts));
            processedAccountsList = accounts;
        } catch (e) {
            console.error('Failed to store processed accounts:', e);
            processedAccountsList = accounts;
        }
    }

    function getAccountPasswords() {
        try {
            const stored = localStorage.getItem('bulk_account_passwords');
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            return {};
        }
    }

    function setAccountPasswords(passwords) {
        try {
            localStorage.setItem('bulk_account_passwords', JSON.stringify(passwords));
        } catch (e) {
            console.error('Failed to store account passwords:', e);
        }
    }

    function copyBulkAccountResults() {
        // Get processed accounts from localStorage (persistent storage)
        const accounts = getProcessedAccounts();

        // If there are processed accounts, retrieve users from them
        if (accounts && accounts.length > 0) {
            retrieveUsersFromProcessedAccounts(accounts);
            return;
        }

        // Otherwise, just copy what's in the textarea
        const textarea = document.getElementById('bulk-account-results-text');
        if (textarea && textarea.value && textarea.value.trim().length > 0) {
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices

            try {
                document.execCommand('copy');
                alert('‚úÖ Copied to clipboard!');
            } catch (err) {
                // Fallback for modern browsers
                navigator.clipboard.writeText(textarea.value).then(() => {
                    alert('‚úÖ Copied to clipboard!');
                }).catch(() => {
                    alert('‚ùå Failed to copy. Please select and copy manually.');
                });
            }
        } else {
            alert('No data to copy. Please run bulk creation first or click "Retrieve & Copy All Users" to fetch users from processed accounts.');
        }
    }

    function retrieveUsersFromTableAccounts(event) {
        console.log('retrieveUsersFromTableAccounts called');

        // Get accounts from the table rows in the modal
        const tbody = document.getElementById('bulk-accounts-tbody');
        if (!tbody) {
            alert('Table not found.');
            return;
        }

        const rows = tbody.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('Please add at least one account to the table.');
            return;
        }

        // Collect account emails from table
        const accounts = [];
        rows.forEach((row) => {
            const accountInput = row.querySelector('input[data-field="account"]');
            if (accountInput) {
                const account = accountInput.value.trim();
                if (account && account.includes('@')) {
                    accounts.push(account);
                }
            }
        });

        if (accounts.length === 0) {
            alert('Please add at least one valid account email to the table.');
            return;
        }

        // Disable button and show loading
        let btn = null;
        if (event && event.target) {
            btn = event.target.closest('button');
        }
        if (!btn) {
            const buttons = document.querySelectorAll('button[onclick*="retrieveUsersFromTableAccounts"]');
            btn = buttons[0];
        }

        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        }

        // Show loading in main results section (outside modal)
        const mainTextarea = document.getElementById('bulk-account-results-text');
        const mainSummary = document.getElementById('bulk-account-summary');
        const mainResultsSection = document.getElementById('bulk-account-results');

        if (mainResultsSection) {
            mainResultsSection.style.display = 'block';
        }
        if (mainTextarea) {
            mainTextarea.value = 'üîÑ Authenticating and retrieving users from ' + accounts.length + ' account(s)...\nPlease wait...';
        }
        if (mainSummary) {
            mainSummary.innerHTML = '<div style="padding: 12px; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading users from ' + accounts.length + ' account(s)...</div>';
        }

        // Call the retrieve function with these accounts
        retrieveUsersFromProcessedAccounts(accounts, btn);
    }

    function retrieveUsersFromProcessedAccounts(accounts = null, buttonElement = null) {
        // Get accounts from parameter or localStorage
        const accountsToRetrieve = accounts || getProcessedAccounts();

        if (!accountsToRetrieve || accountsToRetrieve.length === 0) {
            alert('No accounts found. Please add accounts to the table or run bulk creation first.');
            if (buttonElement) {
                buttonElement.disabled = false;
                buttonElement.innerHTML = '<i class="fas fa-sync-alt"></i> Auth + Retrieve Bulk Users';
            }
            return;
        }

        // Show loading state - prioritize main page results section (outside modal)
        const mainTextarea = document.getElementById('bulk-account-results-text');
        const mainSummary = document.getElementById('bulk-account-summary');
        const mainResultsSection = document.getElementById('bulk-account-results');

        if (mainTextarea) {
            mainTextarea.value = 'üîÑ Authenticating and retrieving users from ' + accountsToRetrieve.length + ' account(s)...\nPlease wait...';
        }
        if (mainSummary) {
            mainSummary.innerHTML = '<div style="padding: 12px; text-align: center;"><i class="fas fa-spinner fa-spin"></i> Loading users from ' + accountsToRetrieve.length + ' account(s)...</div>';
        }
        if (mainResultsSection) {
            mainResultsSection.style.display = 'block';
        }

        // Get account passwords from localStorage (stored during creation or from table)
        const accountPasswords = getAccountPasswords();
        console.log(`[BULK RETRIEVE] Retrieved ${Object.keys(accountPasswords).length} account password(s) from localStorage`);
        console.log(`[BULK RETRIEVE] Accounts to retrieve: ${accountsToRetrieve.join(', ')}`);
        console.log(`[BULK RETRIEVE] Passwords available for: ${Object.keys(accountPasswords).join(', ')}`);

        // Also check table for passwords if not in localStorage
        const tbody = document.getElementById('bulk-accounts-tbody');
        if (tbody) {
            const rows = tbody.querySelectorAll('tr');
            rows.forEach((row) => {
                const accountInput = row.querySelector('input[data-field="account"]');
                const passwordInput = row.querySelector('input[data-field="password"]');
                if (accountInput && passwordInput) {
                    const account = accountInput.value.trim();
                    const password = passwordInput.value.trim();
                    if (account && password && account.includes('@') && !accountPasswords[account]) {
                        accountPasswords[account] = password;
                        console.log(`[BULK RETRIEVE] Added password from table for ${account}`);
                    }
                }
            });
            // Update localStorage with any passwords found in table
            if (Object.keys(accountPasswords).length > 0) {
                setAccountPasswords(accountPasswords);
            }
        }

        // Call API to retrieve users from all processed accounts
        fetch('/api/bulk-retrieve-account-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                accounts: accountsToRetrieve,
                account_passwords: accountPasswords  // Send password mapping to backend
            })
        })
            .then(response => {
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    return response.text().then(text => {
                        console.error('Non-JSON response:', text);
                        throw new Error('Server returned non-JSON response');
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Build user:password list
                    let userPasswordList = [];
                    let totalUsers = 0;
                    let accountDetails = [];

                    if (data.results) {
                        data.results.forEach(accountResult => {
                            const accountName = accountResult.account || 'Unknown';
                            let accountUsers = 0;

                            if (accountResult.users) {
                                accountResult.users.forEach(user => {
                                    // Format: email:password (password might be empty if not available)
                                    const password = user.password || user.app_password || '';
                                    if (password) {
                                        userPasswordList.push(`${user.email}:${password}`);
                                    } else {
                                        userPasswordList.push(`${user.email}:`);
                                    }
                                    accountUsers++;
                                    totalUsers++;
                                });
                            }

                            accountDetails.push({
                                account: accountName,
                                users: accountUsers,
                                authenticated: accountResult.authenticated || false,
                                error: accountResult.error || null
                            });
                        });
                    }

                    // Display in main page textarea (outside modal)
                    const mainTextarea = document.getElementById('bulk-account-results-text');
                    const userListText = userPasswordList.join('\n');

                    if (mainTextarea) {
                        mainTextarea.value = userListText;
                    }

                    // Also update modal textarea if it exists
                    const modalTextarea = document.getElementById('bulk-account-results-text-modal');
                    if (modalTextarea) {
                        modalTextarea.value = userListText;
                    }

                    // Update summary - prioritize main page (outside modal)
                    const mainSummary = document.getElementById('bulk-account-summary');

                    let summaryHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 16px;">
                    <div>
                        <strong style="color: #0969da;">Total Accounts:</strong>
                        <div style="font-size: 24px; font-weight: bold; color: #24292f;">${data.total_accounts || 0}</div>
                    </div>
                    <div>
                        <strong style="color: #1a7f37;">Total Users:</strong>
                        <div style="font-size: 24px; font-weight: bold; color: #1a7f37;">${totalUsers}</div>
                    </div>
                    <div>
                        <strong style="color: #cf222e;">Failed:</strong>
                        <div style="font-size: 24px; font-weight: bold; color: #cf222e;">${data.total_failed || 0}</div>
                    </div>
                </div>
            `;

                    if (accountDetails.length > 0) {
                        summaryHTML += `
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #d0d7de;">
                        <strong style="color: #24292f; font-size: 14px;">Account Details:</strong>
                        <div style="margin-top: 8px; max-height: 200px; overflow-y: auto;">
                `;

                        accountDetails.forEach(detail => {
                            const statusIcon = detail.authenticated ? '‚úÖ' : '‚ùå';
                            const statusColor = detail.authenticated ? '#1a7f37' : '#cf222e';
                            summaryHTML += `
                        <div style="padding: 8px; margin-bottom: 4px; background-color: #f6f8fa; border-radius: 4px; font-size: 13px;">
                            <strong>${statusIcon} ${detail.account}:</strong>
                            <span style="color: ${statusColor}; margin-left: 8px;">
                                ${detail.users} user(s)
                            </span>
                            ${detail.error ? `<div style="color: #cf222e; font-size: 12px; margin-top: 4px;">Error: ${detail.error}</div>` : ''}
                        </div>
                    `;
                        });

                        summaryHTML += `
                        </div>
                    </div>
                `;
                    }

                    if (mainSummary) {
                        mainSummary.innerHTML = summaryHTML;
                    }

                    // Show main results section (outside modal)
                    if (mainResultsSection) {
                        mainResultsSection.style.display = 'block';
                        // Scroll to results section
                        setTimeout(() => {
                            mainResultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }, 100);
                    }

                    // Close modal automatically after retrieving
                    closeBulkAccountModal();

                    // Re-enable button if provided
                    if (buttonElement) {
                        buttonElement.disabled = false;
                        buttonElement.innerHTML = '<i class="fas fa-sync-alt"></i> Auth + Retrieve Bulk Users';
                    }

                    // Copy to clipboard - use main textarea
                    if (mainTextarea && mainTextarea.value) {
                        mainTextarea.select();
                        mainTextarea.setSelectionRange(0, 99999);
                        try {
                            document.execCommand('copy');
                            alert(`‚úÖ Retrieved ${totalUsers} user(s) from ${data.total_accounts} account(s) and copied to clipboard!`);
                        } catch (err) {
                            navigator.clipboard.writeText(mainTextarea.value).then(() => {
                                alert(`‚úÖ Retrieved ${totalUsers} user(s) from ${data.total_accounts} account(s) and copied to clipboard!`);
                            }).catch(() => {
                                alert(`‚úÖ Retrieved ${totalUsers} user(s) from ${data.total_accounts} account(s). Please copy manually.`);
                            });
                        }
                    }
                } else {
                    alert(`Error: ${data.error || 'Failed to retrieve users'}`);
                    const mainTextarea = document.getElementById('bulk-account-results-text');
                    if (mainTextarea) {
                        mainTextarea.value = `‚ùå Error: ${data.error || 'Failed to retrieve users'}`;
                    }

                    // Re-enable button if provided
                    if (buttonElement) {
                        buttonElement.disabled = false;
                        buttonElement.innerHTML = '<i class="fas fa-sync-alt"></i> Auth + Retrieve Bulk Users';
                    }
                }
            })
            .catch(error => {
                console.error('Retrieve users error:', error);
                alert(`Network error: ${error.message}`);
                const mainTextarea = document.getElementById('bulk-account-results-text');
                if (mainTextarea) {
                    mainTextarea.value = `‚ùå Network error: ${error.message}`;
                }

                // Re-enable button if provided
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = '<i class="fas fa-sync-alt"></i> Auth + Retrieve Bulk Users';
                }
            });
    }

    function executeBulkAccountDeletion(event) {
        console.log('executeBulkAccountDeletion called');

        const tbody = document.getElementById('bulk-accounts-tbody');
        if (!tbody) {
            alert('Error: Table body not found');
            return;
        }

        const rows = tbody.querySelectorAll('tr');

        if (rows.length === 0) {
            alert('Please add at least one account.');
            return;
        }

        // Collect account emails from table (only account email is required)
        const accounts = [];
        rows.forEach((row) => {
            const accountInput = row.querySelector('input[data-field="account"]');
            if (accountInput) {
                const account = accountInput.value.trim();
                if (account && account.includes('@')) {
                    accounts.push(account);
                }
            }
        });

        if (accounts.length === 0) {
            alert('Please add at least one valid account email.');
            return;
        }

        // Confirm deletion
        if (!confirm(`‚ö†Ô∏è WARNING: This will delete ALL users from ${accounts.length} account(s).\n\nThis action cannot be undone!\n\nAre you sure you want to continue?`)) {
            return;
        }

        // Show progress
        const progressDiv = document.getElementById('bulk-account-progress');
        const progressBar = document.getElementById('bulk-account-progress-bar');
        const progressText = document.getElementById('bulk-account-progress-text');

        if (progressDiv) progressDiv.style.display = 'block';
        if (progressBar) progressBar.style.width = '0%';
        if (progressText) progressText.textContent = `Authenticating and deleting users from ${accounts.length} account(s)...`;

        // Disable button - get button from event or find it
        let btn = null;
        if (event && event.target) {
            btn = event.target.closest('button');
        }
        if (!btn) {
            // Fallback: find the button by its onclick attribute
            const buttons = document.querySelectorAll('button[onclick*="executeBulkAccountDeletion"]');
            btn = buttons[0];
        }

        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        }

        // Call API
        fetch('/api/bulk-delete-account-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                accounts: accounts
            })
        })
            .then(response => {
                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    return response.text().then(text => {
                        console.error('Non-JSON response:', text);
                        throw new Error('Server returned non-JSON response. Please check server logs.');
                    });
                }
                return response.json();
            })
            .then(data => {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-trash"></i> Authenticate & Delete All Users';
                }

                if (data.success) {
                    const progressBar = document.getElementById('bulk-account-progress-bar');
                    const progressText = document.getElementById('bulk-account-progress-text');
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressText) progressText.textContent = `‚úÖ Deletion completed! ${data.total_deleted} users deleted from ${data.total_accounts} account(s)`;

                    // Display results
                    displayBulkAccountDeletionResults(data);
                } else {
                    const progressText = document.getElementById('bulk-account-progress-text');
                    if (progressText) progressText.textContent = `‚ùå Error: ${data.error}`;
                    alert(`Error: ${data.error}`);
                }
            })
            .catch(error => {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-trash"></i> Authenticate & Delete All Users';
                }
                const progressText = document.getElementById('bulk-account-progress-text');
                if (progressText) progressText.textContent = `‚ùå Network error: ${error.message}`;
                console.error('Delete error:', error);
                alert(`Network error: ${error.message}`);
            });
    }

    function displayBulkAccountDeletionResults(data) {
        const resultsSection = document.getElementById('bulk-account-results');
        const resultsTextarea = document.getElementById('bulk-account-results-text');
        const summaryDiv = document.getElementById('bulk-account-summary');

        if (!resultsSection || !summaryDiv) {
            console.error('Results section not found');
            return;
        }

        // Build summary
        let summaryHTML = `
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 16px;">
            <div>
                <strong style="color: #0969da;">Total Accounts:</strong>
                <div style="font-size: 24px; font-weight: bold; color: #24292f;">${data.total_accounts || 0}</div>
            </div>
            <div>
                <strong style="color: #1a7f37;">Users Deleted:</strong>
                <div style="font-size: 24px; font-weight: bold; color: #1a7f37;">${data.total_deleted || 0}</div>
            </div>
            <div>
                <strong style="color: #cf222e;">Failed:</strong>
                <div style="font-size: 24px; font-weight: bold; color: #cf222e;">${data.total_failed || 0}</div>
            </div>
        </div>
    `;

        // Add account-by-account breakdown
        if (data.results && data.results.length > 0) {
            summaryHTML += `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #d0d7de;">
                <strong style="color: #24292f; font-size: 14px;">Account Details:</strong>
                <div style="margin-top: 8px; max-height: 200px; overflow-y: auto;">
        `;

            data.results.forEach(result => {
                const statusIcon = result.authenticated ? '‚úÖ' : '‚ùå';
                const statusColor = result.authenticated ? '#1a7f37' : '#cf222e';
                summaryHTML += `
                <div style="padding: 8px; margin-bottom: 4px; background-color: #f6f8fa; border-radius: 4px; font-size: 13px;">
                    <strong>${statusIcon} ${result.account}:</strong>
                    <span style="color: ${statusColor}; margin-left: 8px;">
                        ${result.deleted_count || 0} deleted, ${result.failed_count || 0} failed
                    </span>
                    ${result.error ? `<div style="color: #cf222e; font-size: 12px; margin-top: 4px;">Error: ${result.error}</div>` : ''}
                </div>
            `;
            });

            summaryHTML += `
                </div>
            </div>
        `;
        }

        summaryDiv.innerHTML = summaryHTML;

        // Show results section
        resultsSection.style.display = 'block';
        resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    // Close modal when clicking outside
    window.onclick = function (event) {
        const modal = document.getElementById('bulk-account-modal');
        if (event.target == modal) {
            closeBulkAccountModal();
        }
    }

    function getDomainInfo() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult('üîç Retrieving domain info...');
        const display = document.getElementById('domain-info-display');
        display.innerHTML = '<p>Loading domains...</p>';

        fetch('/api/get-domain-info')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    let html = '';
                    if (data.domains.length > 0) {
                        data.domains.forEach(domain => {
                            html += `<div class="domain-item">
                        <span>${domain.domainName}</span>
                        <button class="delete-button" onclick="deleteDomain('${domain.domainName}')">Delete</button>
                    </div>`;
                        });
                    } else {
                        html = '<p>No domains found.</p>';
                    }
                    display.innerHTML = html;
                    logResult(`‚úÖ Domain info retrieved successfully.`);
                } else {
                    display.innerHTML = `<p style="color: red;">Error: ${data.error}</p>`;
                    logResult(`‚ùå Failed to retrieve domain info: ${data.error}`);
                }
            })
            .catch(error => {
                display.innerHTML = `<p style="color: red;">Network error: ${error}</p>`;
                logResult(`‚ùå Network error: ${error}`);
            });
    }

    function addDomainAlias() {
        const domainAlias = document.getElementById('new-domain-alias').value;

        if (!domainAlias) {
            alert('Please enter a domain alias.');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult(`‚ûï Adding domain alias: ${domainAlias}...`);

        fetch('/api/add-domain-alias', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain_alias: domainAlias })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ Domain alias ${domainAlias} added successfully.`);
                    getDomainInfo(); // Refresh the domain list
                } else {
                    logResult(`‚ùå Failed to add domain alias ${domainAlias}: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error}`);
            });
    }

    function deleteDomain(domainName) {
        if (!confirm(`Are you sure you want to delete the domain: ${domainName}?`)) {
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logResult(`‚ùå Deleting domain: ${domainName}...`);

        fetch('/api/delete-domain', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain_name: domainName })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logResult(`‚úÖ Domain ${domainName} deleted successfully.`);
                    getDomainInfo(); // Refresh the domain list
                } else {
                    logResult(`‚ùå Failed to delete domain ${domainName}: ${data.error}`);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error}`);
            });
    }

    // Bulk Subdomain Deletion Functions
    function executeBulkSubdomainDeletion() {
        const subdomainsText = document.getElementById('bulk-subdomains-list').value.trim();

        if (!subdomainsText) {
            alert('Please enter subdomains to delete');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        const subdomains = subdomainsText.split('\n').map(s => s.trim()).filter(s => s);

        if (subdomains.length === 0) {
            alert('No valid subdomains found');
            return;
        }

        if (!confirm(`Are you sure you want to delete ${subdomains.length} subdomains? This action cannot be undone.`)) {
            return;
        }

        logResult(`üóëÔ∏è Starting bulk deletion of ${subdomains.length} subdomains...`);

        // Show progress container
        const progressContainer = document.getElementById('bulk-subdomain-progress');
        const progressBar = document.getElementById('bulk-subdomain-progress-bar');
        const progressText = document.getElementById('bulk-subdomain-progress-text');
        const resultsContainer = document.getElementById('bulk-subdomain-results');
        const resultsContent = document.getElementById('bulk-subdomain-results-content');

        progressContainer.style.display = 'block';
        resultsContainer.style.display = 'block';
        resultsContent.innerHTML = '';

        let completed = 0;
        let successful = 0;
        let failed = 0;
        const results = [];

        // Process each subdomain
        subdomains.forEach((subdomain, index) => {
            setTimeout(() => {
                logResult(`üîÑ Processing subdomain ${index + 1}/${subdomains.length}: ${subdomain}`);

                fetch('/api/delete-domain', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ domain_name: subdomain })
                })
                    .then(response => response.json())
                    .then(data => {
                        completed++;

                        if (data.success) {
                            successful++;
                            results.push(`‚úÖ ${subdomain} - Deleted successfully`);
                            logResult(`‚úÖ Subdomain ${subdomain} deleted successfully`);
                        } else {
                            failed++;
                            results.push(`‚ùå ${subdomain} - Failed: ${data.error}`);
                            logResult(`‚ùå Failed to delete subdomain ${subdomain}: ${data.error}`);
                        }

                        // Update progress
                        const progress = (completed / subdomains.length) * 100;
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `Processing... ${completed}/${subdomains.length} (${successful} successful, ${failed} failed)`;

                        // Update results display
                        resultsContent.innerHTML = results.join('<br>');

                        // Check if all subdomains are processed
                        if (completed === subdomains.length) {
                            progressText.textContent = `Completed! ${successful} successful, ${failed} failed`;
                            logResult(`üèÅ Bulk subdomain deletion completed: ${successful} successful, ${failed} failed`);

                            // Refresh domain list
                            getDomainInfo();
                        }
                    })
                    .catch(error => {
                        completed++;
                        failed++;
                        results.push(`‚ùå ${subdomain} - Network error: ${error.message}`);
                        logResult(`‚ùå Network error for subdomain ${subdomain}: ${error.message}`);

                        // Update progress
                        const progress = (completed / subdomains.length) * 100;
                        progressBar.style.width = `${progress}%`;
                        progressText.textContent = `Processing... ${completed}/${subdomains.length} (${successful} successful, ${failed} failed)`;

                        // Update results display
                        resultsContent.innerHTML = results.join('<br>');

                        // Check if all subdomains are processed
                        if (completed === subdomains.length) {
                            progressText.textContent = `Completed! ${successful} successful, ${failed} failed`;
                            logResult(`üèÅ Bulk subdomain deletion completed: ${successful} successful, ${failed} failed`);

                            // Refresh domain list
                            getDomainInfo();
                        }
                    });
            }, index * 1000); // Stagger requests by 1 second to avoid overwhelming the API
        });
    }

    function clearBulkSubdomainsList() {
        document.getElementById('bulk-subdomains-list').value = '';
        document.getElementById('bulk-subdomain-progress').style.display = 'none';
        document.getElementById('bulk-subdomain-results').style.display = 'none';
        logResult('üßπ Bulk subdomain deletion list cleared');
    }

    // OTP Generator Functions
    let currentOTPCode = null;

    function generateOTP() {
        let accountName = document.getElementById('otp-account-input').value.trim();
        const forceLower = document.getElementById('otp-lowercase-toggle')?.checked;
        if (forceLower && accountName) {
            accountName = accountName.toLowerCase();
        }

        if (!accountName) {
            alert('Please enter an account name');
            return;
        }

        // Show status
        const statusDiv = document.getElementById('otp-status');
        const statusText = document.getElementById('otp-status-text');
        const resultDiv = document.getElementById('otp-result');
        const copyBtn = document.getElementById('copy-otp-btn');

        statusDiv.style.display = 'block';
        statusText.textContent = 'Connecting to server...';
        statusText.style.color = '#0969da';
        resultDiv.style.display = 'none';
        copyBtn.disabled = true;

        fetch('/api/generate-otp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_name: accountName })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentOTPCode = data.otp_code;
                    statusText.textContent = `‚úÖ OTP generated successfully for ${data.account_name}`;
                    statusText.style.color = '#28a745';

                    // Show the OTP code
                    resultDiv.style.display = 'block';
                    document.getElementById('otp-code-display').textContent = data.otp_code;
                    copyBtn.disabled = false;

                    logResult(`üîë OTP generated for ${data.account_name}: ${data.otp_code}`);
                } else {
                    statusText.textContent = `‚ùå Error: ${data.error}`;
                    statusText.style.color = '#dc3545';
                    resultDiv.style.display = 'none';
                    copyBtn.disabled = true;
                    currentOTPCode = null;

                    logResult(`‚ùå OTP generation failed: ${data.error}`);
                }
            })
            .catch(error => {
                statusText.textContent = `‚ùå Network error: ${error.message}`;
                statusText.style.color = '#dc3545';
                resultDiv.style.display = 'none';
                copyBtn.disabled = true;
                currentOTPCode = null;

                logResult(`‚ùå OTP generation network error: ${error.message}`);
            });
    }

    function copyOTP() {
        if (currentOTPCode) {
            navigator.clipboard.writeText(currentOTPCode).then(() => {
                const statusText = document.getElementById('otp-status-text');
                const originalText = statusText.textContent;
                statusText.textContent = `üìã OTP '${currentOTPCode}' copied to clipboard!`;
                statusText.style.color = '#28a745';

                // Reset status after 3 seconds
                setTimeout(() => {
                    statusText.textContent = originalText;
                    statusText.style.color = '#0969da';
                }, 3000);

                logResult(`üìã OTP '${currentOTPCode}' copied to clipboard`);
            }).catch(err => {
                alert('Failed to copy to clipboard: ' + err);
                logResult(`‚ùå Failed to copy OTP to clipboard: ${err}`);
            });
        } else {
            alert('No OTP code available to copy');
        }
    }

    function retrieveAppPasswords() {
        const domain = document.getElementById('retrieve-domain').value.trim();

        if (!domain) {
            alert('Please enter a domain');
            return;
        }

        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Retrieving...';
        button.disabled = true;

        fetch('/api/retrieve-app-passwords', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain: domain })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const display = document.getElementById('app-passwords-display');
                    if (data.app_passwords.length > 0) {
                        display.value = data.app_passwords.join('\n');
                        logBulkDomain(`‚úÖ ${data.message}`);
                        logBulkDomain(`üîÑ Domain updated: All usernames now use ${domain}`);
                        logBulkDomain(`üìß SMTP format: user@domain,app_password,smtp.gmail.com,587`);
                        if (data.optimization) {
                            logBulkDomain(`‚ö° Optimization: ${data.optimization}`);
                        }
                    } else {
                        display.value = `No app passwords found for domain: ${domain}`;
                        logBulkDomain(`‚ÑπÔ∏è No app passwords found for domain ${domain}`);
                    }
                } else {
                    logBulkDomain(`‚ùå Retrieve failed: ${data.error}`);
                    alert(`‚ùå Retrieve failed: ${data.error}`);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert(`‚ùå Network error: ${error.message}`);
            })
            .finally(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    function copyAppPasswords() {
        const display = document.getElementById('app-passwords-display');

        if (!display.value.trim()) {
            alert('No app passwords to copy');
            return;
        }

        display.select();
        document.execCommand('copy');

        // Show feedback
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-check"></i> Copied!';
        button.style.backgroundColor = '#2da44e';

        setTimeout(() => {
            button.innerHTML = originalText;
            button.style.backgroundColor = '';
        }, 2000);

        logBulkDomain('üìã SMTP configuration copied to clipboard');
    }

    function clearAppPasswordsDisplay() {
        const display = document.getElementById('app-passwords-display');
        display.value = '';
        logBulkDomain('üßπ SMTP configuration display cleared');
    }

    function deleteAllAppPasswords() {
        // Double confirmation for admin-only permanent deletion
        const confirm1 = confirm('‚ö†Ô∏è ADMIN ONLY: This will PERMANENTLY DELETE ALL app passwords from the database!\n\nThis action cannot be undone!\n\nAre you sure you want to continue?');

        if (!confirm1) {
            return;
        }

        const confirm2 = confirm('üö® FINAL CONFIRMATION üö®\n\nYou are about to PERMANENTLY DELETE ALL app passwords!\n\nType "DELETE ALL" in the next prompt to confirm.');

        if (!confirm2) {
            return;
        }

        const finalConfirm = prompt('Type "DELETE ALL" to permanently delete all app passwords:');

        if (finalConfirm !== 'DELETE ALL') {
            alert('‚ùå Deletion cancelled. You must type "DELETE ALL" exactly.');
            return;
        }

        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting...';
        button.disabled = true;

        fetch('/api/delete-all-app-passwords', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Clear the display
                    document.getElementById('app-passwords-display').value = '';
                    logBulkDomain(`üóëÔ∏è ${data.message}`);
                    alert(`‚úÖ ${data.message}`);
                } else {
                    logBulkDomain(`‚ùå Delete failed: ${data.error}`);
                    alert(`‚ùå Delete failed: ${data.error}`);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert(`‚ùå Network error: ${error.message}`);
            })
            .finally(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }
    // Tab 3 Functions - Bulk Domain Change (Desktop App Style)


    function downloadAllUsersCSV() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logBulkDomain('üì• Starting download of all users to CSV...');

        fetch('/api/download-users-csv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.csv_data) {
                    // Create download
                    const blob = new Blob([data.csv_data], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `all_users_${new Date().toISOString().slice(0, 10)}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);

                    // Update path display
                    document.getElementById('csv-file-path').value = a.download;

                    logBulkDomain(`‚úÖ Downloaded ${data.user_count} users to CSV: ${a.download}`);
                } else {
                    logBulkDomain(`‚ùå Download failed: ${data.error}`);
                    alert('Download failed: ' + data.error);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert('Network error: ' + error);
            });
    }

    function retrieveAvailableDomains() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logBulkDomain('üîç Retrieving available domains...');

        // Show loading state
        const domainList = document.getElementById('available-domains');
        domainList.innerHTML = '<div class="domain-loading">Retrieving domains from Google API... (This may take a moment for large domain lists)</div>';

        // Batched retrieval to avoid timeouts with large domain lists
        const allDomains = [];
        let nextToken = null;
        let batches = 0;

        const fetchBatch = async () => {
            const payload = { mode: 'batched' };
            if (nextToken) payload.page_token = nextToken;

            const resp = await fetch('/api/retrieve-domains', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const text = await resp.text();
            let data;
            try { data = JSON.parse(text); } catch (e) { throw new Error('SERVER_HTML:' + text.slice(0, 200)); }

            if (!data.success) throw new Error(data.error || 'Unknown error');

            allDomains.push(...data.domains);
            nextToken = data.next_page_token || null;
            batches += 1;

            if (nextToken) {
                await new Promise(r => setTimeout(r, 200));
                return fetchBatch();
            }

            return allDomains;
        };

        fetchBatch().then(domains => {
            if (domains && domains.length > 0) {
                // First display domains with basic info (no user counts to avoid timeout)
                displayAvailableDomains(domains);
                logBulkDomain(`‚úÖ Retrieved ${domains.length} domains (calculating user counts...)`);

                // Then calculate user counts separately to avoid timeout
                calculateUserCounts(domains);
            } else {
                logBulkDomain(`‚ùå No domains found`);
                domainList.innerHTML = `<div class="domain-error">‚ùå No domains found</div>`;
            }
        })
            .catch(error => {
                if (error.message && error.message.startsWith('SERVER_HTML:')) {
                    const snippet = error.message.replace('SERVER_HTML:', '');
                    logBulkDomain(`‚ùå Server Error: HTML error page returned`);
                    domainList.innerHTML = `<div class="domain-error">‚ùå Server Error: HTML error page returned<pre style="white-space: pre-wrap; max-height: 160px; overflow:auto; background:#fff; padding:8px; border:1px solid #eee;">${snippet}</pre></div>`;
                } else {
                    logBulkDomain(`‚ùå Network error: ${error}`);
                    domainList.innerHTML = `<div class="domain-error">‚ùå Network error: ${error}</div>`;
                }
            });
    }

    function getDomainUsageStats() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        logBulkDomain('üìä Retrieving domain usage statistics for current account...');

        // Show loading state
        const domainList = document.getElementById('available-domains');
        domainList.innerHTML = '<div class="domain-loading">Retrieving domain usage statistics for current account...</div>';

        // First get fresh domain data from the authenticated account
        fetch('/api/retrieve-domains', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.domains) {
                    // Display the domain data with new three-state system
                    const inUseDomains = data.domains.filter(d => d.status === 'in_use').length;
                    const usedDomains = data.domains.filter(d => d.status === 'used').length;
                    const availableDomains = data.domains.filter(d => d.status === 'available').length;

                    displayDomainUsageStats({
                        total_domains: data.domains.length,
                        in_use_domains: inUseDomains,
                        used_domains: usedDomains,
                        available_domains: availableDomains,
                        total_users: data.domains.reduce((sum, d) => sum + (d.user_count || 0), 0),
                        domains: data.domains.map(d => ({
                            domain_name: d.domain_name,
                            user_count: d.user_count || 0,
                            is_verified: d.verified || false,
                            is_used: d.is_used || false,
                            status: d.status || 'available',
                            status_text: d.status_text || 'AVAILABLE',
                            status_color: d.status_color || 'green',
                            ever_used: d.ever_used || false,
                            last_updated: new Date().toISOString()
                        }))
                    });
                    logBulkDomain(`‚úÖ Retrieved domain usage statistics for current account`);
                } else {
                    logBulkDomain(`‚ùå Failed to retrieve domain stats: ${data.error}`);
                    domainList.innerHTML = `<div class="domain-error">‚ùå Failed to retrieve domain stats: ${data.error}</div>`;
                    alert('Failed to retrieve domain stats: ' + data.error);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                domainList.innerHTML = `<div class="domain-error">‚ùå Network error: ${error}</div>`;
                alert('Network error: ' + error);
            });
    }



    function calculateUserCounts(domains) {
        // Calculate user counts for domains separately to avoid timeout
        if (!domains || domains.length === 0) return;

        // Extract domain names
        const domainNames = domains.map(d => d.domain_name || d.domainName).filter(name => name);

        if (domainNames.length === 0) return;

        logBulkDomain(`üîç Calculating user counts for ${domainNames.length} domains...`);

        // Show loading indicator
        const domainList = document.getElementById('available-domains');
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'user-count-loading';
        loadingDiv.innerHTML = '<div style="background: #f0f8ff; padding: 10px; margin: 10px 0; border-radius: 5px; text-align: center;"><span style="color: #0066cc;">üîÑ Calculating user counts...</span></div>';
        domainList.appendChild(loadingDiv);

        // Call the separate user count calculation API
        fetch('/api/calculate-domain-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domains: domainNames })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.domain_user_counts) {
                    // Update domains with user counts
                    const updatedDomains = domains.map(domain => {
                        const domainName = domain.domain_name || domain.domainName;
                        const userCount = data.domain_user_counts[domainName] || 0;

                        // Update status based on user count
                        let status, status_text, status_color;
                        if (userCount > 0) {
                            status = 'in_use';
                            status_text = 'IN USE';
                            status_color = '#9C27B0';
                        } else if (domain.ever_used) {
                            status = 'used';
                            status_text = 'USED';
                            status_color = '#FF9800';
                        } else {
                            status = 'available';
                            status_text = 'AVAILABLE';
                            status_color = '#4CAF50';
                        }

                        return {
                            ...domain,
                            user_count: userCount,
                            status: status,
                            status_text: status_text,
                            status_color: status_color
                        };
                    });

                    // Remove loading indicator
                    const loadingDiv = document.getElementById('user-count-loading');
                    if (loadingDiv) loadingDiv.remove();

                    // Update display with user counts
                    displayAvailableDomains(updatedDomains);
                    logBulkDomain(`‚úÖ Updated ${updatedDomains.length} domains with user counts`);
                } else {
                    logBulkDomain(`‚ùå Failed to calculate user counts: ${data.error || 'Unknown error'}`);
                    const loadingDiv = document.getElementById('user-count-loading');
                    if (loadingDiv) {
                        loadingDiv.innerHTML = '<div style="background: #ffe6e6; padding: 10px; margin: 10px 0; border-radius: 5px; text-align: center;"><span style="color: #cc0000;">‚ùå Failed to calculate user counts</span></div>';
                    }
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Error calculating user counts: ${error}`);
                const loadingDiv = document.getElementById('user-count-loading');
                if (loadingDiv) {
                    loadingDiv.innerHTML = '<div style="background: #ffe6e6; padding: 10px; margin: 10px 0; border-radius: 5px; text-align: center;"><span style="color: #cc0000;">‚ùå Error calculating user counts</span></div>';
                }
            });
    }

    function clearOldDomainData() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        if (!confirm('‚ö†Ô∏è This will reset all "used" domains back to "available" status. Continue?')) {
            return;
        }

        logBulkDomain('üóëÔ∏è Resetting domain statuses from "used" to "available"...');

        fetch('/api/clear-old-domain-data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logBulkDomain(`‚úÖ ${data.message}`);
                    logBulkDomain(`üìä Reset ${data.reset_count} domains to available status`);
                    alert(`‚úÖ ${data.message}\nüìä Reset ${data.reset_count} domains to available status`);
                    // Refresh the display
                    setTimeout(() => {
                        getDomainUsageStats();
                        retrieveAvailableDomains(); // Also refresh the domain list
                    }, 500);
                } else {
                    logBulkDomain(`‚ùå Failed to reset domain statuses: ${data.error}`);
                    alert('Failed to reset domain statuses: ' + data.error);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert('Network error: ' + error);
            });
    }

    function debugDomainUsers() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        const currentDomain = document.getElementById('current-domain-suffix').value.trim();
        if (!currentDomain) {
            alert('Please enter a domain in the "Current Domain Suffix" field first');
            return;
        }

        logBulkDomain(`üêõ Debugging users for domain: ${currentDomain}`);

        fetch('/api/debug-domain-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain: currentDomain })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logBulkDomain(`üêõ Debug Results for ${data.domain}:`);
                    logBulkDomain(`   Total users found: ${data.total_users_found}`);
                    logBulkDomain(`   Users with domain ${data.domain}: ${data.domain_users_found}`);

                    if (data.domain_users && data.domain_users.length > 0) {
                        logBulkDomain(`   Domain users:`);
                        data.domain_users.forEach(user => {
                            logBulkDomain(`     - ${user.email} (Admin: ${user.isAdmin}, Suspended: ${user.suspended})`);
                        });
                    } else {
                        logBulkDomain(`   ‚ùå No users found with domain ${data.domain}`);
                    }
                } else {
                    logBulkDomain(`‚ùå Debug failed: ${data.error}`);
                    alert('Debug failed: ' + data.error);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert('Network error: ' + error);
            });
    }

    // Subdomain Status Management Functions
    function changeSubdomainStatus(status) {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        const subdomainInput = document.getElementById('subdomain-status-input');
        const subdomains = subdomainInput.value.trim();

        if (!subdomains) {
            alert('Please enter subdomains in the text area');
            return;
        }

        const subdomainList = subdomains.split('\n').filter(sub => sub.trim());
        if (subdomainList.length === 0) {
            alert('Please enter at least one valid subdomain');
            return;
        }

        const statusLabels = {
            'available': 'Available',
            'in_use': 'In Use',
            'used': 'Used'
        };

        if (!confirm(`Are you sure you want to set ${subdomainList.length} subdomains to "${statusLabels[status]}" status?`)) {
            return;
        }

        // Show progress
        const progressDiv = document.getElementById('subdomain-status-progress');
        const progressBar = document.getElementById('subdomain-status-progress-bar');
        const progressText = document.getElementById('subdomain-status-progress-text');
        const resultsDiv = document.getElementById('subdomain-status-results');
        const resultsContent = document.getElementById('subdomain-status-results-content');

        progressDiv.style.display = 'block';
        resultsDiv.style.display = 'none';
        progressBar.style.width = '0%';
        progressText.textContent = 'Processing...';

        let processedCount = 0;
        let successCount = 0;
        let errorCount = 0;
        const errors = [];

        // Process each subdomain
        const processNext = (index) => {
            if (index >= subdomainList.length) {
                // All done
                progressBar.style.width = '100%';
                progressText.textContent = 'Complete!';

                // Show results
                let resultHtml = `
                <div style="margin-bottom: 16px;">
                    <strong>Summary:</strong><br>
                    ‚úÖ Successfully updated: ${successCount}<br>
                    ‚ùå Failed: ${errorCount}<br>
                    üìä Total processed: ${processedCount}
                </div>
            `;

                if (errors.length > 0) {
                    resultHtml += `
                    <div style="margin-top: 16px;">
                        <strong>Errors:</strong><br>
                        ${errors.map(error => `‚Ä¢ ${error}`).join('<br>')}
                    </div>
                `;
                }

                resultsContent.innerHTML = resultHtml;
                resultsDiv.style.display = 'block';

                // Hide progress after 3 seconds
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                }, 3000);

                return;
            }

            const subdomain = subdomainList[index].trim();
            if (!subdomain) {
                processNext(index + 1);
                return;
            }

            // Update progress
            const progress = ((index + 1) / subdomainList.length) * 100;
            progressBar.style.width = progress + '%';
            progressText.textContent = `Processing ${index + 1}/${subdomainList.length}: ${subdomain}`;

            // Make API call
            fetch('/api/change-subdomain-status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    subdomain: subdomain,
                    status: status
                })
            })
                .then(response => response.json())
                .then(data => {
                    processedCount++;
                    if (data.success) {
                        successCount++;
                    } else {
                        errorCount++;
                        errors.push(`${subdomain}: ${data.error}`);
                    }

                    // Process next
                    setTimeout(() => processNext(index + 1), 100);
                })
                .catch(error => {
                    processedCount++;
                    errorCount++;
                    errors.push(`${subdomain}: Network error - ${error}`);

                    // Process next
                    setTimeout(() => processNext(index + 1), 100);
                });
        };

        // Start processing
        processNext(0);
    }

    function clearSubdomainStatusInput() {
        document.getElementById('subdomain-status-input').value = '';
        document.getElementById('subdomain-status-progress').style.display = 'none';
        document.getElementById('subdomain-status-results').style.display = 'none';
    }

    function displayDomainUsageStats(stats) {
        const domainList = document.getElementById('available-domains');

        let html = `
        <div class="stats-summary" style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 15px 0; color: #333;">üìä Domain Usage Summary</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                <div style="text-align: center; padding: 10px; background: white; border-radius: 5px;">
                    <div style="font-size: 24px; font-weight: bold; color: #2196F3;">${stats.total_domains}</div>
                    <div style="font-size: 12px; color: #666;">Total Domains</div>
                </div>
                <div style="text-align: center; padding: 10px; background: white; border-radius: 5px;">
                    <div style="font-size: 24px; font-weight: bold; color: #4CAF50;">${stats.available_domains || 0}</div>
                    <div style="font-size: 12px; color: #666;">Available</div>
                </div>
                <div style="text-align: center; padding: 10px; background: white; border-radius: 5px;">
                    <div style="font-size: 24px; font-weight: bold; color: #FF9800;">${stats.used_domains || 0}</div>
                    <div style="font-size: 12px; color: #666;">Used</div>
                </div>
                <div style="text-align: center; padding: 10px; background: white; border-radius: 5px;">
                    <div style="font-size: 24px; font-weight: bold; color: #9C27B0;">${stats.in_use_domains || 0}</div>
                    <div style="font-size: 12px; color: #666;">In Use</div>
                </div>
                <div style="text-align: center; padding: 10px; background: white; border-radius: 5px;">
                    <div style="font-size: 24px; font-weight: bold; color: #666;">${stats.total_users}</div>
                    <div style="font-size: 12px; color: #666;">Total Users</div>
                </div>
            </div>
        </div>
    `;

        if (stats.domains.length === 0) {
            html += '<p class="placeholder-text">No domains found in database</p>';
        } else {
            html += '<h4 style="margin: 20px 0 10px 0; color: #333;">Domain Details:</h4>';

            // Sort domains alphabetically by domain name
            const sortedDomains = [...stats.domains].sort((a, b) => {
                return a.domain_name.localeCompare(b.domain_name);
            });

            html += sortedDomains.map(domain => {
                // New three-state system
                let statusColor, statusText, domainClass, domainNameColor;

                if (domain.status === 'in_use') {
                    // Purple - currently has users
                    statusColor = '#9C27B0';
                    statusText = 'IN USE';
                    domainClass = 'domain-item in-use-domain';
                    domainNameColor = '#9C27B0';
                } else if (domain.status === 'used') {
                    // Orange - previously used but no current users
                    statusColor = '#FF9800';
                    statusText = 'USED';
                    domainClass = 'domain-item used-domain';
                    domainNameColor = '#FF9800';
                } else {
                    // Green - never been used (available)
                    statusColor = '#4CAF50';
                    statusText = 'AVAILABLE';
                    domainClass = 'domain-item';
                    domainNameColor = 'black';
                }

                return `<div class="${domainClass}">
                <strong style="color: ${domainNameColor};">${domain.domain_name}</strong>
                <span style="float: right; color: #666;">${domain.user_count} users</span>
                <div style="margin-top: 5px;">
                    ${domain.is_verified ? '<span style="color: green;">‚úÖ Verified</span>' : '<span style="color: red;">‚ùå Not Verified</span>'}
                    <span style="color: ${statusColor}; margin-left: 10px; font-weight: bold;">${statusText}</span>
                </div>
                ${domain.last_updated ? `<div style="font-size: 11px; color: #999; margin-top: 3px;">Last updated: ${new Date(domain.last_updated).toLocaleString()}</div>` : ''}
            </div>`;
            }).join('');
        }

        domainList.innerHTML = html;
    }

    function displayAvailableDomains(domains) {
        const domainList = document.getElementById('available-domains');

        if (domains.length === 0) {
            domainList.innerHTML = '<p class="placeholder-text">No domains found</p>';
            return;
        }

        // Add summary at the top with new three-state system
        const totalDomains = domains.length;
        const availableDomains = domains.filter(d => d.status === 'available').length;
        const usedDomains = domains.filter(d => d.status === 'used').length;
        const inUseDomains = domains.filter(d => d.status === 'in_use').length;
        const totalUsers = domains.reduce((sum, d) => sum + d.user_count, 0);

        let html = `
        <div class="stats-summary">
            <h3>üìä Domain Summary</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                <div style="text-align: center; padding: 8px; background: white; border-radius: 5px;">
                    <div style="font-size: 20px; font-weight: bold; color: #2196F3;">${totalDomains}</div>
                    <div style="font-size: 11px; color: #666;">Total</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 5px;">
                    <div style="font-size: 20px; font-weight: bold; color: #4CAF50;">${availableDomains}</div>
                    <div style="font-size: 11px; color: #666;">Available</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 5px;">
                    <div style="font-size: 20px; font-weight: bold; color: #FF9800;">${usedDomains}</div>
                    <div style="font-size: 11px; color: #666;">Used</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 5px;">
                    <div style="font-size: 20px; font-weight: bold; color: #9C27B0;">${inUseDomains}</div>
                    <div style="font-size: 11px; color: #666;">In Use</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 5px;">
                    <div style="font-size: 20px; font-weight: bold; color: #666;">${totalUsers}</div>
                    <div style="font-size: 11px; color: #666;">Users</div>
                </div>
            </div>
        </div>
        <h4 style="margin: 15px 0 10px 0; color: #333;">Domain Details:</h4>
    `;

        // Sort domains alphabetically by domain name
        const sortedDomains = [...domains].sort((a, b) => {
            return a.domain_name.localeCompare(b.domain_name);
        });

        html += sortedDomains.map(domain => {
            // New three-state system
            let statusColor, statusText, domainClass, clickHandler, domainNameColor;

            if (domain.status === 'in_use') {
                // Purple - currently has users
                statusColor = '#9C27B0';  // Purple
                statusText = 'IN USE';
                domainClass = 'domain-item in-use-domain';
                clickHandler = '';  // Not selectable
                domainNameColor = '#9C27B0';
            } else if (domain.status === 'used') {
                // Orange - previously used but no current users
                statusColor = '#FF9800';  // Orange
                statusText = 'USED';
                domainClass = 'domain-item used-domain';
                clickHandler = '';  // Not selectable
                domainNameColor = '#FF9800';
            } else {
                // Green - never been used (available)
                statusColor = '#4CAF50';  // Green
                statusText = 'AVAILABLE';
                domainClass = 'domain-item';
                clickHandler = `onclick="selectDomain('${domain.domain_name}')"`;
                domainNameColor = 'black';
            }

            return `<div class="${domainClass}" ${clickHandler}>
            <strong style="color: ${domainNameColor};">${domain.domain_name}</strong>
            <span style="float: right; color: #666; font-weight: bold;">${domain.user_count} users</span>
            <div style="margin-top: 5px;">
                ${domain.verified ? '<span style="color: green;">‚úÖ Verified</span>' : '<span style="color: red;">‚ùå Not Verified</span>'}
                <span style="color: ${statusColor}; margin-left: 10px; font-weight: bold;">${statusText}</span>
            </div>
        </div>`;
        }).join('');

        domainList.innerHTML = html;
    }

    function selectDomain(domainName) {
        // Check if domain is used
        const domainElement = event.target.closest('.domain-item');
        if (domainElement.classList.contains('used-domain')) {
            alert('‚ùå This domain has already been used and cannot be selected again.');
            return;
        }

        // Remove previous selection
        document.querySelectorAll('.domain-item').forEach(item => {
            item.classList.remove('selected');
        });

        // Select clicked domain
        domainElement.classList.add('selected');
        selectedDomain = domainName;

        logBulkDomain(`üìå Selected domain: ${domainName}`);
    }

    function applySelectedDomainToCSV() {
        if (!selectedDomain) {
            alert('Please select a domain first');
            return;
        }

        const csvPath = document.getElementById('csv-file-path').value;
        if (!csvPath) {
            alert('Please download users CSV first');
            return;
        }

        logBulkDomain(`‚úÖ Applying domain ${selectedDomain} to CSV...`);

        fetch('/api/apply-domain-to-csv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                selected_domain: selectedDomain,
                csv_path: csvPath
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Domain status is automatically updated by the apply-domain-to-csv endpoint
                    // Update CSV path to modified version
                    document.getElementById('csv-file-path').value = data.modified_csv_path;
                    logBulkDomain(`‚úÖ Domain applied successfully. Modified CSV: ${data.modified_csv_path}`);
                    logBulkDomain(`üìä ${data.modified_count} users will be updated to ${selectedDomain}`);
                } else {
                    logBulkDomain(`‚ùå Failed to apply domain: ${data.error}`);
                    alert('Failed to apply domain: ' + data.error);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert('Network error: ' + error);
            });
    }

    function browseCSVFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.csv';
        input.onchange = function (e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('csv-file-path').value = file.name;
                logBulkDomain(`üìÅ Selected CSV file: ${file.name}`);
            }
        };
        input.click();
    }

    function processDomainChangesFromCSV() {
        const csvPath = document.getElementById('csv-file-path').value;

        if (!csvPath) {
            alert('Please select or specify a CSV file first');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        if (!confirm('‚ö†Ô∏è Process domain changes from CSV?\n\nThis will update user domains as specified in the CSV file.\n\nThis action cannot be easily undone!')) {
            return;
        }

        logBulkDomain(`‚öôÔ∏è Processing domain changes from CSV: ${csvPath}`);

        fetch('/api/process-csv-domain-changes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                csv_path: csvPath
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logBulkDomain(`‚úÖ CSV processing completed!`);
                    logBulkDomain(`üìä Results: ${data.successful} successful, ${data.failed} failed, ${data.skipped} skipped`);

                    if (data.results) {
                        data.results.forEach(result => {
                            if (result.success) {
                                logBulkDomain(`‚úÖ Updated: ${result.old_email} ‚Üí ${result.new_email}`);
                            } else {
                                logBulkDomain(`‚ùå Failed: ${result.email} - ${result.error}`);
                            }
                        });
                    }
                } else {
                    logBulkDomain(`‚ùå CSV processing failed: ${data.error}`);
                    alert('CSV processing failed: ' + data.error);
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå Network error: ${error}`);
                alert('Network error: ' + error);
            });
    }

    function changeDomainForAllUsers() {
        const currentDomain = document.getElementById('current-domain-suffix').value.trim();
        const newDomain = document.getElementById('new-domain-suffix').value.trim();

        if (!currentDomain || !newDomain) {
            alert('Please enter both current and new domain suffixes');
            return;
        }

        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        if (!confirm(`‚ö†Ô∏è Change domain for ALL users?\n\n${currentDomain} ‚Üí ${newDomain}\n\nThis will affect ALL non-admin users with the current domain.\nThis action cannot be easily undone!\n\nContinue?`)) {
            return;
        }

        // Show progress indicator
        const progressContainer = document.getElementById('domain-change-progress');
        const progressBar = document.getElementById('progress-bar');
        const progressPercentage = document.getElementById('progress-percentage');
        const progressMessage = document.getElementById('progress-message');

        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressPercentage.textContent = '0%';
        progressMessage.textContent = 'Starting domain change process...';

        logBulkDomain(`üîÑ Starting bulk domain change: ${currentDomain} ‚Üí ${newDomain}`);

        // Start domain change process (using working synchronous function)
        console.log(`Starting domain change: ${currentDomain} -> ${newDomain}`);

        // Start progress animation
        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15; // Random progress increments
            if (progress > 90) progress = 90; // Don't go to 100% until done
            progressBar.style.width = `${progress}%`;
            progressPercentage.textContent = `${Math.round(progress)}%`;
            progressMessage.textContent = `Processing domain change... ${Math.round(progress)}%`;
        }, 500);

        fetch('/api/change-domain-all-users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                current_domain: currentDomain,
                new_domain: newDomain,
                exclude_admin: true
            })
        })
            .then(response => {
                console.log(`Domain change response status: ${response.status}`);
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error(`Server returned HTML instead of JSON. Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log(`Domain change response data:`, data);
                // Clear progress animation
                clearInterval(progressInterval);

                if (data.success) {
                    // Domain change completed successfully
                    logBulkDomain(`‚úÖ ${data.message || 'Domain change completed successfully!'}`);
                    progressBar.style.width = '100%';
                    progressPercentage.textContent = '100%';
                    progressMessage.textContent = 'Domain change completed successfully!';

                    // Hide progress indicator after 3 seconds
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 3000);
                } else {
                    throw new Error(data.error || 'Failed to change domains');
                }
            })
            .catch(error => {
                console.error('Domain change start error:', error);
                // Clear progress animation
                clearInterval(progressInterval);
                logBulkDomain(`‚ùå Failed to start domain change: ${error.message}`);
                progressContainer.style.display = 'none';
            });
    }

    function pollProgress(taskId) {
        const progressBar = document.getElementById('progress-bar');
        const progressPercentage = document.getElementById('progress-percentage');
        const progressMessage = document.getElementById('progress-message');
        const progressContainer = document.getElementById('domain-change-progress');

        const poll = () => {
            console.log(`Polling for task: ${taskId}`);
            fetch(`/api/progress/${taskId}`)
                .then(response => {
                    console.log(`Progress response status: ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    console.log(`Progress response data:`, data);
                    if (data.success && data.progress) {
                        const progress = data.progress;
                        console.log(`Progress status: ${progress.status}, message: ${progress.message}`);

                        // Update progress bar
                        progressBar.style.width = `${progress.percentage}%`;
                        progressPercentage.textContent = `${progress.percentage}%`;
                        progressMessage.textContent = progress.message;

                        // Update log with progress
                        if (progress.status === 'processing') {
                            logBulkDomain(`üîÑ ${progress.message} (${progress.percentage}%)`);
                        } else if (progress.status === 'completed') {
                            logBulkDomain(`‚úÖ ${progress.message}`);
                            progressContainer.style.display = 'none';
                            return; // Stop polling
                        } else if (progress.status === 'error') {
                            logBulkDomain(`‚ùå ${progress.message}`);
                            progressContainer.style.display = 'none';
                            return; // Stop polling
                        } else if (progress.status === 'not_found') {
                            logBulkDomain(`‚ùå Task not found: ${progress.message}`);
                            progressContainer.style.display = 'none';
                            return; // Stop polling
                        }

                        // Continue polling if still processing
                        if (progress.status === 'processing' || progress.status === 'starting') {
                            setTimeout(poll, 1000); // Poll every second
                        } else {
                            // If we get an unexpected status, log it and stop polling
                            logBulkDomain(`‚ùå Unexpected status: ${progress.status} - ${progress.message}`);
                            progressContainer.style.display = 'none';
                        }
                    } else {
                        logBulkDomain(`‚ùå Failed to get progress: ${data.error || 'Unknown error'}`);
                        progressContainer.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Progress polling error:', error);
                    logBulkDomain(`‚ùå Progress polling failed: ${error.message}`);
                    progressContainer.style.display = 'none';
                });
        };

        // Start polling
        poll();
    }

    function logBulkDomain(message) {
        const log = document.getElementById('bulk-domain-results');
        const timestamp = new Date().toLocaleTimeString();

        if (log.querySelector('.placeholder-text')) {
            log.innerHTML = '';
        }

        log.textContent += `[${timestamp}] ${message}\n`;
        log.scrollTop = log.scrollHeight;
    }

    function clearBulkDomainLog() {
        document.getElementById('bulk-domain-results').innerHTML = '<p class="placeholder-text">Processing results will appear here...</p>';
    }
    function autoChangeSubdomain() {
        if (!isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        // Confirm the action
        if (!confirm('üîÑ Auto Change Subdomain\n\nThis will automatically change all users from the current in-use domain to the next available domain (ascending order).\n\nThis action cannot be easily undone!\n\nContinue?')) {
            return;
        }

        logBulkDomain('üîÑ Starting automated subdomain change...');

        // Show progress indicator
        const progressContainer = document.getElementById('domain-change-progress');
        const progressBar = document.getElementById('progress-bar');
        const progressMessage = document.getElementById('progress-message');
        const progressPercentage = document.getElementById('progress-percentage');

        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressPercentage.textContent = '0%';
        progressMessage.textContent = 'Initializing automated subdomain change...';

        // Show progress indicator on button
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Changing...';
        button.disabled = true;

        // Simulate progress updates
        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += 2;
            if (progress <= 90) {
                progressBar.style.width = progress + '%';
                progressPercentage.textContent = progress + '%';
                progressMessage.textContent = `Processing domain change... ${progress}%`;
            }
        }, 200);

        fetch('/api/auto-change-subdomain', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                progressPercentage.textContent = '100%';

                if (data.success) {
                    logBulkDomain(`‚úÖ ${data.message}`);
                    logBulkDomain(`üìä Successfully changed ${data.successful_changes}/${data.total_users} users`);
                    logBulkDomain(`üîÑ Domain change: ${data.current_domain} ‚Üí ${data.next_domain}`);
                    logBulkDomain(`üìã Available domains: ${data.available_domains.join(', ')}`);

                    if (data.failed_changes > 0) {
                        logBulkDomain(`‚ö†Ô∏è ${data.failed_changes} users failed to change`);
                        if (data.failed_details && data.failed_details.length > 0) {
                            data.failed_details.forEach(failed => {
                                logBulkDomain(`‚ùå Failed: ${failed.email} - ${failed.error}`);
                            });
                        }
                    }

                    progressMessage.textContent = 'Automated subdomain change completed successfully!';

                    // Refresh domain display
                    getDomainInfo();

                    // Auto-retrieve app passwords for the new domain
                    setTimeout(() => {
                        document.getElementById('retrieve-domain').value = data.next_domain;
                        retrieveAppPasswords();
                    }, 1000);

                    // Show success message
                    alert(`‚úÖ Automated subdomain change completed!\n\n${data.message}\n\nChanged ${data.successful_changes}/${data.total_users} users from ${data.current_domain} to ${data.next_domain}`);

                } else {
                    logBulkDomain(`‚ùå Auto change subdomain failed: ${data.error}`);
                    progressMessage.textContent = `Failed: ${data.error}`;
                    alert(`‚ùå Failed to change subdomain: ${data.error}`);
                }
            })
            .catch(error => {
                clearInterval(progressInterval);
                logBulkDomain(`‚ùå Network error: ${error}`);
                progressMessage.textContent = `Network error: ${error.message}`;
                alert(`‚ùå Network error: ${error.message}`);
            })
            .finally(() => {
                // Restore button
                button.innerHTML = originalText;
                button.disabled = false;

                // Hide progress after 3 seconds
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 3000);
            });
    }

    function refreshDomainStatus() {

        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        button.disabled = true;

        fetch('/api/refresh-domain-status', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`‚úÖ Domain status refreshed successfully!\n\n${data.message}\n\nUpdated domains:\n${data.updated_domains.join('\n')}`);
                    // Refresh the domain display
                    getDomainInfo();
                } else {
                    alert('‚ùå Failed to refresh domain status: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Refresh domain status error:', error);
                alert('‚ùå Network error: ' + error.message);
            })
            .finally(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    function markUsedDomains() {
        console.log('markUsedDomains called');

        if (!confirm('This will mark all domains currently in use as "used" in the database. Continue?')) {
            return;
        }

        // Show loading state
        const button = event.target;
        const originalText = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Marking...';
        button.disabled = true;

        fetch('/api/mark-used-domains', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`‚úÖ ${data.message}\n\nüìä Statistics:\n- Updated: ${data.stats.updated}\n- Created: ${data.stats.created}\n- Total Used: ${data.stats.total_used}\n- Total Available: ${data.stats.total_available}`);
                    // Refresh the domain status display
                    refreshDomainStatus();
                } else {
                    alert(`‚ùå Error: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error marking used domains:', error);
                alert(`‚ùå Network Error: ${error.message}`);
            })
            .finally(() => {
                // Restore button state
                button.innerHTML = originalText;
                button.disabled = false;
            });
    }

    function copyRetrievedSubdomains() {
        console.log('copyRetrievedSubdomains called');
        const domainDisplay = document.getElementById('domain-info-display');

        console.log('domainDisplay element:', domainDisplay);

        if (!domainDisplay) {
            alert('‚ùå No domain information found. Please retrieve domains first.');
            return;
        }

        // Extract subdomains from the domain display
        const domainItems = domainDisplay.querySelectorAll('.domain-item');
        console.log('Found domain items:', domainItems.length);

        if (domainItems.length === 0) {
            alert('‚ùå No domains found to copy. Please retrieve domains first.');
            return;
        }

        // Collect all subdomain names
        const subdomains = [];
        domainItems.forEach((item, index) => {
            const domainNameElement = item.querySelector('span');
            console.log(`Domain item ${index}:`, item, 'span element:', domainNameElement);
            if (domainNameElement) {
                const domainName = domainNameElement.textContent.trim();
                console.log(`Found domain: ${domainName}`);
                subdomains.push(domainName);
            }
        });

        console.log('Collected subdomains:', subdomains);

        if (subdomains.length === 0) {
            alert('‚ùå No subdomains found to copy.');
            return;
        }

        // Join subdomains with newlines
        const subdomainsText = subdomains.join('\n');

        // Copy to clipboard
        navigator.clipboard.writeText(subdomainsText).then(() => {
            alert(`‚úÖ Copied ${subdomains.length} subdomains to clipboard!\n\nFirst few subdomains:\n${subdomains.slice(0, 3).join('\n')}${subdomains.length > 3 ? '\n...' : ''}`);
        }).catch(err => {
            console.error('Failed to copy to clipboard:', err);
            // Fallback: show the text in a prompt for manual copying
            prompt('Copy these subdomains manually:', subdomainsText);
        });
    }

    // Tab 4 Functions - SMTP & CSV

    function testSMTPCredentials() {
        const credentials = document.getElementById('smtp-credentials').value.trim();
        const recipient = document.getElementById('smtp-recipient').value.trim();
        const server = document.getElementById('smtp-server').value.trim();
        const port = document.getElementById('smtp-port').value;

        if (!credentials) {
            alert('Please enter SMTP credentials');
            return;
        }

        if (!recipient || !recipient.includes('@')) {
            alert('Please enter a valid recipient email');
            return;
        }

        smtpTesting = true;
        clearSMTPResults();
        logSMTPResult('üöÄ Starting SMTP credential testing...');
        logSMTPResult(`üìß Recipient: ${recipient}`);
        logSMTPResult(`üñ•Ô∏è Server: ${server}:${port}`);
        logSMTPResult('‚îÄ'.repeat(50));

        // Start SMTP testing with progress tracking
        fetch('/api/test-smtp-progress', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                credentials: credentials,
                recipient_email: recipient,
                smtp_server: server,
                smtp_port: parseInt(port)
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const taskId = data.task_id;
                    logSMTPResult(`üìä Testing ${credentials.split('\n').filter(line => line.trim()).length} credentials...`);

                    // Poll for progress updates
                    const progressInterval = setInterval(() => {
                        fetch(`/api/smtp-progress/${taskId}`)
                            .then(response => response.json())
                            .then(progressData => {
                                if (progressData.success) {
                                    const progress = progressData.progress;

                                    // Update progress message
                                    if (progress.current_email) {
                                        logSMTPResult(`üîÑ [${progress.progress}/${progress.total}] Testing ${progress.current_email}...`);
                                    } else {
                                        logSMTPResult(`üîÑ [${progress.progress}/${progress.total}] ${progress.message}`);
                                    }

                                    // Show results as they come in
                                    if (progress.results && progress.results.length > 0) {
                                        const latestResult = progress.results[progress.results.length - 1];
                                        if (latestResult.status === 'success') {
                                            logSMTPResult(`‚úÖ [${progress.progress}/${progress.total}] ${latestResult.email}: ${latestResult.message || 'Success'}`);
                                        } else {
                                            logSMTPResult(`‚ùå [${progress.progress}/${progress.total}] ${latestResult.email}: ${latestResult.error}`);
                                        }
                                    }

                                    // Check if completed
                                    if (progress.status === 'completed') {
                                        clearInterval(progressInterval);
                                        smtpTesting = false;
                                        logSMTPResult('‚îÄ'.repeat(50));
                                        logSMTPResult(`üìà Final Summary: ${progress.success_count}/${progress.total} credentials working`);
                                    } else if (progress.status === 'error') {
                                        clearInterval(progressInterval);
                                        smtpTesting = false;
                                        logSMTPResult(`‚ùå SMTP testing failed: ${progress.message}`);
                                    }
                                } else {
                                    clearInterval(progressInterval);
                                    smtpTesting = false;
                                    logSMTPResult(`‚ùå Progress tracking failed: ${progressData.error}`);
                                }
                            })
                            .catch(error => {
                                clearInterval(progressInterval);
                                smtpTesting = false;
                                logSMTPResult(`‚ùå Progress check error: ${error.message}`);
                            });
                    }, 1000); // Check every second

                } else {
                    smtpTesting = false;
                    logSMTPResult(`‚ùå Failed to start SMTP testing: ${data.error}`);
                }
            })
            .catch(error => {
                smtpTesting = false;
                logSMTPResult(`‚ùå Error: ${error.message}`);
                console.error('SMTP Test Error:', error);
            });
    }

    function interruptSMTPTesting() {
        if (smtpTesting) {
            smtpTesting = false;
            logSMTPResult('‚èπÔ∏è SMTP testing interrupted by user');
            alert('SMTP testing interrupted');
        } else {
            alert('No SMTP testing in progress');
        }
    }

    function clearSMTPResults() {
        document.getElementById('smtp-results-log').textContent = '';
    }

    function logSMTPResult(message) {
        const log = document.getElementById('smtp-results-log');
        const timestamp = new Date().toLocaleTimeString();
        log.textContent += `[${timestamp}] ${message}\n`;
        log.scrollTop = log.scrollHeight;
    }

    function generateUserCSV() {
        const numUsers = document.getElementById('csv-num-users').value;
        const domain = document.getElementById('csv-domain').value.trim();
        const password = document.getElementById('csv-password').value.trim();

        if (!numUsers || numUsers <= 0) {
            alert('Please enter a valid number of users');
            return;
        }

        if (!domain || !domain.includes('.')) {
            alert('Please enter a valid domain');
            return;
        }

        if (!password) {
            alert('Please enter a default password');
            return;
        }

        logResult(`üìù Generating CSV with ${numUsers} users for ${domain}...`);

        fetch('/api/generate-csv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                num_users: parseInt(numUsers),
                domain: domain,
                password: password
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.csv_data) {
                    // Create download link
                    const blob = new Blob([data.csv_data], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const filename = `users_${domain}_${numUsers}.csv`;

                    document.getElementById('csv-download-area').innerHTML = `
                <a href="${url}" download="${filename}" class="download-btn">
                    üì• Download ${filename} (${numUsers} users)
                </a>
            `;

                    logResult(`‚úÖ CSV file generated successfully: ${filename}`);
                } else {
                    logResult(`‚ùå CSV generation failed: ${data.error}`);
                    alert('Failed to generate CSV: ' + data.error);
                }
            })
            .catch(error => {
                logResult(`‚ùå Network error: ${error}`);
                alert('Network error: ' + error);
            });
    }


    function previewCSV() {
        const numUsers = Math.min(document.getElementById('csv-num-users').value || 5, 10); // Preview max 10
        const domain = document.getElementById('csv-domain').value.trim() || 'example.com';
        const password = document.getElementById('csv-password').value.trim() || 'DefaultPass123';

        fetch('/api/preview-csv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                num_users: parseInt(numUsers),
                domain: domain,
                password: password
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.preview) {
                    document.getElementById('csv-preview-area').innerHTML = `
                <h4>üìã CSV Preview (first ${numUsers} rows):</h4>
                <pre>${data.preview}</pre>
            `;
                } else {
                    alert('Failed to preview CSV: ' + data.error);
                }
            })
            .catch(error => {
                alert('Network error: ' + error);
            });
    }



    /*
    
    // COMMENTED OUT - Email Template Functions
    function generateEmailTemplate() {
        const subject = document.getElementById('email-subject').value.trim();
        const body = document.getElementById('email-body').value.trim();
        
        if (!subject || !body) {
            alert('Please enter both subject and body');
            return;
        }
        
        // Sample data for template preview
        const sampleData = {
            email: 'john.doe@example.com',
            password: 'TempPass123',
            first_name: 'John',
            last_name: 'Doe'
        };
        
        let previewSubject = subject;
        let previewBody = body;
        
        // Replace placeholders
        Object.keys(sampleData).forEach(key => {
            const placeholder = `{${key}}`;
            previewSubject = previewSubject.replace(new RegExp(placeholder, 'g'), sampleData[key]);
            previewBody = previewBody.replace(new RegExp(placeholder, 'g'), sampleData[key]);
        });
        
        document.getElementById('email-template-preview').innerHTML = `
            <h4>üìß Email Template Preview:</h4>
            <div style="border: 1px solid #ddd; padding: 1rem; background: white;">
                <div><strong>Subject:</strong> ${previewSubject}</div>
                <hr>
                <div style="white-space: pre-wrap;">${previewBody}</div>
            </div>
            <p><small>üìù Sample data used: ${JSON.stringify(sampleData, null, 2)}</small></p>
        `;
    }
    
    // COMMENTED OUT - Email Template Functions
    function testEmailTemplate() {
        alert('Email template testing feature coming soon!');
    }
    */

    // Mega Upgrade Functions
    function openMegaUpgradeModal() {
        console.log('Opening mega upgrade modal...');
        const modal = document.getElementById('megaUpgradeModal');
        if (modal) {
            modal.style.display = 'block';
            console.log('Modal opened successfully');
        } else {
            console.error('Modal not found!');
            alert('Modal not found. Please refresh the page.');
        }
    }

    function closeMegaUpgradeModal() {
        document.getElementById('megaUpgradeModal').style.display = 'none';
    }

    function startMegaUpgrade() {
        console.log('Starting mega upgrade...');
        const accountInput = document.getElementById('mega-single-account');

        let accounts = [];
        if (accountInput) {
            const accountText = (accountInput.value || '').trim();
            if (!accountText) {
                alert('Please enter at least one account email address');
                return;
            }

            // Parse accounts (one per line)
            accounts = accountText
                .split('\n')
                .map(line => line.trim())
                .filter(line => line && line.includes('@'));
        }

        if (accounts.length === 0) {
            alert('Please provide at least one valid account (one per line).');
            return;
        }

        // Get selected features
        const features = {
            authenticate: document.getElementById('feature-authenticate').checked,
            changeSubdomain: document.getElementById('feature-change-subdomain').checked
        };

        console.log('Selected features:', features);
        console.log('Accounts to process:', accounts);

        // Show progress section
        document.getElementById('megaUpgradeProgress').style.display = 'block';
        document.getElementById('megaStartBtn').style.display = 'none';
        document.getElementById('megaStopBtn').style.display = 'inline-block';

        // Reset log counter for new process
        window.lastLoggedCount = 0;

        // Start mega upgrade process
        runMegaUpgradeWorkflow(accounts, features);
    }

    function stopMegaUpgrade() {
        // Stop the process (implementation depends on backend)
        document.getElementById('megaStartBtn').style.display = 'inline-block';
        document.getElementById('megaStopBtn').style.display = 'none';
        logBulkDomain('‚èπÔ∏è Mega upgrade process stopped by user');
    }

    function clearMegaUpgradeResults() {
        document.getElementById('app-passwords-display').value = '';
        logBulkDomain('üßπ Mega upgrade results cleared');
    }

    function updateMegaProgress(percentage, message, accountInfo = null) {
        const progressBar = document.getElementById('megaProgressBar');
        const progressPercent = document.getElementById('megaProgressPercent');
        const progressText = document.getElementById('megaProgressText');

        console.log('updateMegaProgress called:', { percentage, message, accountInfo });

        if (progressBar && progressPercent && progressText) {
            progressBar.style.width = percentage + '%';
            progressPercent.textContent = percentage + '%';

            // Enhanced progress message with account counting
            if (accountInfo) {
                const { current, total, account, status } = accountInfo;
                let statusIcon = '';
                if (status === 'success') statusIcon = '‚úÖ';
                else if (status === 'failed') statusIcon = '‚ùå';
                else if (status === 'processing') statusIcon = 'üîÑ';

                progressText.innerHTML = `
                <div style="font-weight: bold; color: #0366d6;">
                    ${statusIcon} Processing account ${current}/${total}: ${account}
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 2px;">
                    ${message}
                </div>
            `;
                console.log('Updated progress with account info:', accountInfo);
            } else {
                progressText.textContent = message;
                console.log('Updated progress with simple message:', message);
            }
        } else {
            console.error('Progress elements not found:', { progressBar, progressPercent, progressText });
        }
    }

    // Progress polling function for real-time updates
    function pollMegaUpgradeProgress(taskId, totalAccounts) {
        if (!taskId) return;

        const pollInterval = setInterval(() => {
            fetch(`/api/mega-upgrade-progress/${taskId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.progress) {
                        const progress = data.progress;
                        const percentage = Math.round((progress.completed_accounts / totalAccounts) * 100);

                        // Update progress with account counting
                        updateMegaProgress(percentage, progress.progress_message, {
                            current: progress.current_account_index || progress.completed_accounts,
                            total: totalAccounts,
                            account: progress.current_account || 'Processing...',
                            status: progress.status === 'running' ? 'processing' : 'success'
                        });

                        // Stop polling if completed
                        if (progress.status === 'completed' || progress.status === 'error') {
                            clearInterval(pollInterval);
                        }
                    }
                })
                .catch(error => {
                    console.error('Progress polling error:', error);
                    clearInterval(pollInterval);
                });
        }, 2000); // Poll every 2 seconds

        return pollInterval;
    }


    function debugMegaUpgrade() {
        const accountsText = document.getElementById('mega-accounts-list').value.trim();

        if (!accountsText) {
            alert('Please enter at least one account');
            return;
        }

        // Parse accounts from textarea (one per line)
        const accounts = accountsText.split('\n')
            .map(line => line.trim())
            .filter(line => line && line.includes('@')); // Filter out empty lines and invalid emails

        if (accounts.length === 0) {
            alert('Please enter valid email addresses (one per line)');
            return;
        }

        // Get selected features
        const features = {
            authenticate: document.getElementById('feature-authenticate').checked,
            changeSubdomain: document.getElementById('feature-change-subdomain').checked
        };

        logBulkDomain('üêõ Starting DEBUG Mega Upgrade...');
        logBulkDomain(`üìä Debugging ${accounts.length} accounts with selected features`);
        logBulkDomain(`üîß Features: ${Object.keys(features).filter(k => features[k]).join(', ')}`);
        logBulkDomain('‚îÄ'.repeat(50));

        // Test the debug endpoint
        fetch('/api/debug-mega-upgrade', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                accounts: accounts,
                features: features
            })
        })
            .then(response => {
                logBulkDomain(`üîç Response status: ${response.status}`);
                logBulkDomain(`üîç Response headers: ${JSON.stringify(Object.fromEntries(response.headers))}`);
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    logBulkDomain(`‚úÖ DEBUG completed successfully: ${data.message}`);
                    logBulkDomain(`üìä Accounts received: ${data.accounts_received}`);
                    logBulkDomain(`üîß Features received: ${JSON.stringify(data.features_received)}`);
                    logBulkDomain(`üóÑÔ∏è Database accounts: ${data.database_accounts}`);
                    logBulkDomain(`üîç Debug info: ${data.debug_info}`);
                    logBulkDomain('‚îÄ'.repeat(50));
                    logBulkDomain('üéâ DEBUG completed - All systems operational!');
                } else {
                    logBulkDomain(`‚ùå DEBUG failed: ${data.error}`);
                    if (data.traceback) {
                        logBulkDomain(`üîç Traceback: ${data.traceback}`);
                    }
                }
            })
            .catch(error => {
                logBulkDomain(`‚ùå DEBUG error: ${error.message}`);
                console.error('DEBUG Error:', error);
            });
    }
    function runMegaUpgradeWorkflow(accounts, features) {
        logBulkDomain('üöÄ Starting Mega Upgrade Workflow...');
        logBulkDomain(`üìä Processing ${accounts.length} accounts with selected features`);
        logBulkDomain(`üîß Features: ${Object.keys(features).filter(k => features[k]).join(', ')}`);
        logBulkDomain('‚îÄ'.repeat(50));

        // Show detailed processing for each account
        accounts.forEach((account, index) => {
            logBulkDomain(`üìß Account ${index + 1}: ${account}`);
        });
        logBulkDomain('‚îÄ'.repeat(50));

        // Initialize progress with account counting
        updateMegaProgress(0, 'Initializing...', {
            current: 0,
            total: accounts.length,
            account: 'Starting...',
            status: 'processing'
        });

        logBulkDomain('‚è≥ Starting automated processing...');
        logBulkDomain('‚è∞ Note: Processing multiple accounts may take 30-120 minutes depending on user count');
        logBulkDomain('üïê Timeout set to 2 HOURS to allow for long subdomain change processes');

        // Start progress polling immediately
        let progressPolling = null;

        // Simulate progress updates during processing
        let progressSimulation = null;
        let currentAccountIndex = 0;

        const simulateProgress = () => {
            if (currentAccountIndex < accounts.length) {
                const percentage = Math.round(((currentAccountIndex + 1) / accounts.length) * 85); // Leave 15% for completion
                updateMegaProgress(percentage, `Processing account ${currentAccountIndex + 1}/${accounts.length}: ${accounts[currentAccountIndex]}`, {
                    current: currentAccountIndex + 1,
                    total: accounts.length,
                    account: accounts[currentAccountIndex],
                    status: 'processing'
                });
                currentAccountIndex++;
            } else {
                // If we've gone through all accounts but request is still pending, show waiting message
                updateMegaProgress(90, `Waiting for server response... (${accounts.length}/${accounts.length} accounts processed) - Timeout: 2 hours`, {
                    current: accounts.length,
                    total: accounts.length,
                    account: 'Waiting for server...',
                    status: 'processing'
                });
            }
        };

        // Start progress simulation every 3 seconds
        progressSimulation = setInterval(simulateProgress, 3000);

        // Add a special message after 10 minutes to reassure user
        setTimeout(() => {
            logBulkDomain('‚îÄ'.repeat(50));
            logBulkDomain('‚è∞ Process is taking longer than expected - this is NORMAL for subdomain changes');
            logBulkDomain('üîÑ The backend is still working - please be patient');
            logBulkDomain('üïê Timeout is set to 2 HOURS to allow for completion');
            logBulkDomain('‚îÄ'.repeat(50));
        }, 10 * 60 * 1000); // After 10 minutes

        // Start the mega upgrade process with MUCH longer timeout for subdomain changes
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120 * 60 * 1000); // 2 HOURS timeout for subdomain changes

        fetch('/api/mega-upgrade', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                accounts: accounts,
                features: features
            }),
            signal: controller.signal
        })
            .then(response => {
                clearTimeout(timeoutId); // Clear the timeout since we got a response
                clearInterval(progressSimulation); // Stop progress simulation

                logBulkDomain(`üì° Response received: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return response.json();
            })
            .then(data => {
                updateMegaProgress(80, 'Analyzing results...');
                logBulkDomain('‚îÄ'.repeat(50));
                logBulkDomain('üìã PROCESSING RESULTS:');

                if (data.success) {
                    logBulkDomain(`‚úÖ Mega upgrade completed successfully!`);
                    logBulkDomain(`üìä Results: ${data.successful_accounts} successful, ${data.failed_accounts} failed`);
                    logBulkDomain(`üìã Total accounts processed: ${data.total_accounts}`);

                    // Show completion with account counting
                    updateMegaProgress(100, 'Subdomain change completed successfully!', {
                        current: accounts.length,
                        total: accounts.length,
                        account: 'All accounts processed',
                        status: 'success'
                    });

                    // Display detailed results for each account
                    if (data.final_results && data.final_results.length > 0) {
                        logBulkDomain('‚îÄ'.repeat(50));
                        logBulkDomain('‚úÖ SUCCESSFUL ACCOUNTS:');
                        data.final_results.forEach((result, index) => {
                            logBulkDomain(`  ${index + 1}. Account: ${result.account}`);
                            logBulkDomain(`     New Name: ${result.new_account_name}`);
                            logBulkDomain(`     App Password: ${result.app_password}`);
                            logBulkDomain(`     Status: ${result.status}`);
                        });
                    }

                    // Save next-domain map for precise subdomain mapping per base
                    if (data.next_domain_map) {
                        window.baseToNewSubdomainMap = data.next_domain_map;
                        logBulkDomain(`üß≠ Next-domain map from server: ${JSON.stringify(data.next_domain_map)}`);
                    }

                    // Display SMTP results if available
                    if (data.smtp_results && data.smtp_results.length > 0) {
                        logBulkDomain('‚îÄ'.repeat(50));
                        logBulkDomain('üìß SMTP CONFIGURATION RESULTS:');
                        data.smtp_results.forEach((smtp, index) => {
                            logBulkDomain(`  ${index + 1}. ${smtp}`);
                        });

                        const display = document.getElementById('app-passwords-display');
                        display.value = data.smtp_results.join('\n');
                        logBulkDomain(`üìã ${data.smtp_results.length} SMTP results displayed in textarea`);
                    } else if (features.retrievePasswords) {
                        // If enabled but backend returned none, attempt client-side generation using detected domain
                        // Prefer precise per-base mapping if present; otherwise fall back to detected domain
                        const targetDomain = (window.baseToNewSubdomainMap && Object.values(window.baseToNewSubdomainMap)[0])
                            || window.megaUpgradeChangedSubdomain || window.currentTargetDomain;
                        if (targetDomain) {
                            logBulkDomain('‚ÑπÔ∏è No SMTP results from server, generating client-side using detected domain');
                            generateAppPasswordsWithTargetDomain(accounts, targetDomain);
                        } else {
                            logBulkDomain('‚ö†Ô∏è No SMTP results and no detected domain');
                        }
                    }

                    // Display failed details if any
                    if (data.failed_details && data.failed_details.length > 0) {
                        logBulkDomain('‚îÄ'.repeat(50));
                        logBulkDomain('‚ùå FAILED ACCOUNTS DETAILS:');
                        data.failed_details.forEach((detail, index) => {
                            logBulkDomain(`  ${index + 1}. Account: ${detail.account}`);
                            logBulkDomain(`     Step: ${detail.step}`);
                            logBulkDomain(`     Error: ${detail.error}`);
                        });
                    }

                    updateMegaProgress(100, 'Completed successfully!');
                    logBulkDomain('‚îÄ'.repeat(50));
                    logBulkDomain('üéâ Mega Upgrade Workflow Finished!');

                    // Hide progress after 3 seconds
                    setTimeout(() => {
                        document.getElementById('megaUpgradeProgress').style.display = 'none';
                    }, 3000);
                } else {
                    // Show failure with account counting
                    updateMegaProgress(100, 'Process failed', {
                        current: 0,
                        total: accounts.length,
                        account: 'Process failed',
                        status: 'failed'
                    });

                    document.getElementById('megaStartBtn').style.display = 'inline-block';
                    document.getElementById('megaStopBtn').style.display = 'none';
                    logBulkDomain(`‚ùå Mega upgrade failed: ${data.error}`);

                    // Check for partial results
                    if (data.partial_results) {
                        logBulkDomain('‚îÄ'.repeat(50));
                        logBulkDomain('üìä PARTIAL RESULTS:');
                        logBulkDomain(`‚úÖ Successful accounts: ${data.partial_results.successful_accounts}`);
                        logBulkDomain(`‚ùå Failed accounts: ${data.partial_results.failed_accounts}`);

                        if (data.partial_results.failed_details && data.partial_results.failed_details.length > 0) {
                            logBulkDomain('üìã Failed account details:');
                            data.partial_results.failed_details.forEach((detail, index) => {
                                logBulkDomain(`  ${index + 1}. Account: ${detail.account}`);
                                logBulkDomain(`     Step: ${detail.step}`);
                                logBulkDomain(`     Error: ${detail.error}`);
                            });
                        }

                        if (data.partial_results.next_domain_map && Object.keys(data.partial_results.next_domain_map).length > 0) {
                            logBulkDomain('üåê Domain changes completed:');
                            Object.entries(data.partial_results.next_domain_map).forEach(([base, new_domain]) => {
                                logBulkDomain(`  ${base} ‚Üí ${new_domain}`);
                            });
                        }
                    }

                    logBulkDomain('‚îÄ'.repeat(50));
                    logBulkDomain('üîç Check server logs for more details');
                }
            })
            .catch(error => {
                clearTimeout(timeoutId); // Clear timeout on error
                clearInterval(progressSimulation); // Stop progress simulation

                console.error('Mega Upgrade Error:', error);

                // Show error with account counting
                updateMegaProgress(100, 'Request timeout - subdomain may have changed successfully', {
                    current: 0,
                    total: accounts.length,
                    account: 'Timeout occurred',
                    status: 'failed'
                });

                document.getElementById('megaStartBtn').style.display = 'inline-block';
                document.getElementById('megaStopBtn').style.display = 'none';

                if (error.name === 'AbortError') {
                    logBulkDomain(`‚è∞ Request timeout after 2 HOURS - process may still be running on server`);
                    logBulkDomain('‚îÄ'.repeat(50));
                    logBulkDomain('üîç Check server logs to see if processing completed');
                    logBulkDomain('üí° Try refreshing the page and checking domain status');
                    logBulkDomain('‚úÖ If subdomain was changed successfully, the process worked despite the timeout');
                } else {
                    logBulkDomain(`‚ùå Network Error: ${error.message}`);
                    logBulkDomain('‚îÄ'.repeat(50));
                    logBulkDomain('üîç Check server connection and logs');
                }

                // Even if server times out, find the ACTUAL changed subdomain
                logBulkDomain('‚îÄ'.repeat(50));
                logBulkDomain('üîë Server timeout - finding ACTUAL changed subdomain...');
                logBulkDomain('üîÑ Detecting the subdomain that was actually changed...');

                // Try to detect the ACTUAL subdomain change by checking domains
                logBulkDomain('üîç Detecting ACTUAL subdomain change from domain list...');

                fetch('/api/retrieve-domains', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        batched: true
                    })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.domains && data.domains.length > 0) {
                            logBulkDomain(`‚úÖ Retrieved ${data.domains.length} domains despite timeout`);

                            // Debug: Log all domains to understand the structure
                            logBulkDomain(`üîç Debug: Analyzing ${data.domains.length} domains after timeout...`);
                            data.domains.forEach((domain, index) => {
                                logBulkDomain(`   Domain ${index + 1}: ${JSON.stringify(domain)}`);
                            });

                            // Find the ACTUAL subdomain that was changed (IN USE with users)
                            const inUseDomains = data.domains.filter(domain =>
                                (domain.status === 'in_use' || domain.status_text === 'IN USE') &&
                                domain.user_count > 0 &&
                                (domain.domainName || domain.domain_name) &&
                                (domain.domainName || domain.domain_name) !== 'undefined'
                            );

                            logBulkDomain(`üîç Found ${inUseDomains.length} IN USE domains with users after timeout`);

                            if (inUseDomains.length > 0) {
                                const selectedDomain = inUseDomains.reduce((prev, current) =>
                                    (current.user_count > prev.user_count) ? current : prev
                                );
                                const targetDomain = selectedDomain.domainName || selectedDomain.domain_name;
                                const userCount = selectedDomain.user_count;

                                window.megaUpgradeChangedSubdomain = targetDomain;
                                logBulkDomain(`üéØ Detected ACTUAL changed subdomain: ${targetDomain} (${userCount} users)`);
                                logBulkDomain(`‚úÖ This is the EXACT subdomain that was changed during Mega Upgrade`);
                            } else {
                                // Fallback to any domain with users
                                const domainsWithUsers = data.domains.filter(domain =>
                                    domain.user_count > 0 &&
                                    (domain.domainName || domain.domain_name) &&
                                    (domain.domainName || domain.domain_name) !== 'undefined'
                                );

                                logBulkDomain(`üîç Found ${domainsWithUsers.length} domains with users after timeout`);

                                if (domainsWithUsers.length > 0) {
                                    const selectedDomain = domainsWithUsers.reduce((prev, current) =>
                                        (current.user_count > prev.user_count) ? current : prev
                                    );
                                    const targetDomain = selectedDomain.domainName || selectedDomain.domain_name;
                                    const userCount = selectedDomain.user_count;

                                    window.megaUpgradeChangedSubdomain = targetDomain;
                                    logBulkDomain(`üéØ Detected changed subdomain: ${targetDomain} (${userCount} users)`);
                                } else {
                                    // Final fallback: any domain with valid name
                                    const validDomains = data.domains.filter(domain =>
                                        (domain.domainName || domain.domain_name) &&
                                        (domain.domainName || domain.domain_name) !== 'undefined' &&
                                        (domain.domainName || domain.domain_name).length > 0
                                    );

                                    if (validDomains.length > 0) {
                                        const targetDomain = validDomains[0].domainName || validDomains[0].domain_name;
                                        window.megaUpgradeChangedSubdomain = targetDomain;
                                        logBulkDomain(`üéØ Using first valid domain: ${targetDomain}`);
                                    } else {
                                        logBulkDomain(`‚ùå No valid domains found after timeout`);
                                    }
                                }
                            }
                        }

                        // If requested, generate/display app passwords using detected domain
                        if (features.retrievePasswords) {
                            logBulkDomain('üîë Generating app passwords with ACTUAL target domain...');
                            const targetDomain = window.megaUpgradeChangedSubdomain || window.currentTargetDomain;
                            if (targetDomain) {
                                generateAppPasswordsWithTargetDomain(accounts, targetDomain);
                            } else {
                                logBulkDomain('‚ö†Ô∏è No detected domain for password retrieval');
                            }
                        } else {
                            logBulkDomain('‚ÑπÔ∏è Password retrieval not selected - skipping');
                        }
                    })
                    .catch(error => {
                        logBulkDomain(`‚ùå Error detecting ACTUAL subdomain change: ${error.message}`);
                        logBulkDomain(`‚ö†Ô∏è Cannot proceed without the actual changed subdomain`);
                    });
            });
    }

    // ===== APP PASSWORD MANAGEMENT FUNCTIONS (REFACTORED) =====

    // Global state for app password management
    const AppPasswordManager = {
        currentFile: null,
        isUploading: false
    };

    // Handle file selection
    function handleAppPasswordsFile(input) {
        const file = input.files[0];
        if (!file) {
            AppPasswordManager.currentFile = null;
            console.log('No file selected');
            return;
        }

        // Validate file type
        if (!file.name.endsWith('.txt')) {
            alert('Please select a .txt file');
            input.value = '';
            AppPasswordManager.currentFile = null;
            return;
        }

        AppPasswordManager.currentFile = file;
        console.log(`File selected: ${file.name} (${file.size} bytes)`);
    }

    // Upload app passwords with better error handling
    function uploadAppPasswords() {
        // Check if already uploading
        if (AppPasswordManager.isUploading) {
            alert('Upload already in progress...');
            return;
        }

        // Check if file is selected
        if (!AppPasswordManager.currentFile) {
            alert('Please select a file first');
            return;
        }

        // Get the button element
        const button = event.target || document.querySelector('button[onclick*="uploadAppPasswords"]');
        const originalHTML = button.innerHTML;

        // Set uploading state
        AppPasswordManager.isUploading = true;
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';

        // Create form data
        const formData = new FormData();
        formData.append('file', AppPasswordManager.currentFile);

        console.log(`Uploading file: ${AppPasswordManager.currentFile.name}`);

        // Perform upload
        fetch('/api/upload-app-passwords', {
            method: 'POST',
            body: formData
        })
            .then(response => {
                console.log(`Upload response status: ${response.status}`);
                console.log(`Upload response headers:`, response.headers);

                // Check if response is ok
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server error response:', text);
                        throw new Error(`Server error ${response.status}: ${text}`);
                    });
                }

                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    return response.text().then(text => {
                        console.error('Non-JSON response:', text);
                        throw new Error(`Expected JSON response but got: ${contentType}`);
                    });
                }

                return response.json();
            })
            .then(data => {
                console.log('Upload response data:', data);

                if (data.success) {
                    const count = data.count || 0;
                    const added = data.added || 0;
                    const updated = data.updated || 0;
                    const errors = data.errors || 0;

                    let message = `‚úÖ Successfully processed ${count} app passwords from this file!\n\n`;
                    message += `üìä Details:\n`;
                    message += `‚Ä¢ Added: ${added} new passwords\n`;
                    message += `‚Ä¢ Updated: ${updated} existing passwords\n`;
                    if (errors > 0) {
                        message += `‚Ä¢ Errors: ${errors} failed to process\n`;
                    }

                    alert(message);

                    // Clear file input but keep the ability to upload more files
                    const fileInput = document.getElementById('app-passwords-file');
                    if (fileInput) fileInput.value = '';
                    AppPasswordManager.currentFile = null;

                    // Reload status to show total count
                    loadAppPasswordsStatus();
                } else {
                    const errorMsg = data.error || 'Unknown error occurred';

                    // Check if this is a sequence error
                    if (data.sequence_error) {
                        const fixCommand = data.fix_command || 'python fix_used_domain_sequence.py --all';
                        alert(`‚ùå Database Sequence Error!\n\n${errorMsg}\n\nüîß To fix this issue, run this command on your server:\n\n${fixCommand}\n\nThis will reset the database sequences and allow uploads to work again.`);
                    } else {
                        alert(`‚ùå Upload failed: ${errorMsg}`);
                    }
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                alert(`‚ùå Upload error: ${error.message}`);
            })
            .finally(() => {
                // Reset button state
                AppPasswordManager.isUploading = false;
                button.disabled = false;
                button.innerHTML = originalHTML;
            });
    }

    // Clear all app passwords with confirmation
    function clearAppPasswords() {
        if (!confirm('Are you sure you want to clear all app passwords?\nThis action cannot be undone.')) {
            return;
        }

        console.log('Clearing all app passwords...');

        fetch('/api/clear-app-passwords', {
            method: 'DELETE'
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server error ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Clear response:', data);

                if (data.success) {
                    alert('‚úÖ All app passwords cleared successfully!');
                    loadAppPasswordsStatus();
                } else {
                    alert(`‚ùå Error: ${data.error || 'Failed to clear passwords'}`);
                }
            })
            .catch(error => {
                console.error('Clear error:', error);
                alert(`‚ùå Error clearing passwords: ${error.message}`);
            });
    }

    // Download template file
    function downloadAppPasswordsTemplate() {
        console.log('Downloading template...');

        const template = [
            '# App Passwords Template',
            '# Format: email:password',
            '# One entry per line',
            '',
            'user1@example.com:app_password_1',
            'user2@example.com:app_password_2',
            'admin@company.com:app_password_3',
            'john.doe@domain.com:app_password_4'
        ].join('\n');

        const blob = new Blob([template], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');

        link.href = url;
        link.download = 'app_passwords_template.txt';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        window.URL.revokeObjectURL(url);

        console.log('Template downloaded');
    }

    // Test API endpoint
    function testAppPasswordsAPI() {
        console.log('Testing App Password API...');

        fetch('/api/test-app-passwords')
            .then(response => {
                console.log(`Test API status: ${response.status}`);

                if (!response.ok) {
                    throw new Error(`API test failed with status ${response.status}`);
                }

                return response.json();
            })
            .then(data => {
                console.log('Test API response:', data);

                if (data.success) {
                    alert(`‚úÖ API Test Passed!\n\nDatabase count: ${data.database_count || 0}\nTest operations: ${data.test_passed ? 'Success' : 'Failed'}`);
                } else {
                    alert(`‚ùå API Test Failed!\n\nError: ${data.error || 'Unknown error'}\nMessage: ${data.message || ''}`);
                }
            })
            .catch(error => {
                console.error('Test API error:', error);
                alert(`‚ùå API Test Error: ${error.message}`);
            });
    }


    // Debug app password matching for specific email
    function debugAppPasswordMatching(email) {
        if (!email) {
            email = prompt('Enter email to debug matching:');
            if (!email) return;
        }

        console.log(`=== DEBUGGING APP PASSWORD MATCHING FOR: ${email} ===`);

        fetch('/api/debug-app-password-matching', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: email })
        })
            .then(response => response.json())
            .then(data => {
                console.log('Debug matching response:', data);

                if (data.success && data.debug_info) {
                    const info = data.debug_info;
                    let message = `Debug Results for: ${info.email}\n\n`;
                    message += `Username: ${info.username}\n`;
                    message += `Domain: ${info.domain}\n\n`;

                    message += 'Matching Strategies:\n';
                    info.matches.forEach(match => {
                        if (match.found) {
                            message += `‚úÖ ${match.strategy}: ${match.username}@${match.domain}\n`;
                        } else {
                            message += `‚ùå ${match.strategy}: Not found\n`;
                        }
                    });

                    if (info.similar_records.length > 0) {
                        message += '\nSimilar Records in Database:\n';
                        info.similar_records.forEach(record => {
                            message += `- ${record.username}@${record.domain}\n`;
                        });
                    }

                    alert(message);
                } else {
                    alert(`Debug failed: ${data.error || 'Unknown error'}`);
                }
            })
            .catch(error => {
                console.error('Debug matching error:', error);
                alert(`Debug Error: ${error.message}`);
            });
    }

    // Load and display app passwords status
    function loadAppPasswordsStatus() {
        console.log('Loading app passwords status...');

        fetch('/api/app-passwords-status')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Status API failed with status ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Status response:', data);

                const statusElement = document.getElementById('app-passwords-count');
                if (!statusElement) {
                    console.error('Status element not found');
                    return;
                }

                if (data.success) {
                    const count = data.count || 0;
                    statusElement.textContent = `${count} app passwords stored (from all uploaded files)`;

                    // Log sample data if available
                    if (data.sample_data && data.sample_data.length > 0) {
                        console.log('Sample stored passwords:', data.sample_data);
                    }

                    // Show additional info if there are passwords
                    if (count > 0) {
                        console.log(`Total app passwords in database: ${count}`);
                    }
                } else {
                    statusElement.textContent = 'Error loading status';
                    console.error('Status error:', data.error);
                }
            })
            .catch(error => {
                console.error('Status loading error:', error);
                const statusElement = document.getElementById('app-passwords-count');
                if (statusElement) {
                    statusElement.textContent = 'Error loading status';
                }
            });
    }

    // Advanced App Password Management Functions

    // Debug app passwords
    function debugAppPasswords() {
        console.log('=== DEBUG APP PASSWORDS ===');

        fetch('/api/debug-app-passwords')
            .then(response => response.json())
            .then(data => {
                console.log('Debug API response:', data);

                if (data.success) {
                    const info = data.debug_info;
                    console.log(`Total app passwords in database: ${info.total_count}`);
                    console.log('Sample records:', info.sample_records);
                    console.log('Recent records:', info.recent_records);

                    alert(`Debug Info:\n\nTotal records: ${info.total_count}\n\nCheck browser console for detailed information.`);
                } else {
                    console.error('Debug API failed:', data.error);
                    alert(`Debug failed: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Debug request failed:', error);
                alert(`Debug request failed: ${error.message}`);
            });
    }

    // Search app password users
    function searchAppPasswordUsers() {
        const searchTerm = document.getElementById('search-app-passwords').value.trim();
        const resultsDiv = document.getElementById('app-passwords-search-results');

        if (!searchTerm) {
            resultsDiv.style.display = 'none';
            return;
        }

        console.log('Searching app password users:', searchTerm);

        fetch('/api/list-app-passwords')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Search API response:', data);

                if (data.success && data.users && Array.isArray(data.users)) {
                    const searchLower = searchTerm.toLowerCase();
                    const filteredUsers = data.users.filter(user => {
                        if (!user || !user.username || !user.domain) {
                            console.log('Invalid user record:', user);
                            return false;
                        }

                        const username = user.username.toLowerCase();
                        const domain = user.domain.toLowerCase();
                        const fullEmail = `${username}@${domain}`;

                        // Enhanced search logic
                        const matchesUsername = username.includes(searchLower);
                        const matchesDomain = domain.includes(searchLower);
                        const matchesFullEmail = fullEmail.includes(searchLower);
                        const exactEmailMatch = searchLower.includes('@') && fullEmail === searchLower;

                        const matches = matchesUsername || matchesDomain || matchesFullEmail || exactEmailMatch;

                        if (matches) {
                            console.log(`Match found: ${username}@${domain} (search: ${searchLower})`);
                        }

                        return matches;
                    });

                    console.log(`Found ${filteredUsers.length} matching users out of ${data.users.length} total:`, filteredUsers);
                    displaySearchResults(filteredUsers);
                } else {
                    console.log('No users data in response');
                    resultsDiv.innerHTML = '<div style="color: #6a737d; font-style: italic;">No users found</div>';
                    resultsDiv.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Error searching app password users:', error);
                resultsDiv.innerHTML = '<div style="color: #dc3545;">Error searching users</div>';
                resultsDiv.style.display = 'block';
            });
    }

    // Display search results
    function displaySearchResults(users) {
        const resultsDiv = document.getElementById('app-passwords-search-results');

        if (users.length === 0) {
            resultsDiv.innerHTML = '<div style="color: #6a737d; font-style: italic;">No matching users found</div>';
            resultsDiv.style.display = 'block';
            return;
        }

        let html = '<div style="font-size: 14px;">';
        html += `<div style="margin-bottom: 8px; font-weight: bold; color: #24292f;">Found ${users.length} user(s):</div>`;

        users.forEach((user, index) => {
            const email = user.domain === '*' ? user.username : `${user.username}@${user.domain}`;
            html += `<div style="padding: 8px; border: 1px solid #d0d7de; border-radius: 4px; margin-bottom: 4px; background: #f6f8fa;">`;
            html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
            html += `<div><strong>${email}</strong><br><small style="color: #656d76;">Password: ${user.app_password ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : 'Not set'}</small></div>`;
            html += `<div style="display: flex; gap: 4px;">`;
            html += `<button onclick="editAppPasswordUser('${user.username}', '${user.domain}')" class="btn-github" style="padding: 4px 8px; font-size: 12px;"><i class="fas fa-edit"></i></button>`;
            html += `<button onclick="deleteAppPasswordUser('${user.username}', '${user.domain}')" class="btn-github" style="padding: 4px 8px; font-size: 12px; background-color: #dc3545; color: white;"><i class="fas fa-trash"></i></button>`;
            html += `<button onclick="debugAppPasswordMatching('${email}')" class="btn-github" style="padding: 4px 8px; font-size: 12px; background-color: #17a2b8; color: white;"><i class="fas fa-bug"></i></button>`;
            html += `</div></div></div>`;
        });

        html += '</div>';
        resultsDiv.innerHTML = html;
        resultsDiv.style.display = 'block';
    }

    // Edit app password user
    function editAppPasswordUser(username, domain) {
        const newPassword = prompt(`Edit app password for ${username}@${domain}:`, '');
        if (newPassword === null) return;

        if (!newPassword.trim()) {
            alert('Password cannot be empty');
            return;
        }

        fetch('/api/update-app-password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                username: username,
                domain: domain,
                app_password: newPassword.trim()
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ App password updated successfully');
                    searchAppPasswordUsers(); // Refresh search results
                    loadAppPasswordsStatus(); // Refresh status
                } else {
                    alert(`‚ùå Error updating app password: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error updating app password:', error);
                alert(`‚ùå Error updating app password: ${error.message}`);
            });
    }

    // Delete single app password user
    function deleteAppPasswordUser(username, domain) {
        if (!confirm(`Are you sure you want to delete the app password for ${username}@${domain}?`)) {
            return;
        }

        fetch('/api/delete-app-password', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                username: username,
                domain: domain
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('‚úÖ App password deleted successfully');
                    searchAppPasswordUsers(); // Refresh search results
                    loadAppPasswordsStatus(); // Refresh status
                } else {
                    alert(`‚ùå Error deleting app password: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error deleting app password:', error);
                alert(`‚ùå Error deleting app password: ${error.message}`);
            });
    }
    // Delete specific app passwords
    function deleteSpecificAppPasswords() {
        const deleteField = document.getElementById('delete-app-passwords');
        const usersToDelete = deleteField.value.trim();

        if (!usersToDelete) {
            alert('Please enter users to delete (one per line)');
            return;
        }

        const userList = usersToDelete.split('\n').filter(line => line.trim());
        if (userList.length === 0) {
            alert('Please enter at least one user to delete');
            return;
        }

        if (!confirm(`Are you sure you want to delete ${userList.length} app password(s)?\n\nThis action cannot be undone!`)) {
            return;
        }

        console.log('Deleting specific app passwords:', userList);

        fetch('/api/delete-specific-app-passwords', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                users: userList
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`‚úÖ Successfully deleted ${data.deleted_count} app password(s)`);
                    deleteField.value = ''; // Clear the field
                    loadAppPasswordsStatus(); // Refresh status
                } else {
                    alert(`‚ùå Error deleting app passwords: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error deleting specific app passwords:', error);
                alert(`‚ùå Error deleting app passwords: ${error.message}`);
            });
    }

    // Clear delete field
    function clearDeleteField() {
        document.getElementById('delete-app-passwords').value = '';
    }

    // Update users list statistics
    function updateUsersListStats(users) {
        const statsDiv = document.getElementById('users-list-stats');
        if (!statsDiv || !users) return;

        // Filter out admin accounts for statistics
        const filteredUsers = users.filter(user => {
            const email = user.email || user.primaryEmail || 'N/A';
            const sourceAccount = user.source_account || 'Unknown';

            // Check if this is an admin account by comparing email with source account
            if (email && sourceAccount && email.toLowerCase() === sourceAccount.toLowerCase()) {
                return false; // Exclude admin account
            }

            // Also check for common admin patterns
            const isAdminAccount = email.toLowerCase().includes('admin') ||
                email.toLowerCase().includes('support') ||
                email.toLowerCase().includes('noreply') ||
                email.toLowerCase().includes('postmaster') ||
                email.toLowerCase().includes('abuse') ||
                email.toLowerCase().includes('webmaster');

            return !isAdminAccount; // Exclude if it's an admin account
        });

        let totalUsers = filteredUsers.length;
        let usersWithPasswords = 0;
        let usersWithoutPasswords = 0;

        filteredUsers.forEach(user => {
            if (user.app_password && user.app_password !== 'No app password') {
                usersWithPasswords++;
            } else {
                usersWithoutPasswords++;
            }
        });

        const passwordPercentage = totalUsers > 0 ? Math.round((usersWithPasswords / totalUsers) * 100) : 0;

        // Enhanced statistics with better styling
        const html = `
        <div style="
            display: flex; 
            gap: 16px; 
            flex-wrap: wrap; 
            align-items: center;
            padding: 16px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        ">
            <div style="
                display: flex; 
                align-items: center; 
                gap: 8px; 
                padding: 10px 16px; 
                background: linear-gradient(135deg, #f6f8fa 0%, #e9ecef 100%); 
                border-radius: 20px; 
                border: 2px solid #d0d7de;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">
                <i class="fas fa-users" style="color: #0969da; font-size: 16px;"></i>
                <span style="color: #24292f; font-weight: 700; font-size: 14px;">Total: ${totalUsers}</span>
            </div>
            <div style="
                display: flex; 
                align-items: center; 
                gap: 8px; 
                padding: 10px 16px; 
                background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); 
                border-radius: 20px; 
                border: 2px solid #10b981;
                box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
            ">
                <i class="fas fa-check-circle" style="color: #059669; font-size: 16px;"></i>
                <span style="color: #065f46; font-weight: 700; font-size: 14px;">With Passwords: ${usersWithPasswords}</span>
            </div>
            <div style="
                display: flex; 
                align-items: center; 
                gap: 8px; 
                padding: 10px 16px; 
                background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); 
                border-radius: 20px; 
                border: 2px solid #ef4444;
                box-shadow: 0 2px 4px rgba(239, 68, 68, 0.2);
            ">
                <i class="fas fa-exclamation-triangle" style="color: #dc2626; font-size: 16px;"></i>
                <span style="color: #991b1b; font-weight: 700; font-size: 14px;">Missing: ${usersWithoutPasswords}</span>
            </div>
            <div style="
                display: flex; 
                align-items: center; 
                gap: 8px; 
                padding: 10px 16px; 
                background: ${passwordPercentage >= 80 ? 'linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%)' : passwordPercentage >= 60 ? 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)' : 'linear-gradient(135deg, #fee2e2 0%, #fecaca 100%)'}; 
                border-radius: 20px; 
                border: 2px solid ${passwordPercentage >= 80 ? '#3b82f6' : passwordPercentage >= 60 ? '#f59e0b' : '#ef4444'};
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">
                <i class="fas fa-percentage" style="color: ${passwordPercentage >= 80 ? '#1d4ed8' : passwordPercentage >= 60 ? '#d97706' : '#dc2626'}; font-size: 16px;"></i>
                <span style="color: ${passwordPercentage >= 80 ? '#1e3a8a' : passwordPercentage >= 60 ? '#92400e' : '#991b1b'}; font-weight: 700; font-size: 14px;">Coverage: ${passwordPercentage}%</span>
            </div>
        </div>
    `;

        statsDiv.innerHTML = html;
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function () {
        // Load status when page loads
        setTimeout(() => {
            console.log('Initializing App Password Manager...');
            loadAppPasswordsStatus();
        }, 500);
    });

    // ===== SIMPLIFIED AUTOMATION AUTHENTICATION FUNCTIONS =====

    // Execute the complete automation process
    function executeAutomationProcess() {
        const accountsList = document.getElementById('automation-accounts-list').value.trim();

        if (!accountsList) {
            alert('Please enter at least one account to process');
            return;
        }

        // Parse accounts list (one per line)
        const accounts = accountsList.split('\n').map(line => line.trim()).filter(line => line);

        if (accounts.length === 0) {
            alert('Please enter valid accounts (one per line)');
            return;
        }

        // Show progress
        document.getElementById('automation-progress').style.display = 'block';
        document.getElementById('automation-progress-bar').style.width = '0%';
        document.getElementById('automation-progress-text').textContent = `Starting automation process for ${accounts.length} accounts...`;

        // Show users display areas immediately
        document.getElementById('automation-users-display').style.display = 'block';
        document.getElementById('automation-users-text-display').style.display = 'block';

        // Clear previous results
        document.getElementById('automation-users-list').innerHTML = '<div class="no-users-message"><i class="fas fa-spinner fa-spin"></i><p>Processing users...</p></div>';
        document.getElementById('automation-users-text').value = 'Processing users...';

        // Load app passwords status
        loadAppPasswordsStatus();

        console.log('Starting SEQUENTIAL automation process for', accounts.length, 'accounts');

        // Start sequential processing
        processAccountsSequentially(accounts);
    }

    async function processAccountsSequentially(accounts) {
        const results = [];
        const allUsers = [];
        let authenticatedCount = 0;
        let usersRetrieved = 0;

        try {
            // First, get the account list from the server
            const initResponse = await fetch('/api/start-automation-process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    accounts: accounts.join('\n')
                })
            });

            if (!initResponse.ok) {
                throw new Error(`HTTP ${initResponse.status}: ${initResponse.statusText}`);
            }

            const initData = await initResponse.json();
            if (!initData.success) {
                throw new Error(initData.error);
            }

            console.log('Initialization successful, processing accounts sequentially...');

            // Process each account individually
            for (let i = 0; i < accounts.length; i++) {
                const account = accounts[i];
                const progressPercent = Math.round(((i + 1) / accounts.length) * 100);

                // Update progress
                document.getElementById('automation-progress-bar').style.width = `${progressPercent}%`;
                document.getElementById('automation-progress-text').textContent = `Processing account ${i + 1}/${accounts.length}: ${account}`;

                console.log(`Processing account ${i + 1}/${accounts.length}: ${account}`);

                try {
                    // Process single account
                    const response = await fetch('/api/process-single-account', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            account: account
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.success) {
                        throw new Error(data.error);
                    }

                    const result = data.result;
                    results.push(result);

                    if (result.success) {
                        authenticatedCount++;
                        if (result.users && result.users.length > 0) {
                            allUsers.push(...result.users);
                            usersRetrieved += result.users_count;
                        }
                    }

                    console.log(`Account ${i + 1} completed: ${result.message}`);

                    // Add small delay between accounts to prevent rate limiting
                    if (i < accounts.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                } catch (error) {
                    console.error(`Error processing account ${account}:`, error);
                    results.push({
                        account: account,
                        success: false,
                        message: `Error processing account: ${error.message}`,
                        users_count: 0,
                        users: []
                    });
                }
            }

            // Update progress to 100%
            document.getElementById('automation-progress-bar').style.width = '100%';
            document.getElementById('automation-progress-text').textContent = 'Automation completed!';

            // Show results
            const finalData = {
                success: true,
                processed_count: accounts.length,
                authenticated_count: authenticatedCount,
                users_retrieved: usersRetrieved,
                all_users: allUsers,
                results: results
            };

            showAutomationResults(finalData);

            // Hide progress after 3 seconds
            setTimeout(() => {
                document.getElementById('automation-progress').style.display = 'none';
            }, 3000);

        } catch (error) {
            console.error('Error in sequential automation process:', error);
            alert('Error executing automation process: ' + error.message);
            document.getElementById('automation-progress').style.display = 'none';
        }
    }

    // Poll automation status
    function pollAutomationStatus(taskId) {
        console.log('Starting polling for task:', taskId);
        let pollCount = 0;
        const maxPolls = 1500; // 50 minutes (1500 * 2 seconds)

        const pollInterval = setInterval(() => {
            pollCount++;
            console.log(`Polling attempt ${pollCount} for task:`, taskId);

            fetch('/api/check-automation-status', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    task_id: taskId
                })
            })
                .then(response => {
                    console.log('Poll response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Poll response data:', data);

                    if (data.success) {
                        if (data.status === 'completed') {
                            clearInterval(pollInterval);
                            console.log('Task completed successfully!');
                            document.getElementById('automation-progress-bar').style.width = '100%';
                            document.getElementById('automation-progress-text').textContent = 'Automation completed!';

                            // Show results
                            showAutomationResults(data);

                            setTimeout(() => {
                                document.getElementById('automation-progress').style.display = 'none';
                            }, 3000);
                        } else if (data.status === 'failed') {
                            clearInterval(pollInterval);
                            console.error('Task failed:', data.error);
                            alert('Automation process failed: ' + data.error);
                            document.getElementById('automation-progress').style.display = 'none';
                        } else {
                            // Update progress
                            const progress = data.progress || 0;
                            document.getElementById('automation-progress-bar').style.width = progress + '%';
                            document.getElementById('automation-progress-text').textContent = `Processing... ${progress}%`;
                        }
                    } else {
                        console.error('Poll error:', data.error);
                        if (data.error.includes('Task not found') || data.error.includes('expired')) {
                            clearInterval(pollInterval);
                            alert('Task not found or expired. The process may have completed but results are no longer available.');
                            document.getElementById('automation-progress').style.display = 'none';
                        } else {
                            // Continue polling for other errors
                            console.log('Continuing to poll despite error:', data.error);
                        }
                    }
                })
                .catch(error => {
                    console.error('Poll fetch error:', error);
                    if (pollCount >= maxPolls) {
                        clearInterval(pollInterval);
                        alert('Polling timeout reached. The process may still be running on the server.');
                        document.getElementById('automation-progress').style.display = 'none';
                    }
                    // Continue polling for network errors
                });

            // Stop polling after max attempts
            if (pollCount >= maxPolls) {
                clearInterval(pollInterval);
                console.log('Max polling attempts reached');
            }
        }, 2000); // Poll every 2 seconds
    }

    // Show automation results
    function showAutomationResults(data) {
        console.log('showAutomationResults called with data:', data);
        console.log('Data keys:', Object.keys(data));
        console.log('Users count:', data.users_retrieved);
        console.log('All users length:', data.all_users ? data.all_users.length : 'undefined');

        const resultsDiv = document.getElementById('automation-results');
        const contentDiv = document.getElementById('automation-results-content');

        if (!resultsDiv || !contentDiv) {
            console.error('Results div elements not found!');
            return;
        }

        let html = `
        <div style="margin-bottom: 16px;">
            <strong>Processed Accounts:</strong> ${data.processed_count || 0}<br>
            <strong>Successfully Authenticated:</strong> ${data.authenticated_count || 0}<br>
            <strong>Users Retrieved:</strong> ${data.users_retrieved || 0}
        </div>
    `;

        if (data.results && data.results.length > 0) {
            html += '<div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background: #f9f9f9;">';
            data.results.forEach(result => {
                const status = result.success ? '‚úÖ' : '‚ùå';
                html += `<div style="margin-bottom: 8px;">
                ${status} <strong>${result.account}</strong> - ${result.message}
            </div>`;
            });
            html += '</div>';
        }

        contentDiv.innerHTML = html;
        resultsDiv.style.display = 'block';

        // If users were retrieved, display them directly from the response
        if (data.users_retrieved > 0 && data.all_users) {
            displayAutomationUsers(data.all_users);
        }
    }

    // Fetch and display users from the last authenticated account
    function fetchAndDisplayAutomationUsers() {
        fetch('/api/retrieve-users', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.users && data.users.length > 0) {
                    displayAutomationUsers(data.users);
                } else {
                    console.log('No users found or error retrieving users');
                }
            })
            .catch(error => {
                console.error('Error fetching users:', error);
            });
    }

    // Display users in the automation users list
    function displayAutomationUsers(users) {
        console.log('displayAutomationUsers called with:', users);
        console.log('Users type:', typeof users);
        console.log('Users length:', users ? users.length : 'undefined');

        const usersListDiv = document.getElementById('automation-users-list');
        const usersTextArea = document.getElementById('automation-users-text');
        const usersDisplayDiv = document.getElementById('automation-users-display');
        const usersTextDisplayDiv = document.getElementById('automation-users-text-display');

        console.log('Displaying users:', users);

        if (!usersListDiv || !usersTextArea || !usersDisplayDiv || !usersTextDisplayDiv) {
            console.error('Required DOM elements not found!');
            return;
        }

        if (!users || users.length === 0) {
            usersListDiv.innerHTML = '<div class="no-users-message"><i class="fas fa-info-circle"></i><p>No users found</p></div>';
            usersTextArea.value = 'No users found';
            usersDisplayDiv.style.display = 'block';
            usersTextDisplayDiv.style.display = 'block';
            return;
        }

        // First, detect user types using the API
        detectUserTypes(users, (userTypes) => {
            // Populate the list view with user types
            let html = '';
            let emailsList = [];
            let filteredUsers = []; // For text area (exclude admins)

            users.forEach((user, index) => {
                const email = user.email || user.primaryEmail || 'N/A';
                const name = user.first_name && user.last_name ? `${user.first_name} ${user.last_name}` : (user.first_name || user.name?.fullName || user.name?.givenName || 'N/A');
                const status = user.suspended ? 'Suspended' : 'Active';
                const sourceAccount = user.source_account || 'Unknown';
                const appPassword = user.app_password || 'No app password';

                // Get user type from API response
                const userTypeInfo = userTypes.find(ut => ut.email === email);
                const userType = userTypeInfo ? userTypeInfo.user_type : 'user';

                console.log(`User: ${email}, Type: ${userType}, App Password: ${appPassword}`);

                // Display all users in the visual list (including admins) with elegant styling
                html += `
                <div class="user-item github-card" style="margin-bottom: 16px; border: 1px solid #d0d7de; border-radius: 8px; overflow: hidden; transition: all 0.2s ease;">
                    <div class="github-card-header" style="padding: 16px; background: ${userType === 'admin' ? '#fff8e1' : '#f6f8fa'}; border-bottom: 1px solid #d0d7de;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                    <div class="email" style="font-weight: 600; font-size: 16px; color: #24292f; line-height: 1.25;">${email}</div>
                                    <span class="user-type-badge" style="
                                        padding: 4px 8px; 
                                        border-radius: 12px; 
                                        font-size: 12px; 
                                        font-weight: 600; 
                                        text-transform: uppercase;
                                        background: ${userType === 'admin' ? '#ff9800' : '#28a745'};
                                        color: white;
                                        letter-spacing: 0.5px;
                                    ">${userType}</span>
                                </div>
                                <div class="name" style="color: #656d76; font-size: 14px; margin-bottom: 4px;">${name}</div>
                                <div class="source-account" style="color: #8b949e; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                                    <i class="fas fa-user-circle"></i>
                                    From: ${sourceAccount}
                                </div>
                            </div>
                            <div class="user-status" style="
                                padding: 6px 12px; 
                                border-radius: 16px; 
                                font-size: 12px; 
                                font-weight: 500;
                                background: ${status === 'Active' ? '#d4edda' : '#f8d7da'};
                                color: ${status === 'Active' ? '#155724' : '#721c24'};
                                border: 1px solid ${status === 'Active' ? '#c3e6cb' : '#f5c6cb'};
                            ">
                                <i class="fas fa-${status === 'Active' ? 'check-circle' : 'exclamation-circle'}"></i>
                                ${status}
                            </div>
                        </div>
                    </div>
                    <div class="github-card-body" style="padding: 16px; background: white;">
                        <div style="display: flex; align-items: center; gap: 8px; color: #656d76; font-size: 13px;">
                            <i class="fas fa-info-circle"></i>
                            <span>User Type: <strong style="color: ${userType === 'admin' ? '#ff9800' : '#28a745'};">${userType.toUpperCase()}</strong></span>
                            ${userType === 'admin' ? '<span style="color: #ff9800; font-weight: 500;">‚Ä¢ Administrative Account</span>' : '<span style="color: #28a745; font-weight: 500;">‚Ä¢ Regular User</span>'}
                        </div>
                    </div>
                </div>
            `;

                emailsList.push(email);

                // Only add non-admin users to the text area
                if (userType !== 'admin') {
                    filteredUsers.push(user);
                }
            });

            usersListDiv.innerHTML = html;

            // Create the SMTP format for the text area: user,app-password,smtp.gmail.com,587 (only non-admin users)
            let smtpFormatList = [];
            filteredUsers.forEach(user => {
                const rawEmail = user.email || user.primaryEmail || 'N/A';
                const email = normalizeEmail(rawEmail);
                let appPassword = user.app_password || 'No app password';

                // Remove SMTP part if it's already included in the app password
                if (appPassword.endsWith(',smtp.gmail.com,587')) {
                    appPassword = appPassword.slice(0, -',smtp.gmail.com,587'.length);
                    console.log(`Removed SMTP part from app password: ${appPassword}`);
                } else if (appPassword.endsWith(',smtp.gmail.com,587,smtp.gmail.com,587')) {
                    appPassword = appPassword.slice(0, -',smtp.gmail.com,587,smtp.gmail.com,587'.length);
                    console.log(`Removed duplicated SMTP part from app password: ${appPassword}`);
                }

                // Always append host:port exactly once
                const smtpLine = `${email},${appPassword},smtp.gmail.com,587`;
                smtpFormatList.push(smtpLine);
            });

            usersTextArea.value = smtpFormatList.join('\n');
            usersDisplayDiv.style.display = 'block';
            usersTextDisplayDiv.style.display = 'block';

            // Update statistics display (only for non-admin users)
            updateUsersListStats(filteredUsers);
        });
    }

    // Detect user types using API
    function detectUserTypes(users, callback) {
        console.log('Detecting user types for', users.length, 'users');

        // Debug: Log the first user to see what fields are available
        if (users.length > 0) {
            console.log('Sample user data:', users[0]);
            console.log('isAdmin field:', users[0].isAdmin);
            console.log('All user fields:', Object.keys(users[0]));
        }

        fetch('/api/detect-user-types', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ users: users })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('User types detected:', data.user_types);
                    // Debug: Log the detection results
                    data.user_types.forEach(ut => {
                        if (ut.user_type === 'admin') {
                            console.log(`Admin detected: ${ut.email}, isAdmin API: ${ut.is_admin_api}`);
                        }
                    });
                    callback(data.user_types);
                } else {
                    console.error('Error detecting user types:', data.error);
                    // Fallback: treat all as users
                    const fallbackTypes = users.map(user => ({
                        email: user.email || user.primaryEmail || 'N/A',
                        user_type: 'user',
                        source_account: user.source_account || 'Unknown'
                    }));
                    callback(fallbackTypes);
                }
            })
            .catch(error => {
                console.error('Error calling user type detection API:', error);
                // Fallback: treat all as users
                const fallbackTypes = users.map(user => ({
                    email: user.email || user.primaryEmail || 'N/A',
                    user_type: 'user',
                    source_account: user.source_account || 'Unknown'
                }));
                callback(fallbackTypes);
            });
    }

    // Copy all automation users
    function copyAutomationUsers() {
        const userElements = document.querySelectorAll('#automation-users-list .user-item .email');
        if (userElements.length === 0) {
            alert('No users to copy');
            return;
        }

        const emails = Array.from(userElements).map(element => element.textContent.trim());
        const emailText = emails.join('\n');

        navigator.clipboard.writeText(emailText).then(() => {
            alert(`‚úÖ Copied ${emails.length} user emails to clipboard`);
        }).catch(() => {
            alert('‚ùå Copy failed - please try manually selecting the text');
        });
    }

    // Copy retrieved users text content
    function copyRetrievedUsersText() {
        const textArea = document.getElementById('automation-users-text');
        if (!textArea) {
            console.error('Text area not found');
            alert('‚ùå Text area not found');
            return;
        }

        const raw = textArea.value.trim();
        if (!raw) {
            alert('‚ùå No text content to copy');
            return;
        }

        // Filter out lines with missing app passwords
        const lines = raw.split('\n');
        const filtered = [];
        lines.forEach(line => {
            if (!line.trim()) return;
            const parts = line.split(',').map(p => p.trim());
            if (parts.length < 2) return; // malformed
            const appPwd = (parts[1] || '').toLowerCase();
            if (!appPwd || appPwd === 'no app password' || appPwd === 'no-app-password') return;

            // Normalize to exactly 4 columns: email, app_password, smtp.gmail.com, 587
            const email = parts[0];
            let appPassword = parts[1];

            // Remove SMTP part if it's already included in the app password
            if (appPassword.endsWith(',smtp.gmail.com,587')) {
                appPassword = appPassword.slice(0, -',smtp.gmail.com,587'.length);
            } else if (appPassword.endsWith(',smtp.gmail.com,587,smtp.gmail.com,587')) {
                appPassword = appPassword.slice(0, -',smtp.gmail.com,587,smtp.gmail.com,587'.length);
            }

            const smtp = parts[2] && parts[2].length ? parts[2] : 'smtp.gmail.com';
            const port = parts[3] && parts[3].length ? parts[3] : '587';
            filtered.push([email, appPassword, smtp, port].join(','));
        });

        if (filtered.length === 0) {
            alert('‚ùå No users with app passwords to copy');
            return;
        }

        const content = filtered.join('\n');
        console.log('Copying filtered text (lines):', filtered.length);

        // Try modern clipboard API first
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(content).then(() => {
                console.log('‚úÖ Text copied to clipboard successfully');
                alert(`‚úÖ Copied ${filtered.length} user(s) with app passwords to clipboard`);
            }).catch(err => {
                console.error('Clipboard API failed:', err);
                // Fallback to legacy method using a temporary textarea
                const temp = document.createElement('textarea');
                temp.value = content;
                document.body.appendChild(temp);
                copyTextFallback(temp);
                document.body.removeChild(temp);
            });
        } else {
            // Fallback for older browsers or non-secure contexts
            const temp = document.createElement('textarea');
            temp.value = content;
            document.body.appendChild(temp);
            copyTextFallback(temp);
            document.body.removeChild(temp);
        }
    }

    // Fallback copy method for older browsers
    function copyTextFallback(textArea) {
        try {
            textArea.select();
            textArea.setSelectionRange(0, 99999); // For mobile devices

            const successful = document.execCommand('copy');
            if (successful) {
                console.log('‚úÖ Text copied using fallback method');
                alert('‚úÖ Copied retrieved users text to clipboard');
            } else {
                console.error('‚ùå Fallback copy failed');
                alert('‚ùå Copy failed - please try manually selecting the text');
            }
        } catch (err) {
            console.error('‚ùå Copy fallback error:', err);
            alert('‚ùå Copy failed - please try manually selecting the text');
        }
    }

    // Export automation users as CSV
    function exportAutomationUsers() {
        console.log('Starting CSV export...');

        // First try to get users from the visual list
        const userElements = document.querySelectorAll('#automation-users-list .user-item');
        console.log('Found visual user elements:', userElements.length);

        let csvContent = 'Email,Name,Status,Source Account,App Password,SMTP Config\n';
        let userCount = 0;

        if (userElements.length > 0) {
            // Export from visual list
            userElements.forEach(element => {
                const email = element.querySelector('.email')?.textContent.trim() || '';
                const name = element.querySelector('.name')?.textContent.trim() || '';
                const status = element.querySelector('.user-status')?.textContent.trim() || '';
                const sourceAccount = element.querySelector('.source-account')?.textContent.replace('From: ', '').trim() || '';

                // Extract app password and SMTP config from the SMTP info section
                const smtpInfo = element.querySelector('.smtp-info div:last-child')?.textContent.trim() || '';
                const smtpParts = smtpInfo.split(',');
                const appPassword = smtpParts.length > 1 ? smtpParts[1] : 'No app password';
                const smtpConfig = smtpInfo || `${email},No app password,smtp.gmail.com,587`;

                csvContent += `"${email}","${name}","${status}","${sourceAccount}","${appPassword}","${smtpConfig}"\n`;
                userCount++;
            });
        } else {
            // Fallback: try to get users from text area
            const textArea = document.getElementById('automation-users-text');
            if (textArea && textArea.value.trim()) {
                console.log('Using text area content for export');
                const lines = textArea.value.trim().split('\n');
                lines.forEach(line => {
                    if (line.trim()) {
                        const parts = line.split(',');
                        if (parts.length >= 4) {
                            const email = parts[0];
                            const appPassword = parts[1];
                            const smtpServer = parts[2];
                            const smtpPort = parts[3];
                            csvContent += `"${email}","","","","${appPassword}","${email},${appPassword},${smtpServer},${smtpPort}"\n`;
                            userCount++;
                        }
                    }
                });
            }
        }

        if (userCount === 0) {
            alert('‚ùå No users to export');
            return;
        }

        console.log(`Exporting ${userCount} users to CSV`);

        try {
            // Create and download CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bulk_automation_users_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.csv`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            console.log('‚úÖ CSV file downloaded successfully');
            alert(`‚úÖ CSV file downloaded successfully (${userCount} users exported)`);
        } catch (error) {
            console.error('‚ùå CSV export failed:', error);
            alert('‚ùå CSV export failed: ' + error.message);
        }
    }

    // Ready to Test - Copy one user from each account
    function readyToTest() {
        console.log('üöÄ Ready to Test button clicked!');
        console.log('Starting Ready to Test - selecting one user per account...');

        const textArea = document.getElementById('automation-users-text');
        console.log('Text area found:', textArea);
        console.log('Text area value length:', textArea ? textArea.value.length : 'N/A');

        if (!textArea) {
            alert('‚ùå Text area not found. Please refresh the page and try again.');
            return;
        }

        if (!textArea.value.trim()) {
            alert('‚ùå No users found. Please run automation process first.');
            return;
        }

        const lines = textArea.value.trim().split('\n');
        const accountUsers = new Map(); // Map to store one user per account
        const allDomains = new Set(); // Track all domains seen
        let totalUsers = 0;
        let accountsFound = 0;

        console.log(`Processing ${lines.length} user lines...`);

        // Process each line to group users by account (domain)
        lines.forEach((line, index) => {
            if (line.trim()) {
                const parts = line.split(',');
                if (parts.length >= 4) {
                    const email = parts[0].trim();
                    const appPassword = parts[1].trim();
                    const smtpServer = parts[2].trim();
                    const smtpPort = parts[3].trim();

                    // Extract domain from email (everything after @)
                    const domainMatch = email.match(/@(.+)$/);
                    if (domainMatch) {
                        const domain = domainMatch[1];
                        allDomains.add(domain); // Track all domains
                        totalUsers++;

                        // Check if this is a valid user (not admin, has app password)
                        const isValidUser = !email.toLowerCase().includes('administrator') &&
                            !appPassword.toLowerCase().includes('no app password') &&
                            appPassword !== '' &&
                            appPassword !== 'No app password';

                        if (isValidUser) {
                            // Only store the first valid user for each domain (account)
                            if (!accountUsers.has(domain)) {
                                accountUsers.set(domain, {
                                    email: email,
                                    appPassword: appPassword,
                                    smtpServer: smtpServer,
                                    smtpPort: smtpPort,
                                    line: line
                                });
                                accountsFound++;
                                console.log(`‚úÖ Account ${accountsFound}: ${domain} -> ${email}`);
                            }
                        } else {
                            console.log(`‚ùå Skipping ${email} - administrator or no app password`);
                        }
                    }
                }
            }
        });

        if (accountsFound === 0) {
            alert('‚ùå No valid users found. Please check the format.');
            return;
        }

        // Create the test-ready list (one user per account) in username:password format
        const testUsers = Array.from(accountUsers.values());
        const testList = testUsers.map(user =>
            `${user.email}:${user.appPassword}`
        ).join('\n');

        console.log(`Ready to Test: ${accountsFound} valid accounts found from ${allDomains.size} total domains (${totalUsers} total users)`);
        console.log('Selected users:', testUsers.map(u => u.email));
        console.log('All domains seen:', Array.from(allDomains));
        console.log('Domains with valid users:', Array.from(accountUsers.keys()));

        // Copy to clipboard with fallback
        console.log('Attempting to copy to clipboard...');
        console.log('Test list:', testList);

        if (navigator.clipboard && window.isSecureContext) {
            // Modern clipboard API
            navigator.clipboard.writeText(testList).then(() => {
                console.log('‚úÖ Test users copied to clipboard');
                alert(`‚úÖ Ready to Test!\n\nüìä Selected ${accountsFound} users (one per account)\nüìã Copied to clipboard\n\nFormat: username:app_password`);
            }).catch(err => {
                console.error('Clipboard API failed:', err);
                fallbackCopy(testList, accountsFound);
            });
        } else {
            // Fallback for older browsers or non-secure contexts
            console.log('Using fallback copy method');
            fallbackCopy(testList, accountsFound);
        }

        function fallbackCopy(text, count) {
            // Create temporary textarea
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = text;
            tempTextArea.style.position = 'fixed';
            tempTextArea.style.left = '-9999px';
            tempTextArea.style.top = '-9999px';
            document.body.appendChild(tempTextArea);
            tempTextArea.focus();
            tempTextArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    console.log('‚úÖ Test users copied to clipboard (fallback)');
                    alert(`‚úÖ Ready to Test!\n\nüìä Selected ${count} users (one per account)\nüìã Copied to clipboard\n\nFormat: username:app_password`);
                } else {
                    throw new Error('execCommand failed');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert(`‚úÖ Ready to Test!\n\nüìä Selected ${count} users (one per account)\n\nüìã Copy this text manually:\n\n${text}`);
            } finally {
                document.body.removeChild(tempTextArea);
            }
        }
    }

    // Clear automation list
    function clearAutomationList() {
        if (confirm('Are you sure you want to clear the accounts list?')) {
            document.getElementById('automation-accounts-list').value = '';
            document.getElementById('automation-results').style.display = 'none';
            document.getElementById('automation-users-display').style.display = 'none';
            document.getElementById('automation-users-text-display').style.display = 'none';
        }
    }

</script>

<!-- Mega Upgrade Modal -->
<div id="megaUpgradeModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 1200px; width: 95%;">
        <div class="modal-header">
            <h2><i class="fas fa-rocket"></i> Mega Upgrade: Single Account Workflow</h2>
            <span class="close" onclick="closeMegaUpgradeModal()">&times;</span>
        </div>

        <div class="modal-body">
            <!-- Feature Selection -->
            <div style="margin-bottom: 24px;">
                <h3 style="margin-bottom: 16px; color: #24292f;">
                    <i class="fas fa-cogs"></i> Select Features to Apply
                </h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px;">
                    <label class="checkbox-container">
                        <input type="checkbox" id="feature-authenticate" checked>
                        <span class="checkmark"></span>
                        <i class="fas fa-key"></i> Authenticate Accounts
                    </label>
                    <label class="checkbox-container">
                        <input type="checkbox" id="feature-change-subdomain" checked>
                        <span class="checkmark"></span>
                        <i class="fas fa-exchange-alt"></i> Auto Change Subdomain
                    </label>
                </div>
            </div>

            <!-- Account Input -->
            <div style="margin-bottom: 24px;">
                <h3 style="margin-bottom: 16px; color: #24292f;">
                    <i class="fas fa-users"></i> Account Processing
                </h3>
                <div class="form-group-github">
                    <label for="mega-single-account" class="form-label-github">
                        <i class="fas fa-envelope"></i> Account Emails (one per line)
                    </label>
                    <textarea id="mega-single-account" class="form-control-github" rows="6"
                        placeholder="support@domain1.com\ninfo@domain2.com\nadmin@domain3.com"
                        style="font-family: monospace; font-size: 13px; resize: vertical;"></textarea>
                    <small style="color: #656d76; font-size: 12px;">
                        Enter one or multiple account emails (one per line). The system will process them in parallel
                        with up to 6 concurrent workers.
                    </small>
                </div>

                <div class="form-group-github">
                    <label for="mega-subdomain-prefix" class="form-label-github">
                        <i class="fas fa-globe"></i> Subdomain Prefix (Optional)
                    </label>
                    <input type="text" id="mega-subdomain-prefix" class="form-control-github"
                        placeholder="5fgckso88gxtvm5a (leave empty for random)"
                        style="font-family: monospace; font-size: 13px;">
                    <small style="color: #656d76; font-size: 12px;">
                        Enter a custom subdomain prefix or leave empty for random generation. Format: prefix.domain.com
                    </small>
                </div>
            </div>

            <!-- Progress Section -->
            <div id="megaUpgradeProgress" style="display: none; margin-bottom: 24px;">
                <h3 style="margin-bottom: 16px; color: #24292f;">
                    <i class="fas fa-tasks"></i> Progress
                </h3>
                <div style="background: #f6f8fa; border: 1px solid #d0d7de; border-radius: 6px; padding: 16px;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span id="megaProgressText">Initializing...</span>
                        <span id="megaProgressPercent">0%</span>
                    </div>
                    <div style="background: #d0d7de; border-radius: 3px; height: 8px; overflow: hidden;">
                        <div id="megaProgressBar"
                            style="background: #2da44e; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 12px; justify-content: center;">
                <button onclick="startMegaUpgrade()" class="btn-github btn-github-primary" id="megaStartBtn">
                    <i class="fas fa-play"></i> Run Mega Upgrade
                </button>
                <button onclick="debugMegaUpgrade()" class="btn-github"
                    style="background-color: #6f42c1; border-color: #6f42c1; color: white;">
                    <i class="fas fa-bug"></i> Debug Mega Upgrade
                </button>
                <button onclick="stopMegaUpgrade()" class="btn-github"
                    style="background-color: #d73a49; border-color: #d73a49; color: white;" id="megaStopBtn"
                    style="display: none;">
                    <i class="fas fa-stop"></i> Stop Process
                </button>
                <button onclick="clearMegaUpgradeResults()" class="btn-github">
                    <i class="fas fa-broom"></i> Clear Results
                </button>
            </div>
        </div>
    </div>
</div>

</script>
{% endblock %}

{% block scripts %}
<style>
    /* Modal Styles */
    .modal {
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background-color: #fefefe;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        max-height: 90vh;
        overflow-y: auto;
    }

    .modal-header {
        padding: 20px;
        border-bottom: 1px solid #e1e4e8;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .modal-header h2 {
        margin: 0;
        color: #24292f;
    }

    .close {
        color: #aaa;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }

    .close:hover {
        color: #000;
    }

    .modal-body {
        padding: 20px;
    }

    /* Checkbox Styles */
    .checkbox-container {
        display: block;
        position: relative;
        padding-left: 35px;
        margin-bottom: 12px;
        cursor: pointer;
        font-size: 14px;
        user-select: none;
    }

    .checkbox-container input {
        position: absolute;
        opacity: 0;
        cursor: pointer;
        height: 0;
        width: 0;
    }

    .checkmark {
        position: absolute;
        top: 0;
        left: 0;
        height: 20px;
        width: 20px;
        background-color: #eee;
        border-radius: 4px;
        border: 1px solid #d0d7de;
    }

    .checkbox-container:hover input~.checkmark {
        background-color: #f6f8fa;
    }

    .checkbox-container input:checked~.checkmark {
        background-color: #2da44e;
        border-color: #2da44e;
    }

    .checkmark:after {
        content: "";
        position: absolute;
        display: none;
    }

    .checkbox-container input:checked~.checkmark:after {
        display: block;
    }

    .checkbox-container .checkmark:after {
        left: 6px;
        top: 2px;
        width: 6px;
        height: 10px;
        border: solid white;
        border-width: 0 2px 2px 0;
        transform: rotate(45deg);
    }
</style>

<script>
    // CRITICAL: This MUST execute - if you don't see this, script isn't loading
    console.log('=== DOMAIN VERIFICATION SCRIPT LOADING ===');
    console.log('Script execution started at:', new Date().toISOString());

    // Domain Verification Variables - MUST be defined BEFORE function
    let domainVerificationJobId = null;
    let domainVerificationPollInterval = null;
    let domainVerificationInProgress = false; // Lock to prevent duplicate calls

    // Define function DIRECTLY on window - SIMPLE AND DIRECT
    console.log('About to define window.startDomainVerification...');
    window.startDomainVerification = function () {
        console.log('üöÄ startDomainVerification() called');

        // Prevent duplicate calls
        if (domainVerificationInProgress) {
            console.warn('‚ö†Ô∏è Domain verification already in progress, ignoring duplicate call');
            return;
        }
        domainVerificationInProgress = true;

        // Disable button immediately
        const btn = document.getElementById('domain-verification-start-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        }

        try {
            const inputEl = document.getElementById('domain-verification-input');
            if (!inputEl) {
                throw new Error('Domain input field not found!');
            }
            const input = inputEl.value.trim();
            console.log('üìù Input value:', input);

            if (!input) {
                console.error('‚ùå No input provided');
                domainVerificationInProgress = false; // Reset lock on early return
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                }
                if (typeof logBulkDomain === 'function') {
                    logBulkDomain('‚ùå Error: Please enter at least one domain');
                }
                alert('Please enter at least one domain');
                return;
            }

            if (typeof isAuthenticated === 'undefined' || !isAuthenticated) {
                console.error('‚ùå Not authenticated');
                domainVerificationInProgress = false; // Reset lock on early return
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                }
                if (typeof logBulkDomain === 'function') {
                    logBulkDomain('‚ùå Error: Please authenticate an account first');
                }
                alert('Please authenticate an account first');
                return;
            }

            const domains = input.split('\n').map(d => d.trim()).filter(d => d);
            if (domains.length === 0) {
                console.error('‚ùå No valid domains');
                domainVerificationInProgress = false; // Reset lock on early return
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                }
                if (typeof logBulkDomain === 'function') {
                    logBulkDomain('‚ùå Error: No valid domains found');
                }
                alert('No valid domains found');
                return;
            }

            const dryRun = document.getElementById('domain-verification-dry-run').checked;
            const skipVerified = document.getElementById('domain-verification-skip-verified').checked;

            const provider = document.querySelector('input[name="dns_provider"]:checked').value;

            console.log('üìã Processing domains:', domains);
            console.log('‚öôÔ∏è Options - Dry-run:', dryRun, 'Skip verified:', skipVerified, 'Provider:', provider);

            // Log to Results Log
            if (typeof logBulkDomain === 'function') {
                logBulkDomain('üöÄ Starting Domain Addition & Verification Process...');
                logBulkDomain(`üìã Domains to process: ${domains.length}`);
                domains.forEach((domain, idx) => {
                    logBulkDomain(`   ${idx + 1}. ${domain}`);
                });
                logBulkDomain(`‚öôÔ∏è Options: Dry-run=${dryRun}, Skip verified=${skipVerified}, Provider=${provider}`);
            } else {
                console.warn('logBulkDomain function not available');
            }

            // Show status table
            document.getElementById('domain-verification-status').style.display = 'block';
            document.getElementById('domain-verification-log-container').style.display = 'block';

            // Clear previous results
            document.getElementById('domain-verification-table-body').innerHTML = '';
            document.getElementById('domain-verification-log').textContent = '';

            // Button already disabled at start of function

            // Start process
            if (typeof logBulkDomain === 'function') {
                logBulkDomain('üì° Sending request to server...');
            }
            console.log('üì° Fetching /api/domains/add-and-verify...');

            fetch('/api/domains/add-and-verify', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    domains: domains,
                    dryRun: dryRun,
                    skipVerified: skipVerified,
                    provider: provider
                })
            })
                .then(response => {
                    console.log('üì• Response received:', response.status, response.statusText);
                    if (!response.ok) {
                        return response.json().then(data => {
                            throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('‚úÖ Response data:', data);
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                    }

                    if (data.success) {
                        domainVerificationJobId = data.job_id;
                        console.log('‚úÖ Job started:', data.job_id);
                        if (typeof logBulkDomain === 'function') {
                            logBulkDomain(`‚úÖ Verification job started successfully`);
                            logBulkDomain(`üÜî Job ID: ${data.job_id}`);
                            logBulkDomain(`üìä Processing ${data.accepted} domain(s)...`);
                        }
                        if (typeof logDomainVerification === 'function') {
                            logDomainVerification(`‚úÖ Started verification job: ${data.job_id}`);
                            logDomainVerification(`üìä Processing ${data.accepted} domains...`);
                        }

                        // Start polling
                        if (typeof startDomainVerificationPolling === 'function') {
                            startDomainVerificationPolling();
                        } else {
                            console.error('startDomainVerificationPolling not found');
                        }
                    } else {
                        const errorMsg = data.error || 'Failed to start verification';
                        console.error('Failed to start:', errorMsg);
                        domainVerificationInProgress = false; // Reset lock on error
                        if (typeof logBulkDomain === 'function') {
                            logBulkDomain(`‚ùå Failed to start verification: ${errorMsg}`);
                        }
                        if (typeof logDomainVerification === 'function') {
                            logDomainVerification(`‚ùå Error: ${errorMsg}`);
                        }
                        alert('Failed to start verification: ' + errorMsg + '\n\nCheck console (F12) for details.');
                    }
                })
                .catch(error => {
                    console.error('‚ùå Fetch error:', error);
                    console.error('Error details:', error);
                    domainVerificationInProgress = false; // Reset lock on error
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                    }
                    const errorMsg = error.message || String(error);
                    console.error('Error message:', errorMsg);
                    if (typeof logBulkDomain === 'function') {
                        logBulkDomain(`‚ùå Network/API Error: ${errorMsg}`);
                    }
                    if (typeof logDomainVerification === 'function') {
                        logDomainVerification(`‚ùå Network error: ${errorMsg}`);
                    }
                    alert('Error: ' + errorMsg + '\n\nCheck browser console (F12) for details.');
                });
        } catch (error) {
            console.error('‚ùå startDomainVerification error:', error);
            console.error('Error stack:', error.stack);
            domainVerificationInProgress = false; // Reset lock on error
            if (typeof logBulkDomain === 'function') {
                logBulkDomain(`‚ùå JavaScript Error: ${error.message || String(error)}`);
            }
            alert('Error: ' + (error.message || String(error)));
        }
    };

    window.stopDomainVerification = function () {
        console.log('üõë stopDomainVerification() called');

        if (!domainVerificationJobId) {
            console.warn('No active job to stop');
            alert('No active process to stop');
            return;
        }

        const btn = document.getElementById('domain-verification-stop-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Stopping...';
        }

        fetch('/api/domains/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ job_id: domainVerificationJobId })
        })
            .then(response => response.json())
            .then(data => {
                console.log('üõë Stop response:', data);
                if (data.success) {
                    if (typeof logBulkDomain === 'function') {
                        logBulkDomain('üõë Process stopped by user');
                    }
                    // Clear polling and reset state
                    if (domainVerificationPollInterval) {
                        clearInterval(domainVerificationPollInterval);
                        domainVerificationPollInterval = null;
                    }
                    domainVerificationJobId = null;
                    domainVerificationInProgress = false; // CRITICAL: Reset lock
                } else {
                    alert('Failed to stop process: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error stopping process:', error);
                alert('Error stopping process: ' + error.message);
            })
            .finally(() => {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-stop"></i> Stop Process';
                }
                // Also reset start button
                const startBtn = document.getElementById('domain-verification-start-btn');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                }
            });
    };

    // Verify Unverified Domains - triggers verification for all domains that have TXT records but are not yet verified
    window.verifyUnverifiedDomains = function () {
        console.log('üîÑ verifyUnverifiedDomains() called');

        if (typeof isAuthenticated === 'undefined' || !isAuthenticated) {
            alert('Please authenticate an account first');
            return;
        }

        const btn = document.getElementById('verify-unverified-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Verifying...';
        }

        // Show status table
        const statusDiv = document.getElementById('domain-verification-status');
        if (statusDiv) statusDiv.style.display = 'block';

        // Show log container
        const logContainer = document.getElementById('domain-verification-log-container');
        if (logContainer) logContainer.style.display = 'block';

        if (typeof logBulkDomain === 'function') {
            logBulkDomain('üîÑ Starting verification of unverified domains...');
        }

        fetch('/api/domains/verify-unverified', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_name: currentAccountName })
        })
            .then(response => response.json())
            .then(data => {
                console.log('üì¶ Verify unverified response:', data);

                if (data.success) {
                    if (typeof logBulkDomain === 'function') {
                        logBulkDomain(`‚úÖ Started verification for ${data.total_domains || 0} domains`);
                        if (data.domains && data.domains.length > 0) {
                            data.domains.forEach((domain, idx) => {
                                logBulkDomain(`   ${idx + 1}. ${domain}`);
                            });
                        }
                        logBulkDomain('üìä Job ID: ' + data.job_id);
                    }

                    // Start polling for verification status
                    if (data.job_id) {
                        domainVerificationJobId = data.job_id;
                        startDomainVerificationPolling();
                    }

                    // Also immediately refresh the domain status table
                    if (data.domains && data.domains.length > 0) {
                        const tbody = document.getElementById('domain-verification-table-body');
                        if (tbody) {
                            data.domains.forEach(domain => {
                                const existingRow = document.querySelector(`tr[data-domain="${domain}"]`);
                                if (!existingRow) {
                                    const row = document.createElement('tr');
                                    row.setAttribute('data-domain', domain);
                                    row.innerHTML = `
                                    <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">${domain}</td>
                                    <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">PENDING</span></td>
                                    <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">PENDING</span></td>
                                    <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">VERIFYING</span></td>
                                    <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">Verification in progress...</td>
                                    <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">${new Date().toLocaleString()}</td>
                                `;
                                    tbody.appendChild(row);
                                }
                            });
                        }
                    }
                } else {
                    if (typeof logBulkDomain === 'function') {
                        logBulkDomain('‚ùå Error: ' + (data.error || 'Unknown error'));
                    }
                    alert('Error: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('‚ùå Error verifying unverified domains:', error);
                if (typeof logBulkDomain === 'function') {
                    logBulkDomain('‚ùå Error: ' + error.message);
                }
                alert('Error: ' + error.message);
            })
            .finally(() => {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-check-double"></i> Verify Unverified Domains';
                }
            });
    };


    // ===== BULK MULTI-ACCOUNT DOMAIN VERIFICATION =====
    let bulkMultiJobId = null;
    let bulkMultiPollInterval = null;
    let bulkMultiParsedEntries = [];

    window.parseBulkMultiAccountDomains = function () {
        console.log('üìã parseBulkMultiAccountDomains() called');

        const input = document.getElementById('bulk-multi-account-input').value.trim();
        if (!input) {
            alert('Please paste entries first');
            return;
        }

        const lines = input.split('\n').filter(line => line.trim());
        bulkMultiParsedEntries = [];

        lines.forEach((line, idx) => {
            // Parse format: admin@account.com,domain.fun OR admin@account.com:domain.fun
            // Split by comma or colon (but not the @ in email)
            let adminEmail, domain;

            // Try comma first
            if (line.includes(',')) {
                const parts = line.split(',');
                adminEmail = parts[0].trim();
                domain = parts[1] ? parts[1].trim() : '';
            }
            // Try colon (but not in http://)
            else if (line.includes(':') && !line.includes('http')) {
                const parts = line.split(':');
                adminEmail = parts[0].trim();
                domain = parts[1] ? parts[1].trim() : '';
            }
            // Try tab/spaces as fallback
            else {
                const parts = line.split(/\t+|\s{2,}/);
                if (parts.length >= 2) {
                    adminEmail = parts[0].trim();
                    domain = parts[1].trim();
                }
            }

            if (adminEmail && domain && adminEmail.includes('@')) {
                // Extract account domain from email (e.g., admin@account.com -> account.com)
                const emailParts = adminEmail.split('@');
                const accountDomain = emailParts.length > 1 ? emailParts[1] : adminEmail;

                bulkMultiParsedEntries.push({
                    index: idx + 1,
                    domain: domain,
                    adminEmail: adminEmail,
                    accountDomain: accountDomain,
                    authStatus: 'pending',
                    workspaceStatus: 'pending',
                    dnsStatus: 'pending',
                    verifyStatus: 'pending',
                    message: 'Ready'
                });
            }
        });

        if (bulkMultiParsedEntries.length === 0) {
            alert('No valid entries found. Use format: admin@account.com,domain.fun');
            return;
        }

        // Show table and populate it
        const scheduleDiv = document.getElementById('bulk-multi-schedule');
        scheduleDiv.style.display = 'block';
        document.getElementById('bulk-multi-count').textContent = bulkMultiParsedEntries.length;

        const tbody = document.getElementById('bulk-multi-table-body');
        tbody.innerHTML = '';

        bulkMultiParsedEntries.forEach(entry => {
            const row = document.createElement('tr');
            row.id = `bulk-multi-row-${entry.index}`;
            row.innerHTML = `
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">${entry.index}</td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">${entry.domain}</td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">${entry.adminEmail}</td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">PENDING</span></td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">PENDING</span></td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">PENDING</span></td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);"><span class="status-badge status-pending">PENDING</span></td>
                <td style="padding: 8px; border-bottom: 1px solid var(--color-border-default);">${entry.message}</td>
            `;
            tbody.appendChild(row);
        });

        // Show log container
        document.getElementById('bulk-multi-log-container').style.display = 'block';
        logBulkMulti('üìã Parsed ' + bulkMultiParsedEntries.length + ' entries. Click "Start All" to begin processing.');

        console.log('üìã Parsed entries:', bulkMultiParsedEntries);
    };

    window.startBulkMultiAccountVerification = function () {
        console.log('üöÄ startBulkMultiAccountVerification() called');

        if (bulkMultiParsedEntries.length === 0) {
            alert('Please parse entries first using "Parse & Preview"');
            return;
        }

        const provider = document.querySelector('input[name="bulk_dns_provider"]:checked').value;

        const btn = document.getElementById('bulk-multi-start-btn');
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
        }

        logBulkMulti('üöÄ Starting bulk multi-account verification for ' + bulkMultiParsedEntries.length + ' entries...');
        logBulkMulti('üìß DNS Provider: ' + provider);

        fetch('/api/domains/bulk-multi-account/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                entries: bulkMultiParsedEntries,
                provider: provider
            })
        })
            .then(response => response.json())
            .then(data => {
                console.log('üì¶ Start response:', data);

                if (data.success) {
                    bulkMultiJobId = data.job_id;
                    logBulkMulti('‚úÖ Job started: ' + data.job_id);
                    startBulkMultiPolling();
                } else {
                    logBulkMulti('‚ùå Error: ' + (data.error || 'Unknown error'));
                    alert('Error: ' + (data.error || 'Unknown error'));
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-play"></i> Start All';
                    }
                }
            })
            .catch(error => {
                console.error('Error:', error);
                logBulkMulti('‚ùå Error: ' + error.message);
                alert('Error: ' + error.message);
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Start All';
                }
            });
    };

    window.stopBulkMultiAccountVerification = function () {
        console.log('üõë stopBulkMultiAccountVerification() called');

        if (!bulkMultiJobId) {
            alert('No active job to stop');
            return;
        }

        fetch('/api/domains/bulk-multi-account/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ job_id: bulkMultiJobId })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logBulkMulti('üõë Job stopped');
                    if (bulkMultiPollInterval) {
                        clearInterval(bulkMultiPollInterval);
                        bulkMultiPollInterval = null;
                    }
                    bulkMultiJobId = null;

                    const btn = document.getElementById('bulk-multi-start-btn');
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fas fa-play"></i> Start All';
                    }
                }
            })
            .catch(error => {
                console.error('Error stopping:', error);
            });
    };

    window.clearBulkMultiAccountInput = function () {
        document.getElementById('bulk-multi-account-input').value = '';
        document.getElementById('bulk-multi-schedule').style.display = 'none';
        document.getElementById('bulk-multi-log').innerHTML = '';
        bulkMultiParsedEntries = [];
    };

    window.toggleBulkMultiLog = function () {
        const log = document.getElementById('bulk-multi-log');
        const icon = document.getElementById('bulk-multi-log-toggle-icon');
        if (log.style.display === 'none') {
            log.style.display = 'block';
            icon.className = 'fas fa-chevron-up';
        } else {
            log.style.display = 'none';
            icon.className = 'fas fa-chevron-down';
        }
    };

    function logBulkMulti(message) {
        const log = document.getElementById('bulk-multi-log');
        if (log) {
            const timestamp = new Date().toLocaleTimeString();
            log.innerHTML += `[${timestamp}] ${message}\n`;
            log.scrollTop = log.scrollHeight;
        }
    }

    function startBulkMultiPolling() {
        if (bulkMultiPollInterval) clearInterval(bulkMultiPollInterval);

        bulkMultiPollInterval = setInterval(() => {
            if (!bulkMultiJobId) {
                clearInterval(bulkMultiPollInterval);
                return;
            }

            fetch(`/api/domains/bulk-multi-account/status/${bulkMultiJobId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.entries) {
                        updateBulkMultiTable(data.entries);

                        // Check if all complete
                        if (data.status === 'completed' || data.status === 'stopped' || data.status === 'failed') {
                            logBulkMulti('‚úÖ Job ' + data.status);
                            clearInterval(bulkMultiPollInterval);
                            bulkMultiPollInterval = null;
                            bulkMultiJobId = null;

                            const btn = document.getElementById('bulk-multi-start-btn');
                            if (btn) {
                                btn.disabled = false;
                                btn.innerHTML = '<i class="fas fa-play"></i> Start All';
                            }
                        }
                    }
                })
                .catch(error => console.error('Poll error:', error));
        }, 2000);
    }

    function updateBulkMultiTable(entries) {
        entries.forEach(entry => {
            const row = document.getElementById(`bulk-multi-row-${entry.index}`);
            if (row) {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 8) {
                    cells[3].innerHTML = getStatusBadge(entry.authStatus);
                    cells[4].innerHTML = getStatusBadge(entry.workspaceStatus);
                    cells[5].innerHTML = getStatusBadge(entry.dnsStatus);
                    cells[6].innerHTML = getStatusBadge(entry.verifyStatus);
                    cells[7].textContent = entry.message || '';
                }
            }
        });
    }

    function getStatusBadge(status) {
        const statusMap = {
            'pending': '<span class="status-badge status-pending">PENDING</span>',
            'running': '<span class="status-badge" style="background-color:#0969da;color:#fff;">RUNNING</span>',
            'success': '<span class="status-badge status-success">SUCCESS</span>',
            'failed': '<span class="status-badge status-failed">FAILED</span>',
            'skipped': '<span class="status-badge" style="background-color:#6c757d;color:#fff;">SKIPPED</span>'
        };
        return statusMap[status] || statusMap['pending'];
    }

    // Verify function was created IMMEDIATELY
    console.log('Function created, type:', typeof window.startDomainVerification);
    if (typeof window.startDomainVerification === 'function') {
        console.log('‚úÖ‚úÖ‚úÖ startDomainVerification function successfully created ‚úÖ‚úÖ‚úÖ');
    } else {
        console.error('‚ùå‚ùå‚ùå FAILED to create startDomainVerification function! ‚ùå‚ùå‚ùå');
        alert('CRITICAL: Failed to create startDomainVerification function!');
    }

    function startDomainVerificationPolling() {
        if (domainVerificationPollInterval) {
            clearInterval(domainVerificationPollInterval);
        }

        let lastStatusCount = 0;

        domainVerificationPollInterval = setInterval(() => {
            if (!domainVerificationJobId) {
                clearInterval(domainVerificationPollInterval);
                return;
            }

            fetch(`/api/domains/status?job_id=${domainVerificationJobId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        updateDomainVerificationTable(data.results);

                        // Log status changes to Results Log
                        if (data.results.length !== lastStatusCount) {
                            lastStatusCount = data.results.length;
                            logBulkDomain(`üìä Status update: ${data.results.length} domain(s) in progress`);
                        }

                        // Log each domain's status to Results Log
                        data.results.forEach(result => {
                            const statusKey = `${result.domain}_${result.workspace}_${result.dns}_${result.verify}`;
                            if (!window.domainStatusCache) {
                                window.domainStatusCache = {};
                            }

                            if (window.domainStatusCache[result.domain] !== statusKey) {
                                window.domainStatusCache[result.domain] = statusKey;

                                // Log status changes
                                if (result.workspace === 'success' && result.dns === 'pending' && result.verify === 'pending') {
                                    logBulkDomain(`‚úÖ ${result.domain}: Added to Workspace`);
                                } else if (result.workspace === 'failed') {
                                    logBulkDomain(`‚ùå ${result.domain}: Workspace add failed - ${result.message || 'Unknown error'}`);
                                } else if (result.dns === 'success' && result.verify === 'pending') {
                                    logBulkDomain(`‚úÖ ${result.domain}: TXT record created, waiting for verification...`);
                                } else if (result.dns === 'failed') {
                                    logBulkDomain(`‚ùå ${result.domain}: DNS TXT creation failed - ${result.message || 'Unknown error'}`);
                                } else if (result.verify === 'success') {
                                    logBulkDomain(`‚úÖ ${result.domain}: Domain verified successfully!`);
                                } else if (result.verify === 'failed') {
                                    logBulkDomain(`‚ùå ${result.domain}: Verification failed - ${result.message || 'Unknown error'}`);
                                } else if (result.workspace === 'skipped' || result.verify === 'skipped') {
                                    logBulkDomain(`‚è≠Ô∏è ${result.domain}: Skipped (already verified)`);
                                }
                            }
                        });

                        // Check if all domains are complete
                        const allComplete = data.results.every(r =>
                            r.workspace !== 'pending' && r.dns !== 'pending' && r.verify !== 'pending'
                        );

                        if (allComplete && data.results.length > 0) {
                            clearInterval(domainVerificationPollInterval);
                            const successCount = data.results.filter(r => r.verify === 'success').length;
                            const failedCount = data.results.filter(r => r.verify === 'failed' || r.workspace === 'failed' || r.dns === 'failed').length;
                            const skippedCount = data.results.filter(r => r.verify === 'skipped').length;

                            logBulkDomain('‚úÖ All domains processed');
                            logBulkDomain(`üìä Summary: ${successCount} verified, ${failedCount} failed, ${skippedCount} skipped`);
                            logDomainVerification('‚úÖ All domains processed');

                            // CRITICAL: Reset state when job completes
                            domainVerificationJobId = null;
                            domainVerificationInProgress = false;

                            // Re-enable start button
                            const startBtn = document.getElementById('domain-verification-start-btn');
                            if (startBtn) {
                                startBtn.disabled = false;
                                startBtn.innerHTML = '<i class="fas fa-play"></i> Start Process';
                            }
                        }
                    } else {
                        logBulkDomain(`‚ùå Failed to get status: ${data.error || 'Unknown error'}`);
                    }
                })
                .catch(error => {
                    const errorMsg = error.message || String(error);
                    console.error('Polling error:', error);
                    logBulkDomain(`‚ùå Status polling error: ${errorMsg}`);
                });
        }, 5000); // Poll every 5 seconds
    }

    function updateDomainVerificationTable(results) {
        const tbody = document.getElementById('domain-verification-table-body');
        tbody.innerHTML = '';

        if (!results || results.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px; color: #656d76;">No domains processed yet...</td></tr>';
            return;
        }

        results.forEach(result => {
            const row = document.createElement('tr');
            row.style.borderBottom = '1px solid var(--color-border-default)';

            const getStatusBadge = (status) => {
                const colors = {
                    'success': '#2da44e',
                    'failed': '#cf222e',
                    'pending': '#656d76',
                    'skipped': '#bf8700',
                    'dry-run': '#0969da'
                };
                const color = colors[status] || '#656d76';
                return `<span style="background-color: ${color}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600;">${status.toUpperCase()}</span>`;
            };

            // Escape HTML in message to prevent XSS
            const safeMessage = (result.message || '-').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            row.innerHTML = `
            <td style="padding: 8px;">${result.domain}</td>
            <td style="padding: 8px;">${getStatusBadge(result.workspace)}</td>
            <td style="padding: 8px;">${getStatusBadge(result.dns)}</td>
            <td style="padding: 8px;">${getStatusBadge(result.verify)}</td>
            <td style="padding: 8px; max-width: 300px; word-wrap: break-word;">${safeMessage}</td>
            <td style="padding: 8px; font-size: 11px; color: var(--color-fg-muted);">${result.updated_at ? new Date(result.updated_at).toLocaleString() : '-'}</td>
        `;

            tbody.appendChild(row);
        });
    }

    function logDomainVerification(message) {
        const logDiv = document.getElementById('domain-verification-log');
        const timestamp = new Date().toLocaleTimeString();
        logDiv.textContent += `[${timestamp}] ${message}\n`;
        logDiv.scrollTop = logDiv.scrollHeight;

        // Keep only last 100 lines
        const lines = logDiv.textContent.split('\n');
        if (lines.length > 100) {
            logDiv.textContent = lines.slice(-100).join('\n');
        }
    }

    function toggleDomainVerificationLog() {
        const logDiv = document.getElementById('domain-verification-log');
        const icon = document.getElementById('domain-verification-log-toggle-icon');

        if (logDiv.style.display === 'none') {
            logDiv.style.display = 'block';
            icon.className = 'fas fa-chevron-up';
        } else {
            logDiv.style.display = 'none';
            icon.className = 'fas fa-chevron-down';
        }
    }

    // Add event listener as fallback for button click
    document.addEventListener('DOMContentLoaded', function () {
        console.log('üìÑ DOMContentLoaded fired');
        const btn = document.getElementById('domain-verification-start-btn');
        if (btn) {
            console.log('‚úÖ Domain verification button found');
            // NOTE: Button already has onclick handler, no need for duplicate event listener
            // The onclick handler in the HTML calls window.startDomainVerification()
        } else {
            console.warn('‚ö†Ô∏è Domain verification button not found on page load');
        }

        // Verify function is accessible
        console.log('startDomainVerification function type:', typeof window.startDomainVerification);
        if (typeof window.startDomainVerification !== 'function') {
            console.error('‚ùå CRITICAL: startDomainVerification is not a function!');
        }
    });

    // Cache buster and debugging
    console.log('=== DASHBOARD SCRIPT LOADED ===');
    console.log('Dashboard loaded - Version 20241027');
    console.log('updateMegaProgress function:', typeof updateMegaProgress);
    console.log('copyRetrievedSubdomains function:', typeof copyRetrievedSubdomains);
    console.log('startDomainVerification function:', typeof window.startDomainVerification);

    // CRITICAL TEST - Verify function exists
    if (typeof window.startDomainVerification === 'function') {
        console.log('‚úÖ‚úÖ‚úÖ startDomainVerification IS DEFINED AND IS A FUNCTION ‚úÖ‚úÖ‚úÖ');
    } else {
        console.error('‚ùå‚ùå‚ùå CRITICAL ERROR: startDomainVerification IS NOT A FUNCTION ‚ùå‚ùå‚ùå');
        console.error('Type is:', typeof window.startDomainVerification);
        console.error('Value is:', window.startDomainVerification);
        console.error('CRITICAL: startDomainVerification function not found! Check console.');
    }

    // Force reload if needed
    if (typeof updateMegaProgress === 'undefined') {
        console.error('updateMegaProgress function not found - possible caching issue');
    }

    // Additional debugging: Test button click immediately
    setTimeout(function () {
        const btn = document.getElementById('domain-verification-start-btn');
        if (btn) {
            console.log('‚úÖ Domain verification button found in DOM');
            console.log('Button onclick attribute:', btn.getAttribute('onclick'));
            // Test if function is callable
            if (typeof window.startDomainVerification === 'function') {
                console.log('‚úÖ startDomainVerification is callable');
            } else {
                console.error('‚ùå startDomainVerification is NOT a function!');
            }
        } else {
            console.error('‚ùå Domain verification button NOT found in DOM');
        }
    }, 1000);

    // --- GCP Account Management ---



    // --- Add Account Modal Functions ---
    function openAddAccountModal() {
        document.getElementById('addAccountModal').style.display = 'block';
        // Reset form
        document.getElementById('addAccountEmail').value = '';
        document.getElementById('addAccountName').value = '';
        document.getElementById('addAccountJsonFile').value = '';
        document.getElementById('addAccountJsonPreview').style.display = 'none';
        document.getElementById('addAccountStatus').style.display = 'none';
    }

    function closeAddAccountModal() {
        document.getElementById('addAccountModal').style.display = 'none';
    }

    // Handle JSON file selection for preview
    document.getElementById('addAccountJsonFile').addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const jsonContent = JSON.parse(e.target.result);
                // Mask private key for security in preview
                if (jsonContent.private_key) {
                    jsonContent.private_key = "PRIVATE KEY HIDDEN";
                }
                document.getElementById('addAccountJsonContent').textContent = JSON.stringify(jsonContent, null, 2);
                document.getElementById('addAccountJsonPreview').style.display = 'block';
            } catch (err) {
                alert('Invalid JSON file: ' + err.message);
                document.getElementById('addAccountJsonFile').value = '';
                document.getElementById('addAccountJsonPreview').style.display = 'none';
            }
        };
        reader.readAsText(file);
    });

    function submitAddAccount() {
        const email = document.getElementById('addAccountEmail').value.trim();
        const name = document.getElementById('addAccountName').value.trim();
        const fileInput = document.getElementById('addAccountJsonFile');
        const file = fileInput.files[0];

        if (!email) {
            alert('Please enter an account email.');
            return;
        }
        if (!file) {
            alert('Please select a service account JSON file.');
            return;
        }

        const submitBtn = document.getElementById('addAccountSubmitBtn');
        const statusDiv = document.getElementById('addAccountStatus');
        const statusContent = document.getElementById('addAccountStatusContent');

        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';

        statusDiv.style.display = 'block';
        statusContent.innerHTML = 'Uploading and verifying account credentials...';
        statusContent.style.backgroundColor = '#e1e4e8';
        statusContent.style.color = '#24292f';

        const formData = new FormData();
        formData.append('email', email);
        formData.append('name', name || email); // Use email as name if not provided
        formData.append('json_file', file);

        fetch('/api/add-account-json', {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusContent.innerHTML = '<i class="fas fa-check-circle"></i> ' + data.message;
                    statusContent.style.backgroundColor = '#d4edda';
                    statusContent.style.color = '#155724';

                    setTimeout(() => {
                        closeAddAccountModal();
                        location.reload(); // Reload to show new account
                    }, 1500);
                } else {
                    statusContent.innerHTML = '<i class="fas fa-exclamation-circle"></i> Error: ' + data.error;
                    statusContent.style.backgroundColor = '#f8d7da';
                    statusContent.style.color = '#721c24';
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-plus"></i> Add Account';
                }
            })
            .catch(error => {
                console.error('Error:', error);
                statusContent.innerHTML = '<i class="fas fa-exclamation-circle"></i> Network Error: ' + error.message;
                statusContent.style.backgroundColor = '#f8d7da';
                statusContent.style.color = '#721c24';
                submitBtn.disabled = false;
                submitBtn.innerHTML = '<i class="fas fa-plus"></i> Add Account';
            });
    }

    // --- S3 Import Modal Functions ---
    function openS3ImportModal() {
        document.getElementById('s3ImportModal').style.display = 'flex';
        document.getElementById('s3ImportAccounts').value = '';
        document.getElementById('s3ImportProgress').style.display = 'none';
        document.getElementById('s3ImportResults').style.display = 'none';
    }

    function closeS3ImportModal() {
        document.getElementById('s3ImportModal').style.display = 'none';
    }

    async function executeS3Import() {
        const accountsText = document.getElementById('s3ImportAccounts').value.trim();
        if (!accountsText) {
            alert('Please enter at least one account email.');
            return;
        }

        const accounts = accountsText.split('\n').map(a => a.trim()).filter(a => a && a.includes('@'));
        if (accounts.length === 0) {
            alert('No valid email addresses found.');
            return;
        }

        const btn = document.getElementById('s3ImportBtn');
        const progressDiv = document.getElementById('s3ImportProgress');
        const resultsDiv = document.getElementById('s3ImportResults');
        const resultsContent = document.getElementById('s3ImportResultsContent');
        const progressBar = document.getElementById('s3ImportProgressBar');
        const statusText = document.getElementById('s3ImportStatus');
        const countText = document.getElementById('s3ImportCount');

        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Importing...';
        progressDiv.style.display = 'block';
        resultsDiv.style.display = 'block';
        resultsContent.innerHTML = '';
        progressBar.style.width = '0%';

        let successCount = 0;
        let failCount = 0;
        const total = accounts.length;

        for (let i = 0; i < accounts.length; i++) {
            const email = accounts[i];
            statusText.textContent = `Importing ${email}...`;
            countText.textContent = `${i + 1}/${total}`;
            progressBar.style.width = `${((i + 1) / total) * 100}%`;

            try {
                const response = await fetch('/api/import-account-from-s3', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: email })
                });
                const data = await response.json();

                if (data.success) {
                    resultsContent.innerHTML += `<div style="color: #28a745;">‚úÖ ${email}: ${data.message}</div>`;
                    successCount++;
                } else {
                    resultsContent.innerHTML += `<div style="color: #dc3545;">‚ùå ${email}: ${data.error}</div>`;
                    failCount++;
                }
            } catch (error) {
                resultsContent.innerHTML += `<div style="color: #dc3545;">‚ùå ${email}: Network error - ${error.message}</div>`;
                failCount++;
            }

            // Small delay to avoid overwhelming
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        statusText.textContent = `Complete! Success: ${successCount}, Failed: ${failCount}`;
        btn.disabled = false;
        btn.innerHTML = '<i class="fas fa-cloud-download-alt"></i> Import from S3';

        if (successCount > 0) {
            setTimeout(() => {
                if (confirm(`Successfully imported ${successCount} accounts. Reload page to see them?`)) {
                    location.reload();
                }
            }, 500);
        }
    }


    function toggleProviderSettings() {
        // Placeholder for future UI toggles if needed
        const provider = document.querySelector('input[name="dns-provider"]:checked').value;
        console.log("Selected provider:", provider);
    }
</script>
{% endblock %}